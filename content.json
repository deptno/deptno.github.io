{"meta":{"title":"봉로그","subtitle":"do 봉지니어링 | 기술 관련된 글 포스팅은 앞으로 <a href=\"https://medium.com/@deptno\">medium.com/@deptno</a>에 포스팅합니다.","description":"주섬주섬...","author":"deptno@gmail.com","url":"http://blog.bglee.me"},"pages":[{"title":"All categories","date":"2017-07-09T07:29:04.000Z","updated":"2018-03-29T06:03:19.634Z","comments":true,"path":"categories/index.html","permalink":"http://blog.bglee.me/categories/index.html","excerpt":"","text":""},{"title":"All tags","date":"2017-07-09T07:28:08.000Z","updated":"2018-03-29T06:03:19.635Z","comments":true,"path":"tags/index.html","permalink":"http://blog.bglee.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"미디움으로 이사합니다.","slug":"move-to-medium","date":"2018-03-28T15:00:00.000Z","updated":"2018-03-29T06:41:17.921Z","comments":true,"path":"posts/2018/move-to-medium/","link":"","permalink":"http://blog.bglee.me/posts/2018/move-to-medium/","excerpt":"","text":"https://medium.com/@deptno으로 이사합니다. RSS: https://medium.com/feed/@deptno 이 곳엔 가끔 업데이트나 더 개인적인 주제들을 담고자 합니다.","categories":[{"name":"service","slug":"service","permalink":"http://blog.bglee.me/categories/service/"}],"tags":[]},{"title":"Python","slug":"python","date":"2017-11-10T15:00:00.000Z","updated":"2018-03-29T06:03:19.631Z","comments":true,"path":"posts/2017/python/","link":"","permalink":"http://blog.bglee.me/posts/2017/python/","excerpt":"","text":"macOS 기반으로 작성되었다. ml(머신러닝) 공부를 하기 위해 파이썬을 환경을 설정했다. installationbrew는 기본적으로 설치되어 있어야 한다. 참조 설치 각각에 종속성이 있을 수 있으므로 패키지 설치시마다 터미널을 재시작하면서 하도록 한다. 아나콘다라는 파이썬 배포판으로 데이터 사이언스 관련 패키지들을 포함하고 있다. 보통 책들에서 강력히 추천하므로 설치한다. 파이썬 배포판이므로 글을 쓰는 현재 python 3.6.3을 포함하여 설치된다. 1brew cask install anaconda 프로젝트별 독립된 개발 환경을 만들어주는 virtualenv와 이를 편하게 사용하도록 해주는 virtualenvwrapper를 설치한다. 1pip install virtualenv virtualenvwrapper 사용하는 쉘의 설정 파일을 열어 다음을 추가한다. 설정 파일을 쉘에 따라 다르다. ~/.zshrc or ~/.bashrc 1234# python virtualenv settingsexport WORKON_HOME=~/workspace/virtualenvsexport VIRTUALENVWRAPPER_PYTHON=/usr/local/anaconda3/bin/pythonsource /usr/local/anaconda3/bin/virtualenvwrapper.sh ~/workspace/virtualenvs 이 부분은 사람마다 다른 경로를 사용하므로 사용하고자 하는 경로를 쓰면된다. 설정파일이 적용되기 전에(터미널 재시작 전) 폴더를 만들어준다. 1mkdir -p ~/workspace/virtualenvs 터미널을 재시작하면 스크립트가 돌고 아래와 같은 명령어를 사용할 수 있게된다. mkvirtualenv 프로젝트명 rmvirtualenv 프로젝트명 workon 프로젝트명 deactivate ml이라는 가상황경을 위한 라이프 사이클은 아래와 같다. 12345678910# 가상환경를 생성한다.bglee@since-20171107  mkvirtualenv ml# 가상환경를 종료한다.(ml) bglee@since-20171107  deactivate# 가상환경에 진입한다.bglee@since-20171107  workon ml# 가상환경를 종료한다.(ml) bglee@since-20171107  deactivate# 가상환경를 삭제한다.bglee@since-20171107  rmvirtualenv ml 이제 가상환경은 설정이 되었고 프로젝트를 활성화(진입)한 상태로 pip install package_name을 할 경우 가상환경에 패키지가 포함되게 된다.","categories":[{"name":"service","slug":"service","permalink":"http://blog.bglee.me/categories/service/"}],"tags":[{"name":"python","slug":"python","permalink":"http://blog.bglee.me/tags/python/"},{"name":"파이썬","slug":"파이썬","permalink":"http://blog.bglee.me/tags/파이썬/"},{"name":"ml","slug":"ml","permalink":"http://blog.bglee.me/tags/ml/"},{"name":"머신러닝","slug":"머신러닝","permalink":"http://blog.bglee.me/tags/머신러닝/"},{"name":"anaconda","slug":"anaconda","permalink":"http://blog.bglee.me/tags/anaconda/"},{"name":"아나콘다","slug":"아나콘다","permalink":"http://blog.bglee.me/tags/아나콘다/"},{"name":"virtualenv","slug":"virtualenv","permalink":"http://blog.bglee.me/tags/virtualenv/"},{"name":"virtualenvwrapper","slug":"virtualenvwrapper","permalink":"http://blog.bglee.me/tags/virtualenvwrapper/"}]},{"title":"Netlify","slug":"netlify","date":"2017-10-03T15:00:00.000Z","updated":"2018-03-29T06:03:19.627Z","comments":true,"path":"posts/2017/netlify/","link":"","permalink":"http://blog.bglee.me/posts/2017/netlify/","excerpt":"","text":"Netlify 는 스태틱 웹을 위한 CMS다. Git 서비스들을 통해 제공되며 레포지터리에 푸시를 할 경우 이를 자동으로 감지하고 빌드하며 재 배포한다. 여기에 본인이 도메인을 가진게 있다라면 본인의 도메인을 연결하여 서비스 할 수 있다. 스태틱웹은 동적으로 URL을 생성하는 것이 아닌 그냥 실제 html파일 자체로 서빙을 한다고 생각하면 단순하다. Netlify 는 추가적으로 Let’s encrypt 를 서비스 안으로 포함시켜서 SSL(https://) 을 지원하며 이를 위해 DNS를 품고 있다. 자동으로 지원되지만 자신만의 도메인이 있어 이를 사용할 때는 Netlify DNS를 사용해야한다. 이번 &lt;bglee.me&gt;의 DNS를 Netlify 로 옮기면서 모든 페이지에 SSL을 적용하고 기존 블로그는 https://deptno.github.io로 되돌려 하나의 루트로 접근 경로를 통일했으며 기존 https://blog.bglee.me는 이제 SSL을 적용하고 기존 패스 그대로 https://deptno.github.io로 리다이렉트 시키도록 세팅했다. 이를 세팅 과정은 로컬 환경이 아닌 깃헙 레포지터리를 이용할 정도로 단순했고 Netlify 에서 지원하는 리다이렉트 옵션도 매우 직관적이었다.1 배포글을 작성하고 있는 현재 Netlify 에서 지원하고 있는 Git 클라우드 서비스는 아래와 같다. Gitub Gitlab Bitbucket 잠깐 부연하자면 비공개 레포지터리를 만들기 위해서 Github은 유로 플랜을 써야하지만 나머지 둘은 기본적으로 비공개 레포지터리를 개인에게 무료로 허용한다. 로그인하면 바로 사용을 위한 화면이 시작되며 순서는 아래와 같다. 사용하고 있는 레포지터리 서비스를 선택한다.(Git 클라우드 서비스들) 배포에 사용될 레포지터리를 선택한다. 배포에 사용될 브랜치, 빌드시 명령어, 그리고 빌드 명령어를 통해 생성된 배포될 파일들을 가리키는 디렉토리를 작성한다. 그럼 바로 배포가 시작되며 앞으로 레포지터리에 푸시를 할 때마다 자동으로 빌드 =&gt; 배포가 진행된다. 커스텀 도메인과 DNS커스텀 도메인을 을 사용하기 위해서는 domain settings에 들어가서 custom domain을 누르고 본인의 도메인을 입력해야한다. 도메인 셋업은 www.YOUR_DOMAIN을 통해야 SSL서비스를 받을 수 있다. 예를 들어 필자는 www.bglee.me를 입력하고 HTTPS 에서 주소를 확인한뒤에 Force TLS connections를 활성화 시켜 http접속을 https로 강제 리다이렉트 시켰다. Netflify 에서는 bglee.me가 아닌 www.bglee.me를 등록하라고 권고하고 있으며 www.bglee.me를 등록시에 bglee.me도 자동으로 Netlify에 의해 등록되며 &lt;bglee.me&gt; 접속시 &lt;www.bglee.me&gt;로 강제 리다이렉트된다. 추가적인 기능와… 한 기능들을 몇개 지원한다. 브랜치를 통한 A/B 테스트 지원브랜치를 추가적으로 등록할 수 있는데(A/B테스트 메뉴) 자동으로 로드밸런싱을 해서 A/B테스트를 하게 해준다. PR시, 스테이지 URLPR이 왔을시 이에대한 Preview URL을 생성할 수 있으며 이를 스테이지로 활용할 수 있다. next이제 스태틱 사이트를 작성하고 배포해보자.","categories":[{"name":"service","slug":"service","permalink":"http://blog.bglee.me/categories/service/"}],"tags":[{"name":"netlify","slug":"netlify","permalink":"http://blog.bglee.me/tags/netlify/"},{"name":"https","slug":"https","permalink":"http://blog.bglee.me/tags/https/"},{"name":"ssl","slug":"ssl","permalink":"http://blog.bglee.me/tags/ssl/"},{"name":"스태틱 웹","slug":"스태틱-웹","permalink":"http://blog.bglee.me/tags/스태틱-웹/"},{"name":"static web","slug":"static-web","permalink":"http://blog.bglee.me/tags/static-web/"}]},{"title":"TypeScript와 Redux connect","slug":"typescript-redux-connect","date":"2017-10-02T15:00:00.000Z","updated":"2018-03-29T06:03:19.633Z","comments":true,"path":"posts/2017/typescript-redux-connect/","link":"","permalink":"http://blog.bglee.me/posts/2017/typescript-redux-connect/","excerpt":"","text":"타입스크립트와 리덕스로 SPA를 구현하는데 있어 기본적인 셋업이 아닌 문법적인 측면에 포커싱된 글로 타입스크립트를 활용하는데 도움이 되었으면한다. 필자는 하드 타이핑을 하지 않으며 추가적으로 린트를 쓰지 않는다. 리덕스는 자체적으로 타입스크립트 데피니션 파일(d.ts)을 가지고 있으므로 따로 타입 관련 패키지를 설치하지 않아도 된다. 설치12npm install --save-dev typescriptnpm install redux redux리덕스에 대한 설명을 돕기 위해 루트 스토어가 가지는 스테이트의 타입을 아래와 같이 정의하기로한다. 123456789//index.d.tsinterface RootState &#123; bglee: User deptno: User&#125;interface User &#123; name: string email: string&#125; connect(..args)리덕스를 쓰면서 가장 많이 쓰게 되는 함수일텐데 코드를 먼저 보이면 아래와 같다. 12345678910111213141516171819import * as React from 'react'import &#123;connect, bindActionCreataors&#125; from 'redux'interface StateProps &#123;&#125;interface DispatchProps &#123;&#125;interface OwnProps &#123;&#125;type Props = StateProps &amp; DispatchProps &amp; OwnPropsinterface State &#123;&#125;const Container = connect&lt;StateProps, DispatchProps, OwnProps&gt;( (state: RootState) =&gt; (&#123;&#125;), dispatach =&gt; bindActionCreators(&#123;&#125;, dispatch))( class Component extends React.Component&lt;Props, State&gt; &#123; render() &#123; return &lt;p&gt;hello world&lt;/p&gt; &#125; &#125;) 위 코드는 완전히 동작하는 코드이고 컨테이너를 정의하기 위해 풀어쓴 기본적인 형태다. 참고로 connect 함수는 추가적인 옵션을 기술하기 위해 4개까지 인자를 받을 수 있다. connect를 보면 3개의 타입을 받고 있다. 순서대로 살펴 보겠다. StatePropsconnect의 첫번째 인자는 mapStateToProps로 정의되어 있으며 함수 명과 같이 Store의 state를 Component의 props로 주입하는 함수다. 이 함수의 리턴 타입이라고 생각하면 된다. 예를 들어 Store에 bglee라는 프로퍼티를 연결하고자 한다면 mapStateToProps는 아마도 다음과 같이 작성되게 된다. 1const mapStaetToProps = (state: RootState) =&gt; state.bglee 그러면 Container는 props로 bglee가 가지고 있는 name, email을 받게 된다. 그럼 그에 맞춰서 StateProps를 정의하면 된다. 1234interface StateProps &#123; name: string email: string&#125; 작성하고 보니 User 타입과 동일하다. 1type StateProps = User 로 정의해도되고 코드에서 StateProps를 User로 치환해도 된다. 이 경우는 예제를 위해 특수한 케이스기 때문에 이러하지만 여러 state를 props로 연결해야한다라면 곧 확장을 해야하니 StateProps라는 이름의 컨벤션을 유지해서 코드 일관성, 가독성을 확보하자. 다시 mapStateToProps 함수를 구현한 코드를 보면 아래와 같이 보일 것이 의심치 않는다. 1234const mapStaetToProps = (state: RootState): StateProps =&gt; (&#123; name: state.name, email: state.email&#125;) 이해를 돕기 위해 완전히 풀어서 보였다. StateProps가 리턴되고 있다는 것만 인지하고 있으면 되며 위와 같은 코드작성은 connect가 타입을 받는 이유와 상충되므로 줄여서 작성하도록 하자. DispatchProps두번째 인자는 dispatch할 액션들이 Component의 props로 매핑된다. 위와 마찬가지로 두번째 인자의 이름인 mapDispatchToProps의 리턴 타입이다. 완벽한 이해를 위해 아래와 같이 액션이 정의해보자. 123456const contactBglee = (from: string) =&gt; (&#123; type: 'CONTACT_BGLEE' payload: &#123; from &#125;&#125;) 액션은 type을 포함하는 오브젝트를 리턴하는 함수이며 bindActionCreators함수를 통해 dispatch가능한 형태가 된다. 그럼 두번째 인자의 구현부를 다시 보자. 1dispatch = bindActionCreators(&#123;&#125;, dispatch) 이름을 달고 정의한 액션을 바인딩해보자 123const mapDispatchToProps = dispatch =&gt; bindActionCreators(&#123; contactBglee&#125;) 작성된 mapDispatchToProps함수를 두번째 인자로 전달하게 되며 Container는 contactBglee액션을 디스패칭할 수 있다. Container는 contactBglee props를 가지고 있다는 의미며 이를 컴파일러에게 알려주기위해 두번째 DispatchProps는 아래와 같이 정의된다. 123interface Dispatchprops &#123; contactBglee: typeof contactBglee&#125; typeof를 유심히 보자 contactBglee의 액션이 from: string인자를 취하는데 이를 재 다시 정의하는 것이아니라 기존 정의로부터 타입을 가지고 와서 추가해준다. 따라서 우린 중복정의 없이 기존 정의를 typeof 키워드를 통해서 쓸 수 있다. OwnProps마지막 타입은 기존 우리가 컴포넌트를 정의할 때 받는 부모로 부터 받게되는 그 인자를 정의하면 된다. 컴포넌트를 컨테이너로 변경하는 경우라면 기존 컴포넌트의 인자가 OwnProps로 변경된다. 개인적으로 수없이 정의하게 되는 이런 타입과 함수들이 매우 반복적이기 때문에 mapStateToProps와 같은 함수를 정의하는 대신 inline으로 삽입하는 것을 선호하며 위에 설명한 것들을 함쳐 결과를 보면 아래와 같다. 1234567891011121314151617181920212223242526import * as React from 'react'import &#123;connect, bindActionCreataors&#125; from 'redux'import &#123;contactBglee&#125; from './actions' // 액션이 존재하는 곳interface StateProps extends User &#123;&#125; // type으로 정의도 가능하다interface DispatchProps &#123; contactBglee: typeof contactBglee&#125;interface OwnProps &#123;&#125;type Props = StateProps &amp; DispatchProps &amp; OwnPropsinterface State &#123;&#125;const Container = connect&lt;StateProps, DispatchProps, OwnProps&gt;( (state: RootState) =&gt; (&#123; ...state.bglee &#125;), dispatach =&gt; bindActionCreators(&#123; contactBglee &#125;, dispatch))( class Component extends React.Component&lt;Props, State&gt; &#123; render() &#123; return &lt;p&gt;hello world&lt;/p&gt; &#125; &#125;) next이제 render()함수 안에서 this.props 그리고 .을 찍어보자.","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"ts","slug":"dev/ts","permalink":"http://blog.bglee.me/categories/dev/ts/"}],"tags":[]},{"title":"Texts 구현","slug":"texts","date":"2017-05-07T15:00:00.000Z","updated":"2018-03-29T06:03:19.633Z","comments":true,"path":"posts/2017/texts/","link":"","permalink":"http://blog.bglee.me/posts/2017/texts/","excerpt":"","text":"구현 기획자 디자이너, 퍼블리셔와의 협업시 문구 변경으로 인한 피로를 덜기 위해 ID기반의 문구 관리를 앱 동기 부동산 계열에서 일을 하다보니 너무많은 term이 존재한다. 사소한 문구 변경이 데일리로 일어난다. 퍼블리셔 쪽에서도 html에 대한 이력관리를 원한다. 문구 변경과 markup의 변경이 구분되지 않는다. react로 퍼블리싱하지 않는 이상 태그를 그대로 사용하지 못하므로 daily diff이슈가 존재한다. 여러 곳에서 동일하게 쓰이는 문구 변경이 일어난 경우 diff에 혼란이 있다. 개발 일단 퍼블리셔 쪽에서 ID를 사용하용하여 퍼블리싱 할 수 있게 끔 하는 것을 최우선으로 했다. 독립적으로 사용할 수 있도록 serverless를 통해 DB까지 한번에 deploy한다. backend 엔드포인트만 사용자 별로 바꾸면 되니까 fe는 직접 만들어서 배포했다. Texts 운영기획(스트링 관리 주체) https://texts.surge.sh?endpoint=https://[BACKEND_ENDPOINT] 접속 스트링 마음껏 만들고 잘 됬으면 deploy한다. 퍼블리셔 퍼블리셔 쪽에서는 &lt;div data-text-id=&quot;TEXT_ID&quot;/&gt;와 같은 형식으로 퍼블리싱을 할 수 있게한다. 퍼블리셔는 눈으로 이를 확인할 수 있어야하므로 이를 치환해주는 태그를 서비스해준다. Texts Translator 퍼블리셔가 동적인 동작을 위해 jQuery태그를 심듯이 심어주면 동적으로 확인이 가능해준다. 개발 개발 버전에서는 퍼블리셔와 같이 태그를 심어서 스트링 관리주체가 변경하는 것을 즉각적으로 확인할 수 있게끔 한다. 프로덕션 릴리즈시에 아래 형식으로 저장해서 CI빌드시에 넣으면된다. 1$ http post https://[END_POINT]/json &gt; language_ko.json todos 퍼블리셔쪽에 구문 변경으로 인한 스트레스에서 벗어나고 싶지않냐고 설득한다. 기획자분이 스트링을 관리할 수 있도록 제안하고 설득한다. 히스토리 표준을 이용할 수 있게 끔 Intl을 붙이려고 디자이너쪽에서 태그를 어떻게 사용하게 해야할지 감이 오지 않아 뒤로 미뤘다. 장점 퍼블에서도 모델을 분리한다. 모델, 디자인, 컨트롤의 물리적인 관리주체(부서)가 명확해 진다. 단점 서비스가 아니라 aws 설치 형태라 결국 나만의…","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"js","slug":"dev/js","permalink":"http://blog.bglee.me/categories/dev/js/"}],"tags":[]},{"title":"Next.js","slug":"next-js","date":"2017-05-07T15:00:00.000Z","updated":"2018-03-29T06:03:19.630Z","comments":true,"path":"posts/2017/next-js/","link":"","permalink":"http://blog.bglee.me/posts/2017/next-js/","excerpt":"","text":"Next.js현재 회사의 고객사이트를 next.js와 typescript 기반으로 2017-04-10 일 기준으로 배포되었다. 간단하게 소개를 하고자 한다. next.js next.js는 node.js, react기반의 유니버살 렌더링을 지원하는 프레임웍이다. 첫 접속시에는 서버로부터 첫 페이지를 구동하기 위한 청크를 가져가게되며 한번 접속한 페이지에 대해서는 데이터 청크가 있으므로 SPA와 같이 동작하게 된다. 라우팅라우팅은 기본설정으로 pages/ 디렉토리가 루트가 된다. 기본 라우팅은 index.html에 매칭되는 index.js가 된다. 디렉토리 구조가 그대로 서비스 라우팅에 매칭되기 때문에 특별히 할 일이 없어서 빠른 속도로 개발을 시작할 수 있다. 그럼 html에 해당하는 template은 어디서 제어하는가? pages/_document.js_document.js는 index.html의 템플릿에 해당하는 정보를 내려주는 리엑트 컴포넌트로 시그니쳐가 React.Component의 상속이 아닌 next/document 패키지의 Document 컴포넌트를 상속해서 만들게 된다. 자세한건 문서를 참조한다. pages/_error.jsSSR이 지원되기때문에 데이터를 서버에서 미리 패칭하여 내릴 수 있다. 이런 경우를 포함해서 예외처리가 제대로 되지 않은 경우 500에러를 내리게 되는데 그에 대한 에러 status를 받아 그에 맞는 화면을 내릴 수 있다. _document.js와는 달리 React.Component를 상속한다. apinext.js에서는 리액트 컴포넌트를 내릴때 특수한 static 메서드를 정의할 수 있는데 이 함수는 서버와 클라이언트 모두에서 사용되며 서버일 경우와 클라이언트일 경우에 대한 분기를 여기서 정할 수 있다. 이를 통해서 서버인 경우에 대한 처리, 클라이언트에 대한 처리를 추가할 수 있다. getInitialProps()12345678910111213141516171819202122232425262728293031323334export default class Index extends React.Component&lt;null, null&gt; &#123; private store: Store&lt;RSquareStore&gt;; static async getInitialProps(&#123;req&#125;) &#123; const server = !!req; const store = await storeCreator(reducer, null, server); try &#123; await store.dispatch(getCatalogue()); &#125; catch(ex) &#123;&#125; const initialState = store.getState(); return &#123;initialState, server, catalogue: initialState.themes.catalogue&#125;; &#125; constructor(props) &#123; super(props); this.store = storeCreator(reducer, props.initialState, props.server); &#125; render() &#123; return ( &lt;Provider store=&#123;this.store&#125;&gt; &lt;Layout&gt; &lt;Head&gt; &lt;title&gt;&#123;`SEO_TEXT`&#125;&lt;/title&gt; &lt;/Head&gt; &lt;Home catalogue=&#123;this.props.catalogue&#125;/&gt; &lt;/Layout&gt; &lt;/Provider&gt; ); &#125;&#125; 단순한 구현은 위와 같다. 구조에는 redux가 쓰였으며 이를 위해 스토어를 생성해서 내리고 있는 걸 볼 수 있다. &lt;Head&gt;컴포넌트도 보이는데 helmet 역할로 헤더쪽으로 자식 태그들을 펌핑해준다. 동적으로 바껴야하는 메타태그들을 여기서 처리하면 된다. pros 라우팅이 정형화된 디렉토리 구조로 되어 있기 때문에 직관적이다. API가 적다. 유니버설 렌더링의 지원한다. cons 표준으로 자리잡았다 싶은 기존의 리액트용 라이브러리들과 함께 사용하려면 커스텀 셋업이 필요하다. ###","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"js","slug":"dev/js","permalink":"http://blog.bglee.me/categories/dev/js/"}],"tags":[]},{"title":"yarn","slug":"yarn","date":"2016-12-11T15:00:00.000Z","updated":"2018-03-29T06:03:19.634Z","comments":true,"path":"posts/2016/yarn/","link":"","permalink":"http://blog.bglee.me/posts/2016/yarn/","excerpt":"","text":"yarn은 동시 다운로드를 지원하는 npm이라고 보면된다. 디펜던시 트리를 저장하고 있어서 빠르게 인스톨을 하므로 CI등에서 위력을 발휘한다.기본 지식은 문서를 참고하면 된다. yarn global add [package] 커맨드를 통해 인스톨을 한 경우 npm과 달리 실행이 안되는 문제가 있다. 123456789101112131415&gt; yarn global add typescriptyarn global v0.17.8warning No license field[1/4] 🔍 Resolving packages...[2/4] 🚚 Fetching packages...[3/4] 🔗 Linking dependencies...[4/4] 📃 Building fresh packages...success Installed typescript@2.1.4 with binaries: - tsc - tsserverwarning No license field✨ Done in 1.56s.&gt; tsczsh: command not found: tsc bash 를 이용하고 있다면 될 수도 있을 것 같은데 필자와 같이 zsh를 사용하고 있다면 아래와 같이 한줄을 추가해자. 1&gt; echo \"export PATH=\\$PATH:`yarn global bin`\" &gt;&gt; ~/.zshrc 이후 실행 12&gt; tsc -vVersion 2.1.4 npm을 통해서도 인스톨을 했다라면 패스 문제로 버전 문제가 생길 수 있으니 둘중 하나만 사용하자. 2016-12-26 추가 brew를 통해 yarn을 설치한 경우 위 방법으로는 yarn global add [package]로 추가한 모듈이 동작을 안한다. npm global, yarn global, brew가 꼬여서 생기는 문제일 것 같은데 일단 해결책은 brew를 통해서 설치했다면 다시 아래를 추가로 입력해주면 된다. 1&gt; echo \"export PATH=\"$PATH:$HOME/.config/yarn/global/node_modules/.bin\"","categories":[{"name":"setup","slug":"setup","permalink":"http://blog.bglee.me/categories/setup/"},{"name":"js","slug":"setup/js","permalink":"http://blog.bglee.me/categories/setup/js/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://blog.bglee.me/tags/npm/"},{"name":"yarn","slug":"yarn","permalink":"http://blog.bglee.me/tags/yarn/"}]},{"title":"W3C HTML5 Conference 2016","slug":"w3c-html5-conference-2016","date":"2016-12-07T12:10:13.000Z","updated":"2018-03-29T06:03:19.634Z","comments":true,"path":"posts/2016/w3c-html5-conference-2016/","link":"","permalink":"http://blog.bglee.me/posts/2016/w3c-html5-conference-2016/","excerpt":"","text":"개인 정리 키노트 1(박종목)웹의 발전 스태틱 웹 웹 2.0(ajax) - symbolic boom read, write web(muchine to muchine), 스맨틱 웹(figure, article, header tag), 웹 3.0 네이버의 인공지능 사례들 페이지랭킹은 오래됬고 머신러닝으로 랭킹 먹인다. 지식 쇼핑 40억개 상품, 4000카테고리가 있어서 딥러닝을 통해 자동분류한다. 위치 기반 검색 지역의 특성등을 인공지능으로 추출한다. 전주 한옥마을에 대한 블로그 데이터의 자연어를 분석해서 전주 한옥마을에 대한 특성들을 분석함(크롤링과는 좀 다름) Context-aware analysis based on charateristics of loacation 해시 태그화 등 이미지 검색시의 정렬등 상품검색의 스타일 서치(유사 상품) topic model을 추출한다. 인식기술이 많이 발전함 머신러닝을 하면서 인식률이 85% =&gt; 95%로 증대 음석 합성도 지원함(사전, 뉴스 읽기, 라인 사전) 기계번역(통계기반 번역) =&gt; 머신러닝(뉴런) 투입하면서 번역률이 2배정도됌 amica.ai, 12초 whale browser는 파파고 엔진으로 웹페이지 번역 지원됨 사용자와의 인터렉션은 음성기반으로 바뀔꺼다.(시리 등등)챗봇(사용자들은 메시징하는데 더 많은 시간을 쓴다(웹은 20%정도)) - 페이스북자율주행(아직은 연관성 별로 없음)스마트 홈(IoT)로봇 관련된 웹 표준 Voice XML 시맨틱 웹(3.0에서 실패했던 것이 지금) 이에 대한 안좋은 시각(생각) 웹표준이 아닌, 애플, 구글, 페이스북등이 사실상 리딩 산업에 변화에 비해 웹 표준은 느리다는게 걸림 태생이 다큐먼트 컨셉 Web의 Next? IoT 키노트 2(김국현)IT 세대론… 코볼은 | C, C++에Java(자바는 코볼을 품음) | JS에 막히고 3세대로 가고 있다. 특이사항 없음 @goodhyun 패널토의웹이 다큐먼트인가? 거의 UI로 사용된다. 그러면 모델이 다큐먼트인게 맞는가1조개의 센서, 세금을 블록체인으로 걷는다.서로 다른얘기 함.. 여튼 지금 혁명중 Q: 네이버 브라우저 왜 만드셨어요? A: 사용성이 안좋다. 선두업계 주자라 인터넷 환경 자체를 개선하겠다. Q: 삼성도 MS따라서 오픈소스하나? A: 변명함, artik이라는 보드도 오픈소스로 내놓음 ecma준수하는 jscript 만듬(40k정도) Q: 웹이 성숙된 표준을 가지고 잘 따라고 있는가? A: 웹 !== 웹브라우저, 칩에도 js call이 들어간다. 쉐이딩 영역도 js가 먹을꺼같다. iot도 먹고있다. 웹을 구성하는 기술들로 간다. Q: JS로 IoT하는데 이게 웹인가? A: 웹이라고 하는듯 의견이 갈림 스펙은 잘 따라가지 못하기 때문에 프레임웍에서 많은 일들을 해야하며 리액트를 디펙토로 가던지 등등 맞다고 생각되는 것을 밀어야한다. 웹의 기본 철학은 탐험과 연결이다. Q: 4차 산업 혁명 준비 예산은? 내년 A: 주용환 40억 규모: 엑티브엑스 개선, 웹 표준 확산 기업지원은 웹이 새롭게 쓰이는 서비스에 지원하려함 올해 2억 수준이었는데 10억 이상 수준으로 편성하려함, VR등 국내사례가 별로 없음. 빅테이터, 인공지능 이쪽이 지원 받을게 많다. Q: 뉴런번역 API 제공 계획 없나 A: 모른다 ㅠㅠ 트랙 BSecond Screen &amp; WebRTCWebRCT 표준 현재와 미래최진호 - REMOTE MONSTER 페이스 챗 카카오톡 슬랙, 아마존 등등에서 다 사용이나 아직 Draft단계이며 5년정도밖에 되지 않는다. 전화기 오픈소스라고 생각하면 이해하기 빠르며 표준화를 진행중이다.(구글이)P2P지만 서버(시그널 서버)는 필요하다.토폴로지 구성 및 브로드캐스팅이 가능 API getUserMedia RTCPeerConnection RTCDataChannel 표준화된 프레임웍이 없다.네트워크 및 안드로이드 파편화에 따라 성능차이가 많이 난다.UDP를 사용 그럼에도 불구하고 커뮤니티가 강하다. https://www.facebook.com/groups/rtc.korea WebRTC PaaS도 존재한다. 1200+ 서비스, 브라우저들이 지원함, 3.1조억+ 기업 인수, 투자 규모 엔지니어 구하기가 힘들어서 인수할 정도로 귀족 개발자 17년 1Q Recommandation 예정 엣지도 지원, 애플도 지원 예정 (H.264) 크롬 55에 RTC관련 업데이트가 대거 용량이 크기때문에 IoT에 대응하기에는 쉽지않지만 빌드 잘하면된다.. AR, VR에 유용할 것으로 예상된다. Google Duo = WebRTC + QUIC 빠른 서비스. 통신, 방송, IoT분야에서 활약할 것으로 기대된다. WebRCT 서비스 개발사례와 시사점이랑혁 - 구루미 HLS보다 딜레이가 적다. RTSP, RTMP, HLS 가능일반전화 연결이 가능하다(?) 협업 &gt; 교육 &gt; 상담(의료) &gt; 관제 등 순으로 비지니스 니즈가 있었음 WinXP, IE 이슈 해결 일렉트론 세계적으론 20%대이니 기다려라(국내는 70%이상) 아니면 앱 만들어서 배포해라 기회 크롬 기반 브라우저 확산(웨일 브라우저) 에코 확장 대기업의 신규 서비스 교육 및 의료 부문 전환중(정부 3.0) ActiveX 제거 Second Screen과 웹 커넥티비티송효진 - LG전자 다른 기기로 화면이나 앱을 보내서 실행하는 것 커넥티비티 네트워크를 통해 떨어진 두 지점을 연결 ECMAW3CIETF(L3)IEEE(L2) IETF HTTP/2(One TCP Connection) QUIC(based on UDP) IPv6 IPv6 over Bluetooth/NFC(IOT 기반으로 이터넷이아닌디바이스에서 가능) Application W3C Presentation API W3C Remote Playback API Underlying Protocol SSDP, mDLS 기대 교육 분야 전광판(QR 대체) FlyWeb Project 웹페이지가 서버를 구동하고 디바이스가 여기에 접속 가능 웹고속화AMP(Accelerated Mobile Pages)는 어떻게 빠른 성능을 내는가?김태훈 - 네이버 http://facebook.com/groups/webfrontend 구글 라이브러리다. amp.js 다른거 할필요없이 가이드를 따르면 된다. 인스턴스 로딩이 가능하다. 커스텀 엘리먼트 기반이다. url + #development=1 를 사용하면 에러 뿜어준다. amp.js는 외부 js를 허용하지 않는다. AMP Cache - 구글이 CDN 으로 다 뿌려준다. HTML AMP-HTML 페어로 구성 또는 AMP-HTML 온리 슬랙등에 링크걸면 AMP로딩해준다. amp 컴포넌트를 사용해서 리소스를 로딩하게되면 뷰포트에 보이는 시점에 레이지로딩한다. 크로스 브라우징 해결해준다. 속도는 엄청 좋다는 말로 부족하다. https만 가능하다(video) 커스텀 js를 사용하지 못하는 치명적인 단점이있어서 이벤트 페이지 같은 경우에 적합할 것으로 보임. 특징 비동기 스크립트만 로딩 허용 모든 리소스의 사이즈 지정 확장 컴포넌트들이 렌더링 차단 없이 실행한다. 써드 파티 자바스크립트 크리티컬 패스에서 제거 ?(CSS관련) 웹폰트 효율적으로 허용 GPU 가속 애니메이션으로만 제한됨(레이아웃 변경 CSS는 막힌다)(css triggers 참조) 리소스 로딩 순서 제어(뷰포트에 의해) 페이지 즉시 로드 리플로우 최적화 스타일 변경 작업을 배치작업을 통해서 최적화한다(코드 붙여서 작성하면됌) 6억+ 페이지가 700k+ 사이트가 작성되었다. 커스텀 엘리먼트를 사용해서 라이프 사이클을 제어한다(이를 통해 뷰포트안에 있을때만 로딩등 처리) 프로그레시브 웹앱(PWA)송정기 - 삼성전자 모바일 웹사이트 장점 URL, 연결성, 빠른 배포(URL &gt; store) 표준 기반 다양한, 폭넓은 기기 지원 단점 Native 대비 떨어지는 UX 성능 기능 Manifest + Service Worker + Push https://whatwebcando.today PWA - 홈스크린 인스톨레이션, 오프라인 모드, 푸시 메시지 머무는 시간이 3배 증가 40% 더 재접속 70% 홈스크린을 통해 들어오는 유저가 구매할 확률이 더 높다 3X 데이터를 덜 사용한다 PWA List 앱 참조 PWA를 구성하는 표준 기술 Web App Manifest네이티브와 동일한 앱 접근성을 제공한다. 크롬, 오페라, 삼성 브라우저, 사파리메니페스트가 추가됏을때는 브라우저에서 탭했을때 메뉴가 다르게 뜬다.홈화면에 인스톨레이션을 지원하는 로직은 아직 사파리가 지원하지 않는다. 인스톨레이션 팝업은 브라우저별 휴리스틱 알고리즘을 통해 제공된다. http://pwa.rocks PWA indication의 조건 https:// Service worker WebApp Manifest theme_color를 통해 상태바 색도 바꿀 수 있다.display를 통해 풀사이즈 앱으로 띄울 수 있다. Splash screen - 크롬이 들고나오고 삼성 인터넷도 탑재 예정, 로딩 전 앱 로딩 화면처럼 만들어준다. Service Worker오프라인 우선, 백그라운드 처리 이벤트마다 워커가 종료된다. 웹 워커와는 다르다. 실 브라우저 구현(크로미움 기준) 2-30초는 살아있다. 1234567const navigator.serviceWorker;sw.register(scriptURL, &#123;scope: scopeURL&#125;);;;oninstall = e =&gt; &#123; /* pre-cache here */ &#125;;onfetch = e =&gt; &#123; /* respond with magic */ &#125;;onactivate = e =&gt; &#123; /* Deleting cache is on you * &#125;; // 서비스 워커 버전이 변경됐을때registration.update(); // 강제 업데이트 SW의 이벤트가 가지고 있는 watUntil 메서드를 통해 SW가 죽는 것을 방지할 수 있다.캐시에 애드하는 형식 캐시에 매칭되지 않으면 거기서 fetch한다. Service Worekr Cookbook 찾아볼 것 https://jakearchibald.com Push API푸시의 효과는 검증됨. 필수요소 Background Service (Service Worker) Push 등록/해지/이벤트 (Push API) push이벤트를 받아서 캐싱에 저장하고 노티피케이션을 띄움 띄운 후에는 클릭 이벤트를 받아 그에 따른 처리. https://medium.com/samsung-internet-dev 삼성 인터넷 베타 프로그램 신청 https://goo.gl/1yFP1L Web 엔진Naver Webkit - Sling Project 소개 및 오픈소스김준걸 - 네이버 랩스 슬링 4년 6개월 작업했고 오늘 깃헙에 오픈했다. 애플의 웹킷에서 fork win/android 지원 JS엔진 - JSC vs V8(과할 수록 유리 V8, 실사용에선 JSC, 슬링은 JSC) 리소스가 부족해서 안드로이드로 개발 =&gt; 스크립팅 =&gt; C++ 소스 제네레이팅(android pp, github 참조) 크로미움 네트워크 성능이 뛰어남 GFX Tool for Sling 이라는 디버깅 툴 만들어서 그걸로 선검증 후포팅 WebExtensions API가 400개 정도 되서 아직 다 지원은 못함 Chrome Dev Summit 2016 참관기김지한 - 네이버 랩스 PWA 포커싱 AMP to PWA 매 단계마다 20%의 사용자가 떨어져나간다.(설치나, 가입 등등 모두) 3G 기준으로 5초 이내에 인터렉션이 가능해야한다. 홈 화면에 추가된 사이트는 4배 더 많이 방문한다(알리바바, 2016) PRPL pattern - Push, render, Pre-cache, Lazy-load &lt;link rel=&quot;preload&quot;/&gt; 크롬 51+, 오페라 41+, 안드로이드 5+ https://www.flipkart.com PWA의 정석https://www.housing.com 부동산 체크 Crediential APInavigator.credentials 인증을 브라우저에 던진다. Web Payment API브라우저에 결재 던짐 Debugging the Web 크롬개발자도구 Lighthouse 익스텐션(PWA) 결론 PWA의 핵심 - 오프라인 지원, 로딩 성능 향상 Lyft등 선행 사업자들도 이머징 마켓 중심으로 적용 중 로그인, 결재 등이 브라우저로 이동(크롬, 안드로이드), 이에 대한 강력한 지원 HTML5기반 웹앱 그리고 다가올 HTTP / 2커넥션 제약으로 이미지 등을 로딩할때 image sprite local cache&lt;link rel=&quot;prefetch&quot; href=&quot;image.png&quot;/&gt; domain lookup, x-dns-prefetch-control, preconnect minify prerender preresolve google에서 instant page 검색 HTTP2 바이너리 기반 프로토콜 헤더 압축 멀티플렉스 스트림(프로세스, 쓰레드 같은 개념) 스트림 프라이어티티(리소스 의존성 지정가능) 서버 푸쉬 1.1 에선 핑퐁 치던걸 2에선 한방에 내림 APMhttps://ampproject.org + PWA 포커싱이 HTTP2가 아니라 아쉬움","categories":[{"name":"summary","slug":"summary","permalink":"http://blog.bglee.me/categories/summary/"}],"tags":[{"name":"pwa","slug":"pwa","permalink":"http://blog.bglee.me/tags/pwa/"},{"name":"amp","slug":"amp","permalink":"http://blog.bglee.me/tags/amp/"}]},{"title":"2016년 12월","slug":"2016-12","date":"2016-12-04T10:58:37.000Z","updated":"2018-03-29T06:03:19.620Z","comments":true,"path":"posts/2016/2016-12/","link":"","permalink":"http://blog.bglee.me/posts/2016/2016-12/","excerpt":"","text":"벌써 12월이다. 미션들이 여러개가 떨어져서 이래저래 공부와 삽질을 하면서 11월 한달을 보냈다. 한달에 한번 포스팅할 시간도 없어서 정리를 하고간다. 독서 클로저 시작하기 - 기본 개념과 7주 훈련 프로그램 빠른 모바일 앱 개발을 위한 React Native 디스커버리 Go 예전에는 정독을 목표로 책을 펴고 서문부터 읽어나갔었는데 출퇴근 시간을 아껴서 공부하다보니 실무에 쓰일 수 있는 부분을 먼저 읽기위해 목차를 읽고 고급 내용을 다루는 뒷 부분을 나중에 읽게 되었다. 11월 중순 부로 서버까지 커버해야하는 상황이 오면서 회사에서 쓰이는 언어인 클로저(이전에도 한번 읽긴 했었다.)와 Go를 공부해야하는 상황인데 기존에 인계 받은 것 중에는 루비 온 레일즈도 존재한다. 블로그서브 도메인을 구현했다. 이제까지 블로그가 집에서 굴리는 작은 서버를 통해 서비스되고 있었는데 이를 나스로 옮겨 잘 사용하고 있었는데 조카들이 와서 전원을 뽑아 놓는 바람에 이틀 정도 서비스가 중단되는 것을 계기로 깃헙 페이지를 통해 서비스를 제공하면서 도메인도 http://blog.bglee.me로 옮겼다. Next공부에 치이는 상황에서 주어진 시간을 최대한 활용하고 추후의 빠른 개발 및 데브옵스를 위해서 기존 API 서버의 GraphQL 프록시를 도전하기도 했고 앱에 대한 니즈 또한 존재해 리액트 네이티브를 공부했다. 시간이 얼마 없기 때문에 GraphQL은 드랍했고 메인 프로젝트의 일정을 맞추기 위해 주니어들과 함께 다시 FrontEnd 코드를 작성중에 있다. 웹 서빙을 위해 EC2, ECS, S3 static hosting 여러가지를 해왔는데 각각의 장단점이 있고 Serverless 스택 또한 러닝커브가 있지만 한번 구현이 완료되면 안정성과 비용 절감이 이루어지는 만큼 이 부분이 다음 타겟이 될 것 같다. 첫 시도는 주어진 시간의 한계로 친구에게 맡긴 상황인데 이 부분이 잘 해결되었으면 한다. ㅏ","categories":[{"name":"summary","slug":"summary","permalink":"http://blog.bglee.me/categories/summary/"}],"tags":[]},{"title":"AWS EC2 Container Service(ECS)를 통한 배포","slug":"aws-ec2-container","date":"2016-11-05T06:00:00.000Z","updated":"2018-03-29T06:03:19.622Z","comments":true,"path":"posts/2016/aws-ec2-container/","link":"","permalink":"http://blog.bglee.me/posts/2016/aws-ec2-container/","excerpt":"","text":"ecs 는 현재 서울 리전에서는 지원되고 있지 않다. 글을 쓰다가 개인 업무가 있어서 끊어 쓰다보니 매끄럽지가 않은데 질문사항이나 잘못된 점이 있으면 피드백 주세요. 개요aws console 을 통해 EC2 Container Service(ecs) 에 진입하면 3개의 메뉴가 보인다. Cluster Task Definitions Repositories Cluster 하드웨어 클러스터를 의미한다. EC2의 모임이라고 생각하면 편하다. Task Definitions 이 곳에서 Docker 파일을 통해 task 를 정의한다. 정의한 task를 cluster에 할당하여 동작시킨다고 생각하면된다. task 에서는 메모리를 얼마나 사용할 것인가? 등의 docker 설정을 포함한다. Repository aws 에서 사용할 수 있는 docker hub 라고 이해하면 빠르다. 이 곳에 빌드된 docker image 를 올린다. 실제 구성저장소 구성 및 업로드docker image build먼저 어플리케이션을 구현하고 Dockerfile을 통해 이미지로 빌드한다(빌드 과정은 이 포스트의 영역을 넘어간다). docker 저장소 생성빌드 된 이미지를 ecs repository 에 업로드하기 위해서 ecs 서비스의 repository 에 진입하여 Create repository 버튼으로 저장소를 생성한다. docker image upload친절하게 ecs에서 repository 를 선택하면 View Push Commands 라는 버튼을 통해 업로드 방법을 볼 수 있다. login, build, tag, push(upload) 순으로 명령어가 적혀있는데 저장소 url, region을 자신에 맞게 수정하고 올리면된다. task definitionstask 생성Task Definitions 메뉴에서 Create a Task Definition 버튼을 눌러 생성한다. Container Definitions 에서 Add container 버튼을 통해 컨테이너를 등록해야하는데, image 에서는 프로토콜(http://)을 제외한 이미지 경로를 넣어준다. 메모리의 경우는 task 가 실행될 실제 컨테이너의 메모리 안에서 설정하면된다. 실제 사용하는 메모리보다 적게 잡을 경우 속도저하, 응답없음 등을 경험할 수 있다. 실제로 PDF를 생성하는 서버를 구현했다가 랜더링 할 메모리가 모자라 응답없음을 경험했었다. 추가적으로 포트 매핑, CPU unit 등을 설정해준다. cluster 에 배포cluster 생성service 생성클러스터를 생성하고 나서 클러스터에 제공할 서비스를 생성한다. 여기서는 위에서 정의한 task 와 이를 서비스할 cluster 를 지정하고 몇개의 task를 돌릴 것인지 등을 셋업한다. 추가적으로 ELB, auto scaling등도 셋업을 한다. ELB 최근에 Application Load Balandcer 가 추가 되면서 기본설값이 되어 있다. 기존에 쓰이던 ELB는 Classic Load Balancer 니 참고 바란다. 여기 까지는 그냥 따라오면 되는데 중요한 문제가 있다. cluster 에 등록된 컨테이너 인스턴스가 없다. 이제 이를 세팅해야한다. cluster에 ec2 instance를 등록하기 위해서는 ecs agent가 설치된 이미지가 로드되야한다. 이건 유저가 스스로 설치할 수도 있지만 기본적으로 아마존에서 제공하는 이미지가 있다. 테스트를 위해 ec2 instance 를 생성한다. AMI는 Amazon ECS-Optimized Amazon Linux AMI 를 이용한다. auto scaling group, launch configuration 을 통해 서비스를 하는게 정석이다. 여기서 user data 를 설정해서 인스턴스가 ecs에 접속해서 클러스터에 등록을 할 수 있도록 설정해 줘야한다. 12#!/bin/bashecho ECS_CLUSTER=CLUSTER_NAME &gt;&gt; /etc/ecs/ecs.config user 데이터의 내용은 위와 같다. 여기서 CLUSTER_NAME 부분을 통해 인스턴스가 로딩되면서 ecs agent가 실행되게되고 여기서 ecs 에 접속하여 cluster에 등록되게 된다. update revisiondocker image가 업데이트 되어 재 배포가 필요한 경우에는 task의 new revision을 선택하고 container를 눌러서 한번 업데이트를 누른다(현재 컨테이너가 같은 docker이름을 참조하더라도 재 참조를 하도록) 리비전이 생성되면 생성된 task를 서비스에 업데이트하게 되면 현재 구동되고 있는 task가 active로 업데이트된 task가 primary로 등록되며 시간이 조금 지나면 active가 내려가고 primary가 active되면서 서비스가 이어지게 된다. trouble shotting###* cat /etc/ecs/ecs.config 1Could not register module=&quot;api client&quot; err=&quot;ClientException: Cluster not found. /etc/ecs/ecs.config 에 cluster 이름이 정확히 올라가 있는지 2번 확인한다. 그래도 안되면 ecs agent api call이 public ip를 요구하므로 public ip가 있어야한다.(또는 프록시 등의 다른 방법) ec2를 확인한다.","categories":[],"tags":[{"name":"aws","slug":"aws","permalink":"http://blog.bglee.me/tags/aws/"},{"name":"ecs","slug":"ecs","permalink":"http://blog.bglee.me/tags/ecs/"},{"name":"ecs_cluster","slug":"ecs-cluster","permalink":"http://blog.bglee.me/tags/ecs-cluster/"},{"name":"ecs.config","slug":"ecs-config","permalink":"http://blog.bglee.me/tags/ecs-config/"},{"name":"ec2","slug":"ec2","permalink":"http://blog.bglee.me/tags/ec2/"},{"name":"ec2 container","slug":"ec2-container","permalink":"http://blog.bglee.me/tags/ec2-container/"}]},{"title":"deview-2016","slug":"deview-2016","date":"2016-10-23T15:00:00.000Z","updated":"2018-03-29T06:03:19.624Z","comments":true,"path":"posts/2016/deview-2016/","link":"","permalink":"http://blog.bglee.me/posts/2016/deview-2016/","excerpt":"","text":"Deview 2016 CTOkeynote회사에서 프론트엔드 개발차 지원해준 기회기 때문에 FE로 스케줄을 잡았는데 키노트를 들으니.. 로봇과 음성인식 세션이 궁금했지만 계획대로 진행하기로했다. 네이버 랩스는 무인 주행, 음성 인식(자연어), 로봇에 집중하고 있는 것으로 보인다. 무인 주행 자체에 집중하기 보다는 시각데이터를 파싱하는 목적이 큰 것으로 보였다. M1(?) 이라는 네이버 랩스 로봇 영상이 보여졌는데 돌아다니면서 영상을 찍는데(머리가 카메라로 무장) 단순이 동영상을 찍는게 아니라 걸 돌아다니면 녹화했던 영상 데이터를 다시 보여줄 때는 걸려있던 액자들의 내용을 바꿔서 보여줬다. 3D 맵 데이터로 파싱해서 데이터화 하고 있는 것으로 보였다. D2Naver Open Source2016년 4개를 공개함 https://github.com/naver.com pinpoint star: 2300 나눔 고딕 폰트가 금일 업데이트 되었다. 지도 API는 일일 20만 콜이 가능하다. D2 Startup Factory스타트업 지원 papago한국, 일본, 영어, 중국어 지원 Whale네이버의 Chromium 기반 브라우저다. 12월 런칭 예정이다 [공식 홈페이지]https://whale.google.com 네이버 브라우저 스플릿창 지원 글자 선택만으로 검색 스마트 팝업(구석에 나옴) 이미지 번역 악성코드 제어 파파고 기술이 들어가있음 12월 발표 BLUE생활 환경 지능(Ambient Intelligence) - 사용자가 요구하지 않아도 상황을 인식하고 추천하는 것 understand - 이해하는 것 anticipatory - 답/정보/action을 예상 추천 natural UX 음성, gesture등 AMICA AMI Connected All 영상이 소개되었는데 아이템은 팔찌로 보이고 차 내에서 또 자기전에 말을 하는데 음성인식관련으로 siri와 매우 유사했다. https://amica.ai 자연어 처리는 음성에만 국한된 것이 아닌 채팅에서도 사용이 가능하다.는 것을 기억해야할 듯 AMICA는 11/7 까지 클로즈 베타 신청 받음(막상 들어가보니 11/6일) Samsung ARTIK 으로(Intel Edison류의 보드인 것으로 보임) 포팅되어있어 사용이 가능하다. 자율주행미국(?)의 기준인 NHTSA level 3 수준이다. NAVER LABS M1Indoor mapping robot 공간 인식 및 정보화, 3D 실내지도 이미지 인식기술은 인공지능 기술과 합성되면 사람의 눈과 같은 역할을 하게될 것으로 보여졌다.(카메라니 당연히 눈이지만 시각정보를 인간과 같이 파싱하는 느낌) Session#01(Web Payment API의 현재와 미래)2015-10 에 표준화 작업이 시작됨 Motivation68%는 카트에 담고 결재하지 않음, 데스크탑 보다 모바일에서 그보다 나가는 비율이 66% 더 됨 폼이 너무 복잡하다 계정생성 귀찮음 모바일 디자인이 구림 로딩 속도 Web Payment with Basic Cards크롬 53(4?)에서부터 지원한다. 구성 Payment Request API, Payment Method Identifiers Basic Card Payment 복잡한 form으로 처리 되는 것을 one button 으로 처리한다. 브라우저가 가지고 있다. 판매자가 수용하는 payment request를 날리면 카드 리스트만 리스트업 됨 benefituser 쇼핑몰에 관계없이 같은 ux제공 처음 이용 쇼핑몰에서도 저장된 신용카드를 이용가능 merchant 결재 ux개발안해도됌 보안이슈 및 서버 운용비용 절감 123456789var methodData = [&#123; supportedMethods: ['visa', 'master'],&#125;, &#123; supportedMethods: ['sampay'], data: &#123; merchantID: '12345',...&#125;]var pr = new PaymentRequest(methodData, details, options); shippingOptions: 배송정보paymentOptions: 어떤 정보를 입력받고 받지 않을지 결정 프로미스 기반 언급된 이벤트 shipping address change event shipping options change event 지원하지 않는 지역이나 옵션이 올 경우에 대한 처리를 이벤트를 받아 처리할 수 있다. 1e.updateWith(//이벤트 업데이트 결재를 판매자측 서비스에서 처리하는데 개발 부하가 걸린다 앞으로 미래는 payment app을 사용한 결재가 있다. Web Payment with Payment Apps SamsungPay, AliPay 등을 통해 신용카드 뿐만 아니라 결재 앱을 카드처럼 지원한다. 페이먼트 앱 웹 기반(현재 포커스 되어있음 w3c) 네이티브 기반(완전히 정의되지 않음) =&gt; 네이티브를 트리거하는 방식으로 진행 될 예정(지금이랑 같지 않은가?) service worker 브라우저가 죽어도 살아있다. 브라우저에 설치되게 되며 필요한경우(푸시 알람) 이벤트를 수신받은 브라우저에 의해 활성화된다. 지정된 origin 및 scope에서만 동작하며, Secure Context에서 실행됨을 보장. payment app &lt;&gt; service worker 는 1:1 관계다. 1navigator.serviceWorker.register('/tree_pay.js').then( Session#02(GraphQL)기존 rest 필드제한 한계 필터 문제 문서 문제 동기화 문제 json:api GraphQL query mutation object type을 가지고 schema를 정의 object * type(required): name * args: 인자 * resolve: return function rest: postman / graphql: GraphiQL(chrome extension) RelayReact와 GraphQL을 엮는다. Node Resource에 대한 단일 interface Connection(페이지네이션 특화) Node를 여러개 가져온다 React Relay 123456React.createContainer(COMPONENT_NAME, &#123; fragments: &#123; editor(props의 이름: () =&gt; Relay.QL` fragment on User &#123; pictureURL $&#123;EditorInfo.getFragment Mutation Config query(node, connections),변경(mutation) 참고 http://learngraphql.com 검색해 볼 것 nosyncdb lukka awesome graphql Q&amp;A 시간에 질의 응답을 볼때 Relay와 Redux는 함께 사용하기 껄끄러운(베스트 프렉티스가 없는) 상황으로 보여지며 기존 Redux 사용시의 전략인 외각 오브젝트에서 데이터 로직을 처리하고 나머지를 퓨어 컴포넌트로 가져가는 방식이 아닌 서버쪽 데이터를 활용하는 대부분의 컴포넌트가 Relay로 바인딩 되게 된다. Redux, Relay 모두 Flux 아키텍쳐의 영향을 받았으므로 개인적으로는 Store가 로컬에 있느냐 리포트에 있냐를 차이로 보고 있지만 컴포넌트가 데이터와 강하게 커플링되는 것에 대한 거부감이 있는 것이 사실이다. 실제 적용을 해보면서 답을 찾아야할 부분으로 보인다. Session#03(Electron)검색시에는 github eletron으로 검색해야 한다. slack과 microsoft가 샘플이 됨(Document에도 존재하지 않는 것들이 쓰이니 볼 것)electron은 소스가 다 보인다. 로직을 백엔드로 빼서 구현했다고 말하고 있다. 로직을 백엔드로 빼면서 Command 패턴을 사용했는데 로직이 백엔드로간 이유는 보안상의 이유라고 한다.(여기서의 백엔드는 local에서 node server를 돌린다는 이야기다. Devtron 이라는 크롬 익스텐션이 존재하는 이를 개발 환경에서 이용할 수 있다. node 바이너리 솔루션 enclosejs: 플랫폼에 맞춘 바이너리화 eletron-builder 개인적으로 인상적인 세션은 아니었고 개발 방법론, 패턴등을 설명했음에도 30분내에 발표가 마무리되었다. Session#04(한 달 만에 개발한 하이브리드 앱, 50만 사용자 서비스가 되기까지)해먹남녀하이브리드가 넘어야할 장애물 view 전환 효과 300ms의 지연이 존재(웹뷰) - single tab, double tab을 잡기 위해 존재 hammer.js, fastclick.js가 있음 transition 3d translate css 이용 push cordova 등 백수시절 6개월동안 7개의 앱을 만듬(평균 2주) 해먹남녀는 IonicFramework을 이용해서 제작했다. 1달만에 웹뷰를 이용한 하이브리드앱을 제작했으나 2달의 안정화 작업을 거쳤다. 1주차 comonent부터 ui를 만듬문제는 라우팅으로는 위계 제어가 힘들다. 2주차 어려운 문제들을 해결하기 시작 sync 플러그인 업데이트 종속성 다중업로드 보안정책(애플) 3주차 성능 데이터 프리패치 터치 컨트롤 통제 스크롤시 터치를 받지 않는 등으로 속도 향상 이미지 리사이징 css blur처리가 속도가 느려서 40px짜리를 up scaling해서 속도를 향상 시킴 4주차 png 처리 투명 VOC 사용자 피드백 대응https://microsoft.github.io/code-push 클라우드에서 버전이 바뀌면 파일을 보내줌 급할때만 씀 cordova핵시config.xml 프로젝트 설정 파일버전관리, hook script 테스크 자동화, info, plist 자동 작성 세션 발표자의 회고하이브리드 앱과 네이티브 앱 사이에는 넘을 수 없는 성능(트랜지션 등을 말하는 듯) 차이가 존재하나 하이브리드 앱이 보여주는 수준 자체가 준수하기 때문에 문제가 없다. 하이브리드 앱이 네이티브를 대체한다기 보다는 빠른 Time To Market을 맞추기 적합하며 이를 활용한다는 전략적 차원으로 발표자는 설명했다. 하지만 React Native가 있다면 어떨가… Session#05(5년간의 네이버 웹엔진 개발/삽질기 그리고…)Naver Labs의 신규 브라우저 Whale의 개발에 대한 스토리다. 사실 이 세션은 고민이 많았다. 선택할 수 있는 세션이 4개 였는데 다음과 같았다. Clean Front-End Development React로 개발자 2명이 플랫폼 4개를 서비스하는 이야기 우리 팀에서도 코드리뷰를 할 수 있을까? 5년간의 네이버 웹엔진 개발/삽질 그리고… 원래는 첫번째 세션을 들을까 준비했는데 Single Page Application만 5년 이상을 진행했고(심지어 임베디드 웹 브라우저에서도…) 사실 이 정도의 기간이 SPA 역사기 때문에 나이가 어린 세션 발표자거나(실망 시킨 경우가 많았다) 뻔해 보이거나 답 없는 주제(React vs Angular)와 같은 주제를 피하고 다수의 개발자들이 시간과 노력을 들여 진행한 프로젝트 이야기가 듣고 싶어 이 세션을 선택했고 결과 적으로 성공적이었다. 브라우저 세션 답게 블락 다이어그램으로 스택을 소개하고 공감가는 삽질기를 들을 수 있었다. Q&amp;A 시간을 포함해서 45분인데 그중에 무려 30분을 Webkit 기반으로 진행한 프로젝트 연혁을 말하고 있었는데. 결론적으로는 Webkit을 버리고 Chromium 기반으로 만들었다고… 국내에 브라우저를 낼 수 있는 기업이 얼마나 있겠는가 기대를 걸어본다. 브라우저 같은 뿌리 기술은 가지고 있으면 시너지를 낼 것도 많고 파급력을 가지는 대신 그 만큼 출시 이후에 끌고가는 문제도 있는 아무쪼록 잘 되었으면 한다. Whale일단 feature가 실제 사용 패턴과 관련 된 것이 맘에 들었다 대단히 실질적으로 사용패턴을 분석을 한 것으로 보였다. Over Tabber를 예로 들었는데(탭을 엄청나게 띄워 놓는 사람) 이유인 즉슨 이렇다는 거다. 쇼핑몰에서 고르는데 인덱스 페이지 하나를 두고 상세 페이지를 들어갔다가 나왔다 하기 귀찮으니 여러개를 띄워둔다. 사내에서 보라고 링크 공유가 왔는데 아예 안보는 것은 매너가 아니니 일단 띄워놓고 하염없이 둔다. 구글에서 검색을 한뒤에 원하는 결과를 찾는데 이 때 도움이 될 것 같은 것은 일단 띄워둔다. 실제로 나도 봐도 그렇기 때문에 깊이 공감을 했다. 그래서 Whale은 스플릿 뷰를 지원하고 쇼핑몰등에서 유용히 사용할 수 있도록 했다. 읽기 모드를 미려하게 지원하고 블락하면 궁금하고 블락하지 않자니 너무 떠대는 탭들을 스마트 탭뷰를 만들어서 정리해서 볼 수 있도록 구현했다. 크롬 익스텐션이 풀리 호환되며 자체 지원을 위한 것도 준비되어있다. 음성 검색(파파고?) 이 들어가있다. 퀵 서치기능이 들어가있어서 단순 드래그만으로 단어나 인물등을 검색할 수 있는데 단순 검색이 아닌 검색 기반의 회사인 만큼 컨텍스트 검색을 통해 연관성이 높은 결과 값을 받을 수 있다. 일단 기능이 마음에 든다. 고민의 흔적도 공감할 수 있어서 개인적으로는 아 맞게 고민했구나? (내가 쓸 수 있게...) 이런 느낌을 받았다. 12월 런치로 보인다. https://whale.naver.com deview 2016에 대한 개인적인 감상회사 업무도 업무고 상당히 가기 귀찮았는데 잘 갔다왔다는 생각이 든다. 무료 세미나에 가면 제품 홍보 성격이 강하다거나 어린 세션 발표자(어리다고 뭐라 하는 것이 아니라.. 확률상)의 경우 준비 미숙으로 50분 세션을 10분만에 끝내버리는 경우도 많았는데 그 보다는 훨씬 나았고 주제 자체가 진보된 것이 많았다. 무료 했었는데 좀 의지를 태울 수 있었다.","categories":[{"name":"summary","slug":"summary","permalink":"http://blog.bglee.me/categories/summary/"}],"tags":[{"name":"deview2016","slug":"deview2016","permalink":"http://blog.bglee.me/tags/deview2016/"},{"name":"deview","slug":"deview","permalink":"http://blog.bglee.me/tags/deview/"}]},{"title":"AWS API Gateway - Lambda - Travis-CI prototype 구현","slug":"aws-gateway-lambda-ci","date":"2016-09-25T15:00:00.000Z","updated":"2018-03-29T06:03:19.622Z","comments":true,"path":"posts/2016/aws-gateway-lambda-ci/","link":"","permalink":"http://blog.bglee.me/posts/2016/aws-gateway-lambda-ci/","excerpt":"","text":"aws serverless architecture 의 핵심에 api gateway 와 lambda 가 있다. 두 서비스는 모드 서울 리전에서 사용이 가능하다. 이를 이용하여 프로토타입을 작성해 보자. architecturenode로 서버를 구성하는 것을 예로 들자면 아래와 같다. node application express-router logic aws api gateway lambda aws에서 제공하는 아키텍쳐 예시를 보면 이해가 쉽다. https://api.example.com 부분을 통해 api gateway에 접근하면 라우팅을 통해 필요한 lambda함수를 콜하게 된다. 그리고 db 등에 데이터를 연산을 하고 다시 사용자에게 응답을 리턴한다. 이 포스트는 실무에 적용이 가능하도록 아래와 같은 내용을 담고있다. lambda 함수 생성 api gateway - lambda 함수 연결(parameter, header 설정) development, production 모드를 분리하기 위한 stage 활용 travis ci를 통한 배포 자동화 실제 구현 순서와는 상관없이 설명하기 편하게 상향식 접근 방법으로 작성한다. lambda 함수 구현코드 구현 방식lambda는 다음 3가지 방식으로 코드를 구현 할 수 있다. inline editing upload zip file upload from s3 이 포스트는 배포 자동화까지가 목표이므로 2번째 안으로 진행한다. 구현 언어lambda는 java, python 등 몇가지 언어를 지원하는데 이 포스트는 nodejs 4.3 버전을 기준으로 설명한다. nodejs 4.3은 es2015(a.k.a es6) 를 부분적으로 지원하는데 훌륭하진 않으며 다행이 Promise, Set 정도는 지원을 하고 있다.이외에 코드 작성은 방식은 자유지만 컴파일 또한 비용이며 polyfill등을 이용하게 되는 경우 용량이 늘어나므로 추천하진 않는다. lambda 함수 생성간단하면서도 lambda와 api gateway가 연결되면서 parameter들이 어떻게 전달되는지를 볼 수 있도록 코드를 작성한다. 배포하기 전 빠른 진행을 위해 aws에서 제공하는 inline editor를 사용해 바로 소스를 작성하도록 하자. aws console 에서lambda를 선택해서 lambda 페이지에 진입한 후 왼쪽 사이드 바에서 functions를 누르고 create a Lambda function을 눌러 lambda 함수를 생성하도록 하자. Select blueprint 화면이 나오면서 template 들이 보여지는데 skip 버튼을 눌러 다음 스텝으로 간다. configure triggers 화면이 나오는데 우리는 api call을 통한 실행을 할 것이므로 api gateway를 선택하고 next를 누른다. configuration function 에서는 함수에 대한 설정을 한다. 아래와 같이 설정한다. config value Name loopbackArgument Description Runtime Node.js 4.3 code entry type Edit code inline) 123456exports.handler = (event, context, callback) =&gt; &#123; callback(null, &#123; event: event, context: context &#125;);&#125;; export할 함수 이름을 정하고(여기선 handler) lambda의 signiture대로 3개의 인자를 받는다. 인자를 간략히 설명하면 다음과 같다. argument description event event call에 대한 정보로 parameter, header등이 이 인자로 매핑된다. context lambda 함수 자체에 대한 정보 callback 리턴함수라고 생각하면된다, 첫 번째 인자는 Error 객체, 첫 번째 인자가 null 경우 성공으로 간주되고 2번째 인자가 응답값으로 사용된다. 이 코드는 단순히 람다 함수의 인자를 그대로 응답하는 handler함수를 반환하고 있다. 이 외는 기본 설정을 이용하며 role을 정해줘야하는데 이전에 람다를 위한 role을 만들지 않았다면 생성 후 선택하고 next를 함수를 생성한다. api gateway - lambda 함수 연결(parameter, header 설정)api gateway에서는 라우팅 테이블을 만들때 swagger를 지원한다. 기 구현된 서버가 swagger를 통해 문서화가 되어 있다라면 serverless architecture를 바로 적용할 수 있을 것으로 보인다.특히 swagger에 api gateway extensions가 존재하는데 이 부분을 swagger에 함께 작성하게 되면 파라메터나 응답값에 대한 정의를 문서 작성 단계에서 끝낼 수 있다. 이제 api gateway를 설정할 차례다. API 생성aws console 을 통해 api gateway 서비스에 접속한 후 APIs 메뉴에서 Create API를 누른다. New API를 선택하고 API name에 test 라고 작성한다.Actions를 눌러 Create Method를 선택하고 post를 선택한후 check 버튼을 눌러 생성한다.이러면 생성한 POST method에 대해 setup하는 화면이 나오고 이미지와 같이 설정을 하여 위에서 작성한 lambda 함수를 연결한다. 물론 함수명과 리전은 작업중인 상황에 맞게 넣어야한다. API 설정Method Request설정할 것은 없지만 header와 query string이 들어오는 것을 확인하기 위해 이미지와 같이 추가해 둔다. Integration Request여기선 Method Request에서 설정한 parameter 들을 받기 위한 설정인데 기본 템플릿을 적용하여 아래 이미지와 같이 설정한다. API Deploy사용을 위해 Resources 옆 Actions 를 선택하고 Deploy API를 선택한다. 이미지와 같이 [New Stage] 로 prod를 입력 후 deploy 버튼을 누르면 Stages 화면으로 진입하면서 endpoint가 될 url이 Invoke URL 이라는 이름으로 보인다.이제 이 url을 통해 api call 이 가능하며 당장 postman이나 curl등을 통해 확인이 가능하다. 1차적으로 api gateway와 lambda함수를 연결해서 실행을 확인해 볼 수 있는 상태가 되었다. development, production 모드를 분리하기 위한 stage 활용작성한 코드를 실행해보면 아래와 같은 형태의 json이 응답으로 전달됨을 확인 할 수 있다. 1234567891011121314151617181920212223242526&#123; \"event\": &#123; \"body-json\": &#123; ... &#125;, \"params\": &#123; \"path\": &#123;&#125;, \"querystring\": &#123; \"deptno-param\": \"deptno test\" &#125;, \"header\": &#123; \"Authorization\": \"deptno test\" &#125; &#125;, \"stage-variables\": &#123;&#125;, \"context\": &#123;, \"http-method\": \"POST\", \"stage\": \"prod\", ... &#125; &#125;, \"context\": &#123; \"memoryLimitInMB\": \"128\", ... &#125;&#125; Integration Request에서 설정한 기본 템플릿을 통해 전달된 event 오브젝트와 context 객체의 내용이 구현한 함수의 기능대로 동작한다면 위와 같은 결과 값을 받을 수 있으며, 코드에 보여지는 부분들은 자주 참조 되는 영역만을 코드에 표시했다. event 객체의 구조는 앞으로 사용할 lambda 함수에서 event 객체를 사용하는 reference가 된다.보면 event 에도 context가 존재하는데 여기에 stage property가 있고 우리가 deploy했던 stage를 참조할 수 있는데 이를 통해 (프로덕션 코드와 개발코드가 분리되는데 맞지만) lambda 함수에서 개발 버전 또는 배포 버전의 일에 대해 분기를 할 수 있게 된다. travis ci를 통한 배포 자동화code로 대신한다. 1234567891011deploy:- provider: lambda function_name: loopbackArgument role: arn:aws:iam::... handler_name: handler region: ap-northeast-2 access_key_id: ... secret_access_key: secure: ... runtime: nodejs4.3 timeout: 30 조금 부연하자면 role은 lambda함수를 생성할 때 줬던 role(lambda 함수 실행을 위한) 이 들어가야된다. 추가적으로 메모리 사용량 설정등도 가능하다. s3를 통해 업로드하는 방식과 달리 폴더를 압축해서 zip파일을 업로드하게 되는데 이때 용량제한이 걸린다. 압축한 파일을 용량이 50MB를 넘어가면 deploy에 실패하게 되니 주의하자. 이 때는 s3에 upload 하고 추가로 스크립팅을 통해 deploy 되야하므로 번거로워진다. next 실무 적용 및 효율 적인 업무를 위한 추가 적인 작업들은 아래와 같다. todo custom domain을 통한 배포 ssl 적용 api gateway cors 적용 swagger를 통한 문서화 및 배포 slack을 통한 알림 처리","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"aws","slug":"dev/aws","permalink":"http://blog.bglee.me/categories/dev/aws/"}],"tags":[{"name":"aws","slug":"aws","permalink":"http://blog.bglee.me/tags/aws/"},{"name":"ci","slug":"ci","permalink":"http://blog.bglee.me/tags/ci/"},{"name":"api gateway","slug":"api-gateway","permalink":"http://blog.bglee.me/tags/api-gateway/"},{"name":"lambda","slug":"lambda","permalink":"http://blog.bglee.me/tags/lambda/"},{"name":"travis","slug":"travis","permalink":"http://blog.bglee.me/tags/travis/"},{"name":"lambda 배포","slug":"lambda-배포","permalink":"http://blog.bglee.me/tags/lambda-배포/"}]},{"title":"github - travis ci - slack","slug":"github-travis-ci","date":"2016-08-14T15:00:00.000Z","updated":"2018-03-29T06:03:19.625Z","comments":true,"path":"posts/2016/github-travis-ci/","link":"","permalink":"http://blog.bglee.me/posts/2016/github-travis-ci/","excerpt":"","text":"코드를 커밋하고 ci가 검증하고 이에 대한 결과를 슬랙으로 받고자 한다.circle ci, travis ci 등 ci cloud service가 많은데 open source 를 지원해주는 travis-ci를 기준으로 해서 작성한다. circle ci도 개인 레포지터리 하나에 대해선 지원을 해준다. travis-ci, github 연결순서대로 진행을 하면 github과 ci를 연결해야한다. 일단 github에서 travis-ci를 사용하기 위해선 travis-ci.org에 계정을 만들고 github계정과 싱크를 한다. 그러면 개인 레포지터리가 보이게 되고 여기서 활성화를 하면 된다. 활성화를 하면 다음과 같이 github =&gt; repo =&gt; Settings =&gt; Webhooks &amp; services 에 Travis CI 가 들어 온 것을 확인 할 수 있다. 소스코드에서는 travis에서 읽어갈 설정 파일을 만든다. travis-ci는 cli를 제공하므로 이를 설치하도록 한다. ruby 종속성이 있으므로 없으면 이를 먼저 설치한다. 1gem install travis 이제 코드가 있는 디렉토리로 가서 .travis.yml 파일을 생성한다. 1travis init 이때 github에서 clone된 폴더로 작업을 하고 있었다면 자동으로 레포 정보를 가져오고 언어는 현재 사용하는 언어를 해주면 알아서 생성해준다. npm을 사용한 프로젝트라면 ci가 한번 돌 때마다 npm install에서 소요되는 시간이 상당하므로 캐쉬 설정을 해준다. install:에서 npm install을 한 경우에만 캐싱되는 것으로 보인다(또는 다른 곳에서 npm install을 하지 않은 경우) 123cache: directories: - node_modules slack 연결slack에 계정이 없다면 가입을 해서 생성을 하고 travis-ci를 설정하도록 한다 여기서 install을 눌러 설치를 하고 Post to Channel에서 원하는 채널이나 본인(Privately to @deptno (you))에게 알려주도록 설정한다. token 은 노출되면 안되므로 Encrypting your credentials에 써있는 코드를 복사해서 위에서 생성한 .travis.yml 이 있는 디렉토리에서 실행한다. 그러면 .travis.yml에 slack에 알림 설정이 된다. 이제 코드를 푸시해서 master 에 들어오게 되면 알림이 뜨게된다. 배포가 남았는데 배포는 서버 환경에 의해 좌우되므로 나눠서 기약없는 추후에 다루기로 한다.","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"ci","slug":"dev/ci","permalink":"http://blog.bglee.me/categories/dev/ci/"}],"tags":[{"name":"ci","slug":"ci","permalink":"http://blog.bglee.me/tags/ci/"},{"name":"travis ci","slug":"travis-ci","permalink":"http://blog.bglee.me/tags/travis-ci/"},{"name":"circle ci","slug":"circle-ci","permalink":"http://blog.bglee.me/tags/circle-ci/"},{"name":"slack","slug":"slack","permalink":"http://blog.bglee.me/tags/slack/"},{"name":"github","slug":"github","permalink":"http://blog.bglee.me/tags/github/"},{"name":"devops","slug":"devops","permalink":"http://blog.bglee.me/tags/devops/"},{"name":"notification","slug":"notification","permalink":"http://blog.bglee.me/tags/notification/"}]},{"title":"aws code deploy - ci","slug":"aws-code-deploy","date":"2016-08-14T15:00:00.000Z","updated":"2018-03-29T06:03:19.621Z","comments":true,"path":"posts/2016/aws-code-deploy/","link":"","permalink":"http://blog.bglee.me/posts/2016/aws-code-deploy/","excerpt":"","text":"TODO 권한 이슈에 따른 이슈 (IAM role) 트러블 슈팅 github - ci - slack 링크 연결 aws를 잘 모르는 상태에서 aws code deploy와 travis ci, slack을 통해 배포하기 위해 삽질한 기록. 입사한지 4개월이 조금 넘어가는데 프론트엔드를 리딩을 하다보니 배포에 대한 니즈를 느끼게 되었고 그 삽질한 과정이다. 첫번째 프로젝트는 ci까지는 연결하고 배포는 쉘 스크립트를 이용해 scp로 운영하는 서버에 배포했다. 현재는 두번째 프로젝트를 조용히(?) 진행하고 있는데 n대의 서버에 배포하는 프로젝트를 곧 진행하게 될 것 같아 이 기회에 진행했다. 회사는 현재 aws를 통해 서비스를 제공하고 있고, github enterprise를 통해 코드를 관리하고 있으며 travis-ci를 도입하는 단계에 있다. aws code deploy 는 배포 코드를 여러대의 aws 서버에 순차적으로 또는 한번에 배포를 할 수 있게 하는 시스템이라 생각하면 된다. 코드 작성 부터 배포 까지의 한 사이클은 다음과 같다. github code 작성 =&gt; commit =&gt; push =&gt; pull request =&gt; merge ci pull =&gt; test =&gt; deply code deploy 배포파일 download =&gt; 각 서버에 워하는 대로 배포 github =&gt; ci에 대한 것은 github - travis ci - slack 포스트를 참조한다. code deploy 설정배포는 여러가지 방법이 있는데 aws code deploy 는 aws에서 여러대의 서버에 배포를 할때 쓰인다. aws를 잘 모르는 상태에서 시간이 꽤나 걸렸는데 권한 설정에 대한 이해가 발목을 잡았던 것 같다. 우리는 지금 코드가 푸시되면 ci를 돌리고 있고 그 결과를 slack으로 받고 있다. 이제 ci가 성공했을 때 deploy를 해야한다. code deploy가 의미를 가지려면 여러대의 서버를 사용해야하고 auto scaling등의 기능을 사용해야하겠지만 여기선 배제한다. 알아둬야할 사항은 다음과 같다. aws console 에서 우리가 접근 할 서비스는 아래와 같다. EC2 CodeDeploy Identity &amp; Acceess Management(IAM) S3(s3를 통해 배포된다면) ec2 instance 자체에 code deploy를 위한 role 을 설정해줘야하며 이는 instance 시작 후에 변경이 불가능(?) 하다(이미 돌아가고 있는 인스턴스에는 적용할 수 없다). codedeploy-agent 가 각 인스턴스 마다 설치 되어있어야 한다. code deploy는 배포 데이터를 s3 또는 github으로 부터 번들링 된 데이터를 가져와서 실행하게 된다. 번들링 된 데이터에는 code deploy가 무엇을 배포해야할지 알 수 있게 하는 설정파일이 root 에 포함되어야 한다. 파일 이름은 appspec.yml 이다. appspec.yml참고 문서 를 보면 단순하고 또 정리가 잘 되어 있으므로 참고하기가 편하다(읽기 귀찮으면 example 로 직행). 단순하게 실 사용하는 파일 내용은 다음과 같다. 12345version: 0.0os: linuxfiles: - source: / destination: /var/www/renderer/ appspec.yml 에서 files 섹션을 보면 source와 destination이 있는데 source 는 번들링 파일의 구조를 기준으로 root를 설정한다. 쉽게 말하면 appspec.yml 이 있는 위치가 root(/) 가 된다. destination 은 각 서버에 복사될 위치를 나타내며 서버안에서의 위치를 생각하면 된다. code deploy는 각각의 서버에서 직접 번들링된 파일을 내려받아 실행되는 구조로 보인다. 이 때문에 인스턴스 생성 때문에 code deploy 에 대한 role 을 가지고 있어야 한다. 번들링 된 배포 파일의 위치가 s3 라면 이에 대한 권한 설정은 덤이다. 대략적인 한 사이클에 대한 설명은 끝(?)났으니 실제로 따라해 보도록 한다. 글은 니즈의 순서대로 작성하고 올바른 순서는 표시를 하도록 하겠다. iam role 설정 ec2 isntance deployment group codedeploy-agent 설치 배포서버 destination의 권한 확인 IAM 설정aws console =&gt; IAM =&gt; roles 에서 Create New Role 을 선택해서 code deploy 대한 설정을 해야한다. 생성 후에 Trust Relationships =&gt; Edit Trust Relationship 에서 다음과 같이 설정한다 123456789101112131415&#123; \"Version\": \"2012-10-17\", \"Statement\": [ &#123; \"Effect\": \"Allow\", \"Principal\": &#123; \"Service\": [ \"ec2.amazonaws.com\", \"codedeploy.[:region].amazonaws.com\" ] &#125;, \"Action\": \"sts:AssumeRole\" &#125; ]&#125; :region은 ec2가 존재하는 region을 설정하면된다. //TODO: role [2] EC2 설정 IAM 설정 [1] 에서 생성한 role을 선택해서 instance를 생성 하도록 한다. codedeploy-agent 설치 문서화가 잘 되어 있어 그대로 따라하면 된다. 문서 [3] AWS CodeDeploycodedeploy 설정에 진입하고 Create New Application 버튼을 눌러 배포할 application 에 대한 설정을 한다. Application Name 배포할 어플리케이션의 이름이다. Deployment Group Name 같은 설정을 통한 배포로 엮일 그룹 이름을 지정한다. Add Instances 인스턴스를 생성하면서 만든 태그를 통해 배포의 타겟이 될 인스턴스 설정을 한다. Deployment Configuration n개의 서버에 한번에 deploy 할 것인지 하나씩 순차적으로 할 것인지에 대한 정책이다. 한대이니까 설정오류가 나지 않도록 CodeDeployDefault.AllAtOnce를 설정한다(배포시에 서빙가능한 서버가 없어도 된다). Service Role //TODO: codedeploy.[:region name].amazonaws.com 에 대한 설정이 되어 있는 role을 필요로 한다. [1] 에서 생성한 deployment group 에 대한 role을 선택한다. CI_ 설정CI가 slack에 알리는 것 외에 배포를 트리거 할 수 있도록 .travis.yml 에 codedeploy 관련 설정을 추가하고 번들링해서 업로드할 경로를 함께 설정한다. 123456789101112131415161718192021222324before_deploy:[: 여기서 build를 한다]before_deploy:- mkdir -p [:업로드할 번들링 된 파일이 존재하는 디렉토리]- cp appspec.yml [:번들링 할 루트가 되는 디렉토리]- cd [:번들링 할 루트가 되는 디렉토리] zip -r ../[:업로드할 번들링 된 파일이 존재하는 디렉토리]/[:file key(file name)] .- cd ..deploy:- provider: s3 access_key_id: [:your access key] secret_access_key: [:your secret access key] local_dir: [:업로드할 번들링 된 파일이 존재하는 디렉토리] skip_cleanup: true bucket: [:bucket name] on: branch: master- provider: codedeploy access_key_id: [: your access key] secret_access_key: [:your secret access key] region: [:code deploy application이 존재하는 region] bucket: [:bucket name] key: [:file key(file name)] application: [:code deploy에 설정된 application] deployment_group: [:code deploy에 설정된 deployment group] [:번들링 할 루트가 되는 디렉토리] 컴파일 된 소스코드만 배포하면 되니 빌드된 바이너리나 코드가 있는 곳을 지정. 이제 ci가 deploy 전 단계까지 성공한 다음에는 s3에 번들링된 파일을 업로드하게 되고 code deploy 를 트리거하게 된다. 잘 되었는지 확인하기 위해서 aws console의 aws codedeploy로 진입하여 대상 application을 선택하면 배포 상태를 확인 할 수 있다. 실패한 경우에는 로그와 함께 어떤 상태에서 실패했는지를 확인 할 수 있다. download 에서 실패하면다면 s3에 대한 접근 권한 문제일 가능성이 크다.","categories":[{"name":"setup","slug":"setup","permalink":"http://blog.bglee.me/categories/setup/"},{"name":"ci","slug":"setup/ci","permalink":"http://blog.bglee.me/categories/setup/ci/"}],"tags":[{"name":"aws","slug":"aws","permalink":"http://blog.bglee.me/tags/aws/"},{"name":"code deploy","slug":"code-deploy","permalink":"http://blog.bglee.me/tags/code-deploy/"},{"name":"ci","slug":"ci","permalink":"http://blog.bglee.me/tags/ci/"},{"name":"travis ci","slug":"travis-ci","permalink":"http://blog.bglee.me/tags/travis-ci/"},{"name":"circle ci","slug":"circle-ci","permalink":"http://blog.bglee.me/tags/circle-ci/"},{"name":"slack","slug":"slack","permalink":"http://blog.bglee.me/tags/slack/"}]},{"title":"vim node plugin","slug":"vim-node-plugin","date":"2016-08-02T15:00:00.000Z","updated":"2018-03-29T06:03:19.633Z","comments":true,"path":"posts/2016/vim-node-plugin/","link":"","permalink":"http://blog.bglee.me/posts/2016/vim-node-plugin/","excerpt":"","text":"VIM 플러그인을 node로 작성하는 방법에 대해 간단히 리포트한다. 기본적으로 지원하는 플러그인은 vimscript, python정도로 보이는데 작은 기능을 추가하려고하는데 언어까지 배우기는 뭐해서 방법을 찾아봤다. 플러그인의 기능을까지라고 할 수 있을진 모르겠지만 node를 통해 간단한 작업은 할 수 있다. OSX를 기준으로 작성되었고 neovim을 사용하고 있다. 홈 디렉토리 안에 .vimrc파일이 설정일텐데 neovim에서는 .config/nvim/init.vim파일이 그 역할을 대신한다. 여튼 설정 파일을 열고 다음과 같이 추가해준다. 코드가 우아하진 않고 공유차원이 그러려니… 12345678910111213function CallNode(...) execute '%! node -e \"require(\\\"$HOME/.config/node-connector\\\")[\\\"' . a:1 . '\\\"][\\\"' . a:2 . '\\\"]()\"'endfunctionfunction CallNodeWithEcho(...) echom system('node -e \"require(\\\"$HOME/.config/node-connector\\\")[\\\"' . a:1 . '\\\"][\\\"' . a:2 . '\\\"](\\\"' . a:3 . '\\\")\"')endfunctionnmap ,fj :&lt;C-U&gt;call CallNode(\"format\", \"json\")&lt;CR&gt;nmap ,fx :&lt;C-U&gt;call CallNode(\"format\", \"xml\")&lt;CR&gt;nmap ,trk :&lt;C-U&gt;call CallNodeWithEcho(\"translate\", \"en\", getline(\".\"))&lt;CR&gt;nmap ,tre :&lt;C-U&gt;call CallNodeWithEcho(\"translate\", \"ko\", getline(\".\"))&lt;CR&gt;nmap ,trj :&lt;C-U&gt;call CallNodeWithEcho(\"translate\", \"ja\", getline(\".\"))&lt;CR&gt; CallNode 와 CallNodeWithEcho 함수가 있는데 후자는 결과 값을 VIM의 status bar에 표시해주는 역할을 한다. 아래 다섯개의 함수를 정의했는데 역할은 순서대로 다음과 같다. formating json formating xml 영어로 번역 한국어로 번역 일본어로 번역 함수의 정의를 보면 알겠지만 단순히 node 스크립트를 로딩해서 실행하는 것이다. $HOME/.config/node-connector node script를 로드하므로 이 파일을 작성해줘야한다. node-connector.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879var pd = require('pretty-data').pd;module.exports = &#123; format: &#123; json: function() &#123; let i = process.stdin, d = ''; i.resume(); i.setEncoding('utf8'); i.on('data', function(data) &#123; d += data; &#125;); i.on('end', function() &#123; try &#123; console.log(JSON.stringify(JSON.parse(d), null, 4)); &#125; catch(ex) &#123; console.log(d); &#125; &#125;); &#125;, xml: function() &#123; let i = process.stdin, d = ''; i.resume(); i.setEncoding('utf8'); i.on('data', function(data) &#123; d += data; &#125;); i.on('end', function() &#123; try &#123; console.log(pd.xml(d)); &#125; catch(ex) &#123; console.log(d); &#125; &#125;); &#125; &#125;, translate: &#123; en: function(text) &#123; this.tr('en', text); &#125;, ja: function(text) &#123; this.tr('ja', text); &#125;, ko: function(text) &#123; this.tr('ko', text); &#125;, tr: function(source, text) &#123; var https = require('https'); var client_id = ''; //TODO: use yours var client_secret = ''; //TODO: use yours var host = 'openapi.naver.com'; var port = 443; var uri = '/v1/language/translate'; var data = require('querystring').stringify(&#123; source: source, target: source !== 'ko' ? 'ko' : 'en', text: text &#125;); var options = &#123; host: host, port: port, path: uri, method: 'POST', headers: &#123; 'X-Naver-Client-Id':client_id, 'X-Naver-Client-Secret': client_secret, 'Content-Type': 'application/x-www-form-urlencoded', 'Content-Length': Buffer.byteLength(data) &#125; &#125;; var req = https.request(options, function(res) &#123; res.setEncoding('utf8'); res.on('data', function (chunk) &#123; console.log(JSON.parse(chunk).message.result.translatedText); &#125;); &#125;); req.write(data); req.end(); &#125; &#125;&#125;; 번역 api를 서비스로 네이버 개발자용을 쓰고 있어서 이 부분은 각자 발급해서 본인 것을 쓰면 된다. 이제 문장이 있는 줄에서 영어로 번역을 원한다면 ,trk를 누르면 된다. json파일을 포맷팅하고 싶다면 ,fj 이런식이다. 오류가 발생하면 그대로 원본글 그대로를 보여주게 해놓았다. 더 참조가 필요하다면 필자의 셋업을 참조하도록한다. 보통 난 노트북을 새로 셋업할때 git을 깔고 처음으로 설정을 클론뜨도록 해두었다. vim은 터미널 환경의 반이니까. https://github.com/deptno/.config","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"js","slug":"dev/js","permalink":"http://blog.bglee.me/categories/dev/js/"}],"tags":[{"name":"neovim","slug":"neovim","permalink":"http://blog.bglee.me/tags/neovim/"},{"name":"vim","slug":"vim","permalink":"http://blog.bglee.me/tags/vim/"},{"name":"vim plugin node","slug":"vim-plugin-node","permalink":"http://blog.bglee.me/tags/vim-plugin-node/"},{"name":"vim plugin javascript","slug":"vim-plugin-javascript","permalink":"http://blog.bglee.me/tags/vim-plugin-javascript/"}]},{"title":"Neovim","slug":"nvim","date":"2016-08-02T15:00:00.000Z","updated":"2018-03-29T06:03:19.630Z","comments":true,"path":"posts/2016/nvim/","link":"","permalink":"http://blog.bglee.me/posts/2016/nvim/","excerpt":"","text":"12345brew install neovim/neovim/neovimcurl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vimcd ~ &amp;&amp; git clone https://github.com/deptno/.config.gittouch ~/.local.vim 만약 .config 디렉터리가 있다면 실패하게된다 이때는 레포에 직접 접속해서 .config/nvim/init.vim을 들고와서 넣어준다. 특정 폰트를 사용해야만 깨짐이 없으므로 패치된 폰트를 아래서 하나 받아 설치하고 iTerm2의 Non-ASCII Font를 설치한 폰트로 설정.https://github.com/ryanoasis/nerd-fonts 너무 많아서 개인적으로는 그 중에 들어본 폰트를 설치했다. 123brew unlink vimcp -f /usr/local/bin/nvim /usr/local/bin/vicp -f /usr/local/bin/nvim /usr/local/bin/vim path문제로 되지 않을 경우 .zshrc의 PATH를 수정하면된다 trouble shooting E902: “eslint” is not an executable js 파일 수정시 eslint 가 실행되야 하는데 없어서 생기는 문제다. 1npm -g install eslint requires Vim compiled with Python (2.6+ or 3.3+) support YouCompleteMe와 같은 플러그인은 파이썬을 필요로한다. 12brew install python3pip3 install --upgrade neovim [https://neovim.io/doc/user/provider.html]","categories":[{"name":"setup","slug":"setup","permalink":"http://blog.bglee.me/categories/setup/"}],"tags":[{"name":"neovim","slug":"neovim","permalink":"http://blog.bglee.me/tags/neovim/"},{"name":"vim","slug":"vim","permalink":"http://blog.bglee.me/tags/vim/"},{"name":"nvim","slug":"nvim","permalink":"http://blog.bglee.me/tags/nvim/"}]},{"title":"맥북 설정","slug":"osx","date":"2016-07-27T15:00:00.000Z","updated":"2018-03-29T06:03:19.631Z","comments":true,"path":"posts/2016/osx/","link":"","permalink":"http://blog.bglee.me/posts/2016/osx/","excerpt":"","text":"맥북 때문에 겁먹은 동지들을 위해 씀.이 글의 대상은 일반인과 (프론트엔드)개발자를 모두 포함한다. 맥을 받으면 App Store에 가서 OS 부터 업데이트를 시작한다.그 동안 만약에 키보드랑 마우스를 받았는데 Apple 이 안찍혀있으면 어차피 방해되므로 몰래 버리도록 한다.시스템 환경설정에 들어간다. 키보드 부터 설정해야한다. 키보드 설정키보드 설정은 시스템 환경설정을 통해 진입하면 된다. ^ 이건 ctrl \\- 이런식으로 생긴건 alt 꽃무니같은 건 command 키다. 캡쳐하기 귀찮아서 키보드로 쳤다… 키보드 모든 F1, F2 등의 키를 표준 기능 키로 사용 설정 단축키 입력 소스 입력 메뉴에서 다음 소스 선택 *만** 설정 단축키 Spotlight Spotlight 검색 보기 ^스페이스 로 설정 이거면 우리는 키보드를 사용할 수 있게 된다. 다음은 터치패드다. 터치 패드 설정터치 패드 설정은 시스템 환경설정을 통해 진입하면 된다. 체크 박스아래에 세 손가락으로 탭하기등도 설정메뉴이므로 동일 하게 설정한다.그럼 클릭이 아닌 탭으로 클릭동작을 수행할 수 있고 두 손가락으로 우클릭이 가능해진다.네 손가락으로 스와이프를 하면 바탕화면간 이동이 가능해진다. 설정 메뉴 자체가 튜토리얼이니 유심히 보도록 한다. 중요하다. 손쉬운 사용손쉬운 사용도 시스템 환경설정을 통해 진입한다. 마우스와 트랙패드 트랙패드 옵션... 관성사용 체크 세 손가락으로 드래그하기 체크 이제는 손가락 3개로 드래그가 가능해져서 마우스가 필요 없어진다. 프로그램 설치 일만 하면 우울하니까 카카오톡 설치한다. 여기서 부턴 개발자를 위한 코스다. 요즘은 보통 쓰는 Slack 설치한다. 개발자니까 터미널은 있어야한다. iTerm을 설치한다. FE 개발자니까 Chrome, WebStorm 설치한다. 에디터 하나는 필요하니까 리듬에 맞춰 하나 선택한다. neovim - 설정 포스트 vs code atom 개발 환경 셋업이제 터미널도 생겼고 개발 프로그램들도 설치했으니 필요한 환경들을 셋업한다. Gitgit은 터미널에서 git이라고 치면 라이센스 어쩌고 나오게 된다 그걸 설치하면된다. 터미널 환경 설정ohmyzsh - 설정 포스트 을 설치하면 터미널에서 git status를 별다른 명령어 없이 바로 설정할 수 있다. 패키지 매니저 설치debian의 apt-get이 있다면 여긴 brew가 있다.링크를 타고 가서 설치 스크립트를 복사해서 터미널에 붙이면된다. brew search [package name] brew install [package name] 개인적으로는 neovim을 에디터로 쓰므로 그에 따른 플러그인 환경을 셋업하다보면 대충 다음정도는 바로 깔아줘야한다. history에서 발췌한 몇가지는 아래와 같다. 1234brew install nodebrew install git-flow-avhbrew install treebrew install python3 이제 node 설치됐으니 npm을 통해 필요로 하는 셋업을 해주면된다. 생활 유틸리티 Shiftit - open source로 키보드로 창 이동을 하게 해준다. Windows 유저였다면 Window + 방향키 느낌이라고 생각하면된다. Numbers - 애플 버전 스프레드 시트다. 회사 생활하려면 엑셀은 열얼봐야한다. vlc - open source movie player. 가끔 개발을 위해 미디어 포맷을 확인한다거나(?) 생각없이 버그 잡으면서 영상 틀어놀때 필요하다. yoink - 드래그로 파일 이동시에 워크스페이스(바탕화면 하나)를 넘어가는 경우에 발생하는 짜증을 감소시켜준다. 유료다. 이제 코드를 짜면 된다.","categories":[{"name":"setup","slug":"setup","permalink":"http://blog.bglee.me/categories/setup/"}],"tags":[{"name":"맥북 셋업","slug":"맥북-셋업","permalink":"http://blog.bglee.me/tags/맥북-셋업/"},{"name":"맥북 개발 환경 설정","slug":"맥북-개발-환경-설정","permalink":"http://blog.bglee.me/tags/맥북-개발-환경-설정/"},{"name":"osx 개발 환경","slug":"osx-개발-환경","permalink":"http://blog.bglee.me/tags/osx-개발-환경/"},{"name":"맥북 설정","slug":"맥북-설정","permalink":"http://blog.bglee.me/tags/맥북-설정/"}]},{"title":"React 구현 전략","slug":"react-strategy","date":"2016-07-21T15:00:00.000Z","updated":"2018-03-29T06:03:19.631Z","comments":true,"path":"posts/2016/react-strategy/","link":"","permalink":"http://blog.bglee.me/posts/2016/react-strategy/","excerpt":"","text":"임베디드 브라우저에서 사용되는 앱을 Web 기술을 통해서 구현했던 터라 일반적인 Web 서비스의 구현이 처음이기도 해서 시행착오가 꽤나 있었다(인증, 배포, 서버 통신).처음으로 주어진 사내 서비스에 대한 구현을 잘 알지도 못하는 React로 구현하면서 느낀 점, 그리고 다음 구현에 대한 개인적인 글이다. TypeScript를 적용해야겠다.서버와의 통신이 많은데 interface는 컴파일레벨에서 많은 도움을 준다. 아쉬운 점은 React에서 중점적으로 쓰이는 Rest/Spread 지원이 아직 되지 않는 점인데 이 부분에 대한 부분은 pure js로 라이브러리화 하여 사용하는 면이 귀찮지만 그래도 득이 있을 것으로 생각된다. 실무에서는 데이터 통신 부분에서만 TypeScript를 적용하여 반쪽짜리 사용을 하고 있는데 이를 통해서도 득이 있었다. Container와 Component에 대한 개념을 탑재하자Redux를 적용하면서 Container와 Component에 대한 개념적인 부분이 약했다. code상으로는 redux의 connect를 통해 wrapping된 component가 Container인데 UI에서 제공하는 페이지당 하나의 Container를 둬서 통신에 대한 모듈로서의 역할을 명확히 하고 나머지 UI에 대한 부분은 Pure Component로 작성하는 것이 중요하다. 이에 대한 처리가 미흡하면 여기 저기선 connect를 하게 되어 data flow가 망가지고 컴포넌트의 순수성이 망가져서 test code의 작성을 불가 하게 한다. Immutable에 대한 적용은 뒤로 미뤄보자react, redux, immutable이 마치 세트처럼 다뤄지고 있지만 각각의 역할이 있고 도입 동기가 있어야했다. immutable은 사용성에서 pure javascript와는 이질적인 부분이 존재하고 객체가 pure인지 immutable객체인지에 대한 판단을 코드레벨에서 요구하게 된다. 사용성에 대한 부분을 개선한 seamless immutable 같은 경우에는 class의 instance를 유지하지 못하는 단점이 있다. react-addons-update가 제공하는 방식 또한 우아하다고 느껴지진 않지만 일단 최소한의 Container에서 사용하게 된다라고 가정한다면 바이러스처럼 퍼저나가는 immutable을 나중에 수습하는 비용을 뒤로 미룰 수 있다. UI component가 raw data를 직접 참조하지 않도록 한다.UI component가 참조하는 데이터 객체는 raw data를 품은 UI data class를 만들어서 사용한다. 이는 데이터 구조의 변경등이 있을 경우 수정 영역을 한정 할 수 있는 장점이 있고 이에 대한 저장을 store를 통한다면 강점이 있을 것 같다. 실무에서는 seamless immutable object의 instance를 유지하지 못하는 문제로 새로운 레이어를 만들어서 참조를 유지하도록 했다. StoreStore에 서버로 부터 받은 데이터 형태를 그대로 저장하고 있었는데 normalizr등을 통해 Object형태로 key값을 통해 바로 참조할 수 있는 형태가 여러 API를 통해 data의 수정등에 유연하게 대처할 수 있지 않나 한다.","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"js","slug":"dev/js","permalink":"http://blog.bglee.me/categories/dev/js/"}],"tags":[{"name":"react","slug":"react","permalink":"http://blog.bglee.me/tags/react/"}]},{"title":"React.js 프로 리액트","slug":"book-pro-react","date":"2016-07-21T15:00:00.000Z","updated":"2018-03-29T06:03:19.623Z","comments":true,"path":"posts/2016/book-pro-react/","link":"","permalink":"http://blog.bglee.me/posts/2016/book-pro-react/","excerpt":"","text":"React.js를 이용한 모던 프런트엔드 구축 읽으면서 중요하다고 생각하는 것 몇 가지에 대한 정리 Props conventiononChange등과 같이 camelCase가 사용되며 DOM API의 기준으로 element에 class등을 넣기 위해서는 className 프로퍼티가 대신 사용된다. Controlled Component와 Un Controlled Component둘을 나누는 차이는 가볍게 코드 상에서 props.value의 존재 유무라고 생각하면 된다.value가 존재하면 이에 대한 제어를 위해 onChange와 같은 이벤트를 받아 state를 관리하게 된다. 이 말은 Pure Component가 아니라는 말과 의미가 통하는 부분이 있다. Controlled ComponentControlled Component는 user action(click, typing 등)에 의해서 변하는 상태 값을 Component가 핸들링한다. Un Controlled Component상태값을 유지하지 않기 때문에 특정 시점에 Un Controlled Component 로 부터 데이터를 가져오는 작업이 필요하다. value prop이 사용되지 않기 때문에 기본 값 등의 셋업을 위해서는 defaultValue가 사용된다. Virtual DOMVirtual DOM을 통해 렌더링을 다시할 부분을 계산하게 되는데 이때 List형식의 DOM에 대해 insert, remove, move 등을 인지 할 수 없으므로 key 프로퍼티가 사용된다. 실무에서 적용할 때는 시간이 없어(?) warning을 지우기 위해 의미없는 index값을 대입했었으나 이 부분이 의미 있기 쓰이려면 List의 각 row가 가지고 있는 데이터의 매칭이 이루어져야 하므로 data의 id값 등을 넣어야한다. Shallow CopyReact에서 컴포넌트의 렌더링에 대해 비교할 때 레퍼런스를 비교하게 되는 것으로 예상(?)하고 있는데 이에 대한 처리를 정확히 해서 렌더링을 줄여 퍼포먼스 향상을 위해 Shallow Copy를 이해할 필요가 있다. 이에 대한 처리를 위해 facebook에서 만든 Immutable.js이 있고 순수 자바스크립트처럼 사용이 가능한 seamless-immutable 등의 구현체가 있으나 각각이 가지는 단점이 존재하여 단순한 큰 규모의 어플리케이션이 아니라면 얕은 복사에 대한 이해를 바탕으로 해결 할 수 있는 부분이 있을 것으로 보인다. Object, Array등 레퍼런스등의 객체를 직접 수정하는 것이 아닌 새로운 객체를 대입하는 케이스가 flux 아키텍쳐에서는 자주 일어나는데 이를 위해 Object.assign, Array의 map, concat등의 메서드를 자주 사용하게 된다. 새로운 레퍼런스를 반환하지만 Array나 Object안에서 다른 Array나 Object를 포함하고 있다면 이에 대한 레퍼런스는 유지되게 된다. 이에 대한 이해가 있으면 될 것 같다. 관련 라이브러리react-addons-update TestReact에서는 test framework으로 jest 를 권장하고 있다. 관련 라이브러리react-addons-test-utils ETC이 외에도 Router(react router)와 flux(redux가 아닌) 자체, 서버 사이드 렌더링, 퍼포먼스 튜닝등의 내용을 담고 있다.","categories":[{"name":"summary","slug":"summary","permalink":"http://blog.bglee.me/categories/summary/"}],"tags":[{"name":"pro react","slug":"pro-react","permalink":"http://blog.bglee.me/tags/pro-react/"},{"name":"프로 리액트","slug":"프로-리액트","permalink":"http://blog.bglee.me/tags/프로-리액트/"}]},{"title":"webpack babel 설정","slug":"webpack-babel","date":"2016-07-20T15:00:00.000Z","updated":"2018-03-29T06:03:19.634Z","comments":true,"path":"posts/2016/webpack-babel/","link":"","permalink":"http://blog.bglee.me/posts/2016/webpack-babel/","excerpt":"","text":"webpack을 통해 번들링Webpack은 파일을 하나로 묶어주는 번들러고 Babel은 ES2015/2016/2017 =&gt; ES5로 내려주는 트랜스파일러다. 둘을 세트로 셋업하는 경우가 흔하고 사용 방법이 두가지가 존재하고 많은 예제들이 너무 여러가지를 포함하고 있어서 기본을 셋업할 수 있도록 정리하려 한다. 1webpack ./entry.js bundle.js Webpack을 위와 같이 실행하면 entry로 부터 참조는 모든 의존성을 묶어 bundle.js 파일 하나로 묶어낸다. 실제로는 config 파일을 생성해서 쓰게 되다. webpack.config.js123456789module.exports = &#123; module: &#123; loaders: [&#123; test: /\\.jsx*$/, exclude: /node_modules/, loader: 'babel' &#125;] &#125;&#125;; 이 파일에서 로더를 설정하여 js, jsx파일을 만나게 되면 babel-loader를 통해서 번들링되며 이 과정에서 babel은 babel 설정을 로드한다. 여러가지 설정 방법 중에 .babelrc를 생성하는 방법을 선호하며 json을 다음과 같이 작성한다. .babelrc123&#123; \"presets\": [\"es2015\", \"stage-0\", \"react\"]&#125; 사용하는 프리셋들은 babel 플러그인들의 집합인데 각각 간단히 설명하면 다음과 같다. * es2015: es2015(ES6) 문법을 지원한다. * stage-0: es2016(ES7) 이상의 실험적인 문법을 지원한다. * react: jsx를 지원한다. 이렇게 설정을 해 놓으면 entry.js 부터 ES2015 혹은 그 이상(stage-0 때문)의 문법으로 작성이 가능하고 바벨을 통해 ES5로 bundle.js파일이 생성되게 된다. 클라이언트에서 로드하게 되는 static file은 위와 같은 방식으로 만들면 된다. runtime에 적용node로 작성을 한다고 가정해보자. 클라이언트에서 생성된 파일을 로드하는 것과는 달리 실행을 시켜야한다. 보통 이런식이 된다. 1node index node는 버전에 따라 다르지만 현재를 기준으로 es2015 문법이 완전히 지원되지 않는다. 이전에 작업한 파일을 가지고 시작한다고 가정하면 하나의 파일만 작성하면된다. index.js123456require('babel-register')(&#123; \"plugins\": [[ \"babel-plugin-webpack-loaders\", &#123; \"config\": \"./webpack.config.js\" &#125; ]]&#125;);require('main.js'); babel-register로드하면서 플러그인으로 babel-plugin-webpack-loaders를 설정하면서 webpack-config.js를 로드한다 이후 파일(main.js) 부터는 es2015 문법을 지원하게 된다. babel-nodebabel-node는 node의 wrapper라고 생각하면된다. .babelrc만 작성되어있으면 바로 es2015등의 문법 사용이 가능하다. 사용을 위해선 설치를 해야한다. 12npm install --save-dev babel-cli./node_modules/.bin/babel-node main 성능상의 이슈가 있으며 프로덕션 모드에서는 사용하지 않는다. trouble shooting problem 2016-08-22 123456789101112$ npm start&gt; open http://localhost:3000//Users/bglee/tmp/paperboy-client/node_modules/rimraf/node_modules/glob/glob.js:106 for (var j = 0; j &lt; set[0].length; j++) &#123; ^TypeError: Cannot read property 'length' of undefined at Function.glob.hasMagic (/Users/bglee/tmp/paperboy-client/node_modules/rimraf/node_modules/glob/glob.js:106:29) at rimraf (/Users/bglee/tmp/paperboy-client/node_modules/rimraf/rimraf.js:61:36) at ExecBuffer.cleanup (/Users/bglee/tmp/paperboy-client/node_modules/exec-buffer/index.js:124:2) at ExecBuffer.&lt;anonymous&gt; (/Users/bglee/tmp/paperboy-client/node_modules/exec-buffer/index.js:103:10) at FSReqWrap.readFileAfterClose [as oncomplete] (fs.js:439:3) solution 1npm i rimraf@2.2.8 ramraf와 glob관 버전 호환성 문제로 보인다 rimraf를 강제로 버전을 고정시켜준다.","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"js","slug":"dev/js","permalink":"http://blog.bglee.me/categories/dev/js/"}],"tags":[{"name":"babel","slug":"babel","permalink":"http://blog.bglee.me/tags/babel/"},{"name":"webpack","slug":"webpack","permalink":"http://blog.bglee.me/tags/webpack/"}]},{"title":"Promise || Async/Await","slug":"async:await","date":"2016-07-10T15:00:00.000Z","updated":"2018-03-29T06:03:19.621Z","comments":true,"path":"posts/2016/async:await/","link":"","permalink":"http://blog.bglee.me/posts/2016/async:await/","excerpt":"","text":"callback방식 1234567891011function asyncFunction(callback) &#123; setTimeout(function() &#123; if (callback) callback(1); &#125;, 1000);&#125;function caller() &#123; asyncFunction(function(returnVal) &#123; console.log('after callback()'); &#125;);&#125; promise 1234567891011121314function asyncFunction() &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(1); &#125;, 1000); &#125;);&#125;function caller() &#123; asyncFunction() .then(function resolved(resolveVal) &#123; console.log('after callback()'); &#125;) .catch(function rejected() &#123; &#125;);&#125; Async/Await / ES7 12345678async function caller() &#123; try &#123; const resolveVal = await asyncFunction(); console.log('after callback()'); &#125; catch (rejected) &#123; console.log('after reject(throw)'); &#125;&#125;; Async/Await은 Await을 사용하기 위해 함수를 async로 선언해야 한다. TypeScript는 1.7버전 이상이 있으면 사용 가능하다. 마지막으로 async 함수는 Promise를 리턴한다. 1234567891011121314151617async function returnPromise(wantToThrow) &#123; if (wantToThrow) &#123; throw false; &#125; return true;&#125;async function awaiter() &#123; const mustBeTrue = await returnPromise(); console.log(mustBeTrue) // true try &#123; await returnPromise(true); &#125; catch(ex) &#123; console.log(ex); // false &#125;&#125;","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"js","slug":"dev/js","permalink":"http://blog.bglee.me/categories/dev/js/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://blog.bglee.me/tags/es6/"},{"name":"es7","slug":"es7","permalink":"http://blog.bglee.me/tags/es7/"},{"name":"es2015","slug":"es2015","permalink":"http://blog.bglee.me/tags/es2015/"},{"name":"async await","slug":"async-await","permalink":"http://blog.bglee.me/tags/async-await/"},{"name":"async/await","slug":"async-await","permalink":"http://blog.bglee.me/tags/async-await/"},{"name":"promise","slug":"promise","permalink":"http://blog.bglee.me/tags/promise/"}]},{"title":"book-the-software-crafatsman","slug":"book-the-software-crafatsman","date":"2016-05-15T15:00:00.000Z","updated":"2018-03-29T06:03:19.623Z","comments":true,"path":"posts/2016/book-the-software-crafatsman/","link":"","permalink":"http://blog.bglee.me/posts/2016/book-the-software-crafatsman/","excerpt":"","text":"ISBN: 979011086659-48-9 93560 목차* 1부: 이념과 태도 * 21세기의 소프트웨어 개발 * 애자일 * 소프트웨어 장인정신 * 소프트웨어 장인의 태도 * 영웅, 선의 그리고 프로페셔널리즘 * 동작하는 소프트웨어 * 기술적 실행 관례 * 길고긴 여정 * 2부: 완전한 전환 * 인재 채용 * 소프투웨어 장인 면접하기 * 잘못된 면접 방식 * 낮은 사기의 대가 * 배움의 문화 * 기술적 변화의 실행 * 실용주의 장인정신 * 소프트웨어 장인으로서의 커리어 이 책은 소프트웨어 장인정신이라 칭하는 개발자가 가져야할 태도에 관한 책이다. 공감가는 부분이 꽤 있었고 도움이 되는 부분도 있었다. 소프트웨어 장인(이하 장인)은 엘리트나 슈퍼 개발자를 칭하지 않는다. 장인정신을 가진 개발자를 말한다. 주니어개발자도 장인이 될 수 있다. 장인 정신의 핵심은 열정이다. 열정이 있기 때문에 장인은 일을 일로만 바라보지 않는다. 즐거워야하고 그 즐거움을 나누고 싶기에 이를 전파한다. 이 열정은 다른 개발자도 장인이 되고자 하는 의지를 불태워 장인 파이를 키우고 종국적으론 소프트웨어 산업 전반의 역량을 향상시켜 사회에 기여하게 된다. 장인들은 열정이 있기 때문에 스스로 공부하고 이를 전파하고자 하는데 이에 대해 사회적인 가로막힘이 현실적으로 존재한다. 경직된 조직 문화, 연봉, 근무 시간, 환경 여러가지 요소가 있을 수 있는데 이에 대한 타개 방법을 프로페셔널리즘에 입각해서 풀고 있다. 개발자가 위에서 시키는 일만 하는 사람이 아니기 위해선 비즈니스를 이해해야하며 스스로 결정하고 책임을 지는 태도로 임해야한다. 침체에 빠진 조직을 구하기도 하며 구할 수 없을때는 떠나기도 해야한다. 저자는 5년이상 일한 기업이 없다고 적고 있다. 우리는 프로페셔널이기 때문에 단지 사람이나 이 기업이 마음에 든다고해서 영원히 있을 수 없고 자신의 커리와 회사의 이해가 맞을 때 우리는 함께 할 수 있다. 말도 안되는 인원과 일정이 주어지는 프로젝트에서 우리는 안된다고 의사를 전할 수 있어야하며(단순히 우리의 매니저가 아닌 마케팅 담당자 등에) 이를 영웅이 되고자하는 마음으로 푸는 프로페셔널하지 못한 결정을 하면안된다. 이건 개인을 위해서도 회사를 위해서도 옳지 못한 행위라는 것을 인지해야한다. 채용과 면접에 관해서도 나오는데 이 부분이 재밌다. 공감이 되어 기억에 남는 부분들을 적어본다. 채용과 관련해서는 장인을 찾기 위한 방법이 기재되어 있다. 장인에게 중요한건 단순 연봉이 아니기 때문에 이들을 찾기 위해서는 채용 공고부터 다시 써야한다. 일반적인 채용공고로는 장인을 꼬실 수도, 과한 오버스펙 공고로는 장인 풀 자체를 줄여 뽑을 수 없게 된다. 장인을 찾기 위한 몇가지 방법을 제시했는데 장인을 찾기 위한 그물망* Github 계정 * 블로그 * 오픈 소스 활동 * 기술 커뮤니티나 사용자 그룹 활동 내역 * 펫 프로젝트 내용 * 트위터 계정 * 좋아하는 기술서적 목록 * 참석했거나 발표했던 콘퍼런스 위와 같다. 개인적으로 성향등을 고려하였을 때 우선순위를 두자면 * Github 계정 * 블로그 * 기술 커뮤니티나 사용자 그룹 활동 내역 위 정도가 맞을 것 같다. 코드나 오픈 소스 활동등이 그대로 오픈되는 Github 계정은 말할 것도 없고 블로그 또한 자신의 지식을 공유하겠다는 큰 의지표현이라 볼 수 있다(물론 블로그 글을 통해 장인정신이 있는지를 잘 봐야한다). 펫 프로젝트는 개인 프로젝트를 말하는 것으로 보이고 오픈 소스 활동 또한 Github 계정을 통해 모두 노출된다. 기술 커뮤니티에서의 활동 내역은 장인을 찾는데 도움이 될 것 같다. 하지만 트위터의 리트윗충(개인 블로그니 막말한다)이나 페이스북 커뮤니티에는 매우 낮은 수준의 글에도 따봉충이 따르는 경우가 있기 때문에 주의를 요한다. 회사에 다니면 컨퍼러스 참여에 한계가 올텐데 이 부분에 대한 우리나라 회사의 문화(일반화의 오류 일지도?)를 생각했을 때는 컨퍼런스충을 잘 걸러야 장인을 찾을 수 있을 것으로 보인다. 면접 질문* 수수께기 문제를 내어 면접자를 바보로 만들어선안된다. * 버스안에 골프공이 몇개 들어가냐같은 잘문으로 뭘 판단하려는 건지 전혀 모르겠다. * 코딩 * 손으로 코딩문제를 풀게한다. * 글씨체를 테스트 하는 것인가? 굳이 왜 나쁜 환경에서 문제를 내는 것인가. * 인터넷을 못하게 한다. * 왜? * 알고리즘 문제를 낸다. 공부해도 잊혀진다. 내 기억력을 테스트 하려는 것인가? 알고리즘은 답이 나와있는 문제다. 인터넷에 공유되어 있다. 이런 문제에 대한 답은. 직군에 따라서는 알고리즘 문제가 나오는 것도 이해한다. 소프트웨어 장인정신은 애자일, 린, XP등과 맥락을 함께 하는 점이 꽤 된다 소프트웨어 장인정신은 실행관례로써 XP를 지지한다. XP를 지지하는 만큼 책 전반에 걸쳐 TDD에 대한 언급이 상당히 많으며 페어프로그래밍을 하라고 하고 있다. 사실 경험적으로도 레거시 코드를 가지고 요구사항과 일정이 빡빡한 프로젝트를 만나게 되면 TDD의 중요성을 느끼게 된다. 프론트엔드 테스트 자동화가 쉽지 않은데 테스트 코드 위주로 코드를 짜지 않으면 추후 리펙토링 때 히스토리 운운하며 사이드 이펙트 날 까봐 아무 것도 건드리지 못하고 예외처리의 예외처리를 해서 코드량이 익스포넨셜하게 증가하는 매직이 일어나게 된다. 많은면에서 생각이 비슷해서 놀랬다. 회사와 장인은 서로 계약관계로 서로를 평가하고 서로 이해관계가 맞아야한다. 이외에도 기술적으로 장인이 되기 위한 글도 있고 해서 지금 앞이 보이지 않거나 뭔가 막혀 있다고 생각하면 생각을 열어 줄 수 있는 기회를 얻을 수 있을 지도 모르겠다.","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"ts","slug":"dev/ts","permalink":"http://blog.bglee.me/categories/dev/ts/"}],"tags":[{"name":"소프트웨어 장인","slug":"소프트웨어-장인","permalink":"http://blog.bglee.me/tags/소프트웨어-장인/"},{"name":"프로페셔널리즘","slug":"프로페셔널리즘","permalink":"http://blog.bglee.me/tags/프로페셔널리즘/"},{"name":"실용주의","slug":"실용주의","permalink":"http://blog.bglee.me/tags/실용주의/"},{"name":"자부심","slug":"자부심","permalink":"http://blog.bglee.me/tags/자부심/"},{"name":"애자일","slug":"애자일","permalink":"http://blog.bglee.me/tags/애자일/"},{"name":"xp","slug":"xp","permalink":"http://blog.bglee.me/tags/xp/"}]},{"title":"Git","slug":"git","date":"2016-04-11T15:00:00.000Z","updated":"2018-03-29T06:03:19.625Z","comments":true,"path":"posts/2016/git/","link":"","permalink":"http://blog.bglee.me/posts/2016/git/","excerpt":"","text":"Submodule1234567$ git init$ git add *$ git submodule add [git repo#1] [target path]$ git submodule add [git repo#2] [target path]$ git commit -m \"add submodules\"$ git remote add origin [git repo#0]$ git push -u 저장소를 생성하고 서브 모듈로 두개 저장소를 가져온후 이를 리모트에 푸시한다. 1234$ git clone [git repo#0] [path]$ cd [path]$ git submodule init$ git submodule update 이제 다른 경로에서 아까 푸시한 리모트 경로를 클론하고 서브 모듈까지 모두 내려받는다. 123456789101112$ tree├── /│ ├── /submodule-01│ │ ├── sub01.file01│ │ └── sub01.file02│ │ ├── sub01.file03│ │ └── sub01.file04│ └── /submodule-02│ ├── sub02.file01│ └── sub02.file02├── root.file01└── root.file02 [git repo#0]을 기준으로 하면 커밋된 파일은 root.file01 root.file02 submodule-01 submodule-02가 된다. submodule들의 폴더만을 가지며 하위 폴더는 submodule 내 각자의 저장소에서 처리된다. 폴더가 커밋되는 이유로는 리비전 정보를 가지기 때문인 것으로 보인다.","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"git","slug":"dev/git","permalink":"http://blog.bglee.me/categories/dev/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://blog.bglee.me/tags/git/"},{"name":"submodule","slug":"submodule","permalink":"http://blog.bglee.me/tags/submodule/"}]},{"title":"slackbot","slug":"slackbot","date":"2016-04-11T15:00:00.000Z","updated":"2018-03-29T06:03:19.632Z","comments":true,"path":"posts/2016/slackbot/","link":"","permalink":"http://blog.bglee.me/posts/2016/slackbot/","excerpt":"","text":"hubot과 연동해서 slack에서 귀찮은 일들을 대신해줄 봉봇(bongbot)을 만들기로 했다. 12345npm install -g yo generator-hubotmkdir slackbotcd slackbotyo bongbotvi bin/hubot 1234export HUBOT_SLACK_TOKEN=[TOKEN]# export HUBOT_SLACK_TEAM=[TEAM]# export HUBOT_SLACK_BOTNAME=[BOTNAME]# export HUBOT_LOG_LEVEL=[LOG_LEVEL] HUBOT_SLACK_TOKEN은 https://slack.com/apps/에서 생성할 수 있다. 12npm install./bin/hubot --adapter slack 그리고… 봉봇1234git clone https://github.com/deptno/bongbot.gitcd bongbotnpm install./bin/hubot refs:https://github.com/github/hubot/blob/master/docs/index.md","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"js","slug":"dev/js","permalink":"http://blog.bglee.me/categories/dev/js/"}],"tags":[{"name":"slack","slug":"slack","permalink":"http://blog.bglee.me/tags/slack/"},{"name":"slackbot","slug":"slackbot","permalink":"http://blog.bglee.me/tags/slackbot/"}]},{"title":"OhMyZsh","slug":"ohmyzsh","date":"2016-04-11T15:00:00.000Z","updated":"2018-03-29T06:03:19.631Z","comments":true,"path":"posts/2016/ohmyzsh/","link":"","permalink":"http://blog.bglee.me/posts/2016/ohmyzsh/","excerpt":"","text":"설치12sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"vi ~/.zshrc 테마를 수정한다.ZSH_THEME=&quot;agnoster&quot; # (this is one of the fancy ones) 테마가 특수한 문자 코드를 사용하기 때문에 패치된 폰트가 필요하다. VIM 설정에서도 추가적인 폰트를 필요하므로 그 쪽을 참고한다. 안이쁘면 코딩 능력 발현이 안되므로 iTerm2의 설정에 들어가서 색상팔레트를 설정한다. 필자는 Tango Dark로 설정한다. refs:https://github.com/robbyrussell/oh-my-zsh","categories":[{"name":"setup","slug":"setup","permalink":"http://blog.bglee.me/categories/setup/"}],"tags":[{"name":"ohmyzsh","slug":"ohmyzsh","permalink":"http://blog.bglee.me/tags/ohmyzsh/"},{"name":"zsh","slug":"zsh","permalink":"http://blog.bglee.me/tags/zsh/"}]},{"title":"JavaScript","slug":"javascript","date":"2016-04-11T15:00:00.000Z","updated":"2018-03-29T06:03:19.626Z","comments":true,"path":"posts/2016/javascript/","link":"","permalink":"http://blog.bglee.me/posts/2016/javascript/","excerpt":"","text":"jshint123function exam() &#123;&#125;new (Function.prototype.bind.apply(exam, [null].concat([1,2]))); ^ Missing ‘()’ invoking a constructor. jshint를 실행할 때 supernew 을 함께 준다.","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"js","slug":"dev/js","permalink":"http://blog.bglee.me/categories/dev/js/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.bglee.me/tags/javascript/"},{"name":"js","slug":"js","permalink":"http://blog.bglee.me/tags/js/"},{"name":"jshint","slug":"jshint","permalink":"http://blog.bglee.me/tags/jshint/"}]},{"title":"TypeScript","slug":"typescript","date":"2016-04-11T15:00:00.000Z","updated":"2018-03-29T06:03:19.633Z","comments":true,"path":"posts/2016/typescript/","link":"","permalink":"http://blog.bglee.me/posts/2016/typescript/","excerpt":"","text":"requirejs.config paths관련 하여 alias된 모듈 로드 TypeScript로 작업을 작업을 한다라면 여러 문제들이 부딪히게 될 텐데 대 부분 문제들의 시작은 아마 JavaScript를 TypeScript로 포팅하면서 시작 될 것이다. 그에 대한 정리다. requirejs.config paths관련 하여 alias된 모듈 로드이미 프로젝트가 RequireJS를 사용하여 의존성 관리를 하고 있다면 의존성에 관한 경로 문제를 겪을 수 있다. 문제의 원인은 TypeScript는 컴파일을 하는 언어고 런타이밍에 세팅되는 requirejs.config 함수의 설정을 모르기 때문이다. 코드를 보자 1234567// config.jsrequirejs.config(&#123; paths: &#123; \"jquery\": \"lib/jquery\" &#125;&#125;);&#125;) paths를 통해 “jquery” 위치를 정의한다. 12345import * as $ from \"jquery\";$(function() &#123; console.log(\"document ready\");&#125;); ts파일을 작성한다. 1tsc main.ts --m amd main.ts(1,20): error TS2307: Cannot find module ‘jquery’. 모듈을 찾을 수 없다는 에러메시지가 발생하지만 main.js파일은 의도한 대로 생성된다. 123456define([\"require\", \"exports\", \"jquery\"], function (require, exports, $) &#123; \"use strict\"; $(function () &#123; console.log(\"document ready\"); &#125;);&#125;); 의도한 대로 파일이 생성됐다. 문제는 컴파일 에러가 나는 부분인데 config.js 파일의 내용을 주입시킬 수 있는 방법이 없다. TypeScript 1.8에서 도입된 AMD-dependency 구문을 통해 해결 할 수 있게 됐다. 일단 구문을 모자 1/// &lt;amd-dependency path=\"lib/jquery\" /&gt; 위 주석(?)을 파일 윗줄에 삽입함으로서 의존성을 삽입가능한데 일단 import 구문을 통했을 때와 차이를 알아야한다. 다시 컴파일을 하면 일단 $에 대한 오류가 당연히 발생하게 된다. main.ts(3,1): error TS2304: Cannot find name ‘$’. 123456define([\"require\", \"exports\", \"lib/jquery\"], function (require, exports) &#123; \"use strict\"; $(function () &#123; console.log(\"document ready\"); &#125;);&#125;); 에러와 함께 컴파일된 js파일이다. 모듈은 로딩 되었는데 참조가 불가능하다. 이에 대한 문제를 해결 할 수 이도록 name 프로퍼티가 1.8에 들어가게 되었다. 12/// &lt;amd-dependency path=\"lib/jquery\" name=\"$\"/&gt;declare var $; name에 $를 지정해주고 실제 코드에서 사용할 수 있도록 declare var $; 구문을 주석 아래쪽에 삽입하여 TS2304 에러코드를 해결한다. 123456define([\"require\", \"exports\", \"lib/jquery\"], function (require, exports, $) &#123; \"use strict\"; $(function () &#123; console.log(\"document ready\"); &#125;);&#125;); 의존성과 컴파일 에러 모드 해결되었다. search-response.ts(2,15): error TS2307: Cannot find module &#39;lodash&#39;. 1import _ from 'lodash'; es6 방식의 export가 지원 되지 않아 생기는 에러로 보인다. 1import * as _ from &apos;lodash&apos; 위와 같이 해결한다.","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"ts","slug":"dev/ts","permalink":"http://blog.bglee.me/categories/dev/ts/"}],"tags":[{"name":"requirejs","slug":"requirejs","permalink":"http://blog.bglee.me/tags/requirejs/"},{"name":"typescript","slug":"typescript","permalink":"http://blog.bglee.me/tags/typescript/"},{"name":"amd","slug":"amd","permalink":"http://blog.bglee.me/tags/amd/"},{"name":"amd-dependency","slug":"amd-dependency","permalink":"http://blog.bglee.me/tags/amd-dependency/"}]},{"title":"requirejs","slug":"requirejs","date":"2016-04-11T15:00:00.000Z","updated":"2018-03-29T06:03:19.632Z","comments":true,"path":"posts/2016/requirejs/","link":"","permalink":"http://blog.bglee.me/posts/2016/requirejs/","excerpt":"","text":"build.js 123456789(&#123; baseUrl: \".\", paths: &#123; jquery: \"1\", jhary: \"2\" &#125;, include: ['1','2'], out: \"main-built.js\"&#125;) 1r.js -o build.js optimize=none main-built.js 12345678define('1',[], function() &#123; return 1;&#125;);define('2',[], function() &#123; return 2;&#125;);","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"js","slug":"dev/js","permalink":"http://blog.bglee.me/categories/dev/js/"}],"tags":[{"name":"r.js","slug":"r-js","permalink":"http://blog.bglee.me/tags/r-js/"},{"name":"requirejs","slug":"requirejs","permalink":"http://blog.bglee.me/tags/requirejs/"}]},{"title":"프로 AngularJS","slug":"book_pro_angularjs","date":"2016-01-31T15:00:00.000Z","updated":"2018-03-29T06:03:19.624Z","comments":true,"path":"posts/2016/book_pro_angularjs/","link":"","permalink":"http://blog.bglee.me/posts/2016/book_pro_angularjs/","excerpt":"","text":"이 문서는 AngluarJS를 빠르게 읽히기 위해 예제코드를 눈으로만 읽으며 정리한 개인 노트다. 환경 셋업 서버 Chapter 7: 스포츠 상점: 내비게이션 및 결제 directive filter Provider Chatper 8: 스포츠 상점: 주문 및 관리자 기능 directive 폼 유효성 AngularJS 활용 Chapter 9: AngularJS 앱 해부 팩터리 함수와 작업자 함수 컴포넌트 별 작업자 함수 인자 서비스 값 정의 모듈의 의존성 config, run 메서드 Module.config 메서드 Module.run 메서드 상수 정의 Chapter 10: 바인딩 및 템플릿 디렉티브 활용 디렉티브 적용 방법 데이터 바인딩 디렉티브 템플릿 디렉티브 Chapter 11: 엘리먼트 및 이벤트 디렉티브 활용 엘리먼트 디렉티브 이벤트 디렉티브 내장변수 불리언 어트리뷰트 디렉티브 기타 어트리뷰트 Chapter 12: 폼 활용 Chapter 13: 컨트롤러 및 스코프 활용 스코프리스 컨트롤러 명시적 스코프 업데이트 Chapter 14: 필터 활용 단일 값 내장 필터 컬렉션 필터링 항목 정렬 필터 체인 커스텀 필터 구현 Chapter 15: 커스텀 디렉티브 구현 표현식 평가 데이터 변화 처리 jqLite 활용 jqLite -&gt; jQuery Chapter 16: 고급 디렉티브 구현 디렉티브 스코프 관리 Chapter 17: 고급 디렉티브 기능 트랜스클루전 활용 컴파일 함수 활용 디렉티브 내 컨트롤러 활용 기타 디렉티브 추가 Chapter 18: 모듈 및 서비스 활용 서비스 생성 AngularJS 내장 서비스 Chapter 19: 전역 객체, 에러, 표현식을 위한 서비스 DOM API 전역 객체 접근 HTML5 URL 활용 위험한 데이터 처리 AngularJS 표현식 및 디렉티브 활용 Chapter 20: Ajax 서비스 및 프로미스 Ajax 요청 설정 Ajax 기본값 설정 Ajax 인터셉터 활용 프로미스의 활용 Chapter 21: REST 서비스 $http 서비스의 활용 Ajax 요청 숨기기 데이터 객체 수정 새 객체 생성 $resource 서비스 행동 설정 resource 활용에 적합한 컴포넌트 구현 비동기적 데이터 함정 피하기 Chapter 22: 뷰를 위한 서비스 ngRoute 라우트 및 라우트 파라미터 접근 라우트 설정 Chapter 23: 애니메이션 및 터치를 위한 서비스 ngAnimation모듈 설치 애니메이션의 정의 및 적용 병렬적 애니메이션의 위험성 터치 이벤트 지원 Chapter 24: 프로비전 및 주입을 위한 서비스 AngularJS 컴포넌트 등록 주입 관리 Chapter 25: 단위 테스트 source code 환경 셋업서버deployd를 사용한다. 12$ dpd create sportsStore$ dpd -p 5500 sportsstore\\app.dpd dashborad Chapter 7: 스포츠 상점: 내비게이션 및 결제directive ng-show ng-hide ng-include[src] ng-view filter orderBy unique Provider routeProvider: ngRoute ng-view에 들어가게되는 라우팅 테이블을 관리 프로바이더 명명법은 서비스명 + Provider Chatper 8: 스포츠 상점: 주문 및 관리자 기능directive ng-model form[novalidate]: 브라우저의 검증 기능을 사용하지 않는다. input[required]: 값이 있어야한다 button[ng-disabled] ng-class=”{‘classname’: item === true }” ng-repaet $index 폼 유효성1234&lt;form name='myForm'&gt; &lt;input ng-model='object.model' require /&gt;myForm.$invalidobject.model.$error 2016-01-16 추가 AngularJS 활용Chapter 9: AngularJS 앱 해부팩터리 함수와 작업자 함수컴포넌트를 설정하고 싶을 때 팩터리 함수를 호출하고, 컴포넌트를 적용하는 시점에 작업자 함수가 호출된다. 123app.directive(\"directiveName\", function 팩터리함수() &#123; return function 작업자함수(scope, element, attrs) &#123;&#125;;&#125;); 컴포넌트 별 작업자 함수 인자123456// directivereturn function(scope, element, attrs) &#123;&#125;;// filterreturn function(input) &#123; return 'modified input data';&#125;; 정의된 필터도 팩터리 함수에서 $filter 를 인젝션하여 사용할 수 있다. 서비스 서비스는 싱글턴 이다. 서비스를 정의 하는 방법에는 세 가지 메서드가 존재한다. service factory provider 값 정의 상수 정의를 위해 constant가 사용되는데 아직은 차이를 모른다. 오버 스펙느낌인듯… Module.value(‘valueName’, ‘value’) 를 통해 정의된다. 모듈의 의존성1angular.module('testApp', ['testApp.filter', 'testApp.directive']); 위와 같이 testApp 모듈을 정의 하고 의존성으로 ‘testApp.filter’, ‘testApp.directive’ 모듈을 선언하게 되면 ‘testApp.filter’, ‘testApp.directive’ 모듈간 상호 참조가 가능하게 되는 것으로 보인다.(서로간의 정의에서 의존성 주입이 가능하다는 말) 모듈의 의존성을 선언하게 되면 config, run 메서드Module.config 메서드현재 모듈이 로드 될 대 호출된다. Module.run 메서드모든 모듈이 로드될 때 해출된다. 말이 애매한데 run은 모든 의존성이 해결된 뒤에 호출되는 것으로 보인다. 타 모듈에 대한 의존성 주입이 해결된 후에 호출되며 config는 그 이전에 호출되는 차이가 있는 것으로 보인다. 상수 정의1Module.constant('name', 'value'); 값 정의와는 달리 Module.config에서 주입이 가능하다. Chapter 10: 바인딩 및 템플릿 디렉티브 활용디렉티브 적용 방법1234//어트리뷰트&lt;span ng-bind=\"todos.length\"&gt;&lt;/span&gt;//클래스&lt;span class=\"ng-bind: todos.length\"&gt;&lt;/span&gt; 데이터 바인딩 디렉티브 ng-bind ng-bind-html ng-bind-template ng-model ng-non-bindable 템플릿 디렉티브 ng-clock ng-include ng-repeat ng-repeat-start ng-repeat-end ng-switch ng-repeat {{ item in array }}, {{ (key, value) in object }} 등의 방식으로 쓰일 수 있으며 내장변수는 아래와 같다. $index $first $middle last $even $odd ng-repeat-start 엘리먼트 하나를 기준으로 반복하는 것이 아니라 여러 형제 엘리먼트(Sibling)가 있어 이를 함께 반복해야 하는 경우라면 사용한다.ng-repeat-end 를 만날때까지 반복된다. ng-include 외부 파일을 로드 할 수 있게 한다. 몇 가지 어트리뷰트를 설정해서 사용한다. src onload autoscroll ng-switch 컨텐츠를 상황에 따라 전환할 때 사용한다. on 어트리뷰트를 통해 변수를 설정하고(object타입만 가능 할 수 있다.) 1234&lt;ng-switch on='object.data'&gt;&lt;div ng-switch-when='value1'&gt;&lt;/div&gt;&lt;div ng-switch-when='value2'&gt;&lt;/div&gt;&lt;div ng-switch-default&gt;&lt;/div&gt; 를 통해 변수값이 when과 맞으면 그 뷰를 보여주도록 설정한다. ng-clock 앵귤라가 처리하는 동안 인라인 템플릿이 그대로 노출되는 시간이 아주 짧게 존재하는데 이 시간동안 css를 통해 보이지 않도록 처리해주는 어트리뷰트형 디렉티브다. 2016-01-20 추가 Chapter 11: 엘리먼트 및 이벤트 디렉티브 활용엘리먼트 디렉티브 ng-if ng-class ng-class-even ng-class-odd ng-hide ng-show ng-style ng-if ng-hide와는 다르게 실제로 DOM에서 엘리먼트를 제거한다.ng-repeat과 함께 사용할 수 없다 이벤트 디렉티브 ng-blur ng-change ng-click ng-copy ng-cut ng-paste ng-dblclick ng-focus ng-keydown ng-keyup ng-mousedown ng-mouseenter ng-mouseleave ng-mousemove ng-mouseover ng-mouseup ng-submit 내장변수 $event 불리언 어트리뷰트 디렉티브 ng-checked ng-disabled ng-open ng-readonly ng-selected 기타 어트리뷰트 ng-href ng-src ng-srcset 2016-01-21 추가 Chapter 12: 폼 활용 form tag from 태그는 유효성 검증을 필요로 요구된다. 어트리뷰트 novalidate ng-submit 유효성 검증 변수 $pristine $dirty $valid $invalid $error 유효성 검증 변수는 form 엘리먼트에 지정한 name 어트리뷰트의 값을 통해 접근이 가능하다상호작용 태그에 클래스가 자동으로 적용된다. 클래스 명 ng-pristine ng-dirty ng-valid ng-invalid ng-invalid-email 과 같은 클래스 언급이 있는데 이 부분도 확인해봐야한다. input type에 매핑되는 어트리뷰트 값 checkbox email number radio text url AngularJS에서 제공되는 어트리뷰트 디렉티브(input, textarea) ng-model ng-change ng-minlength ng-maxlength ng-pattern ng-required input 엘리먼트의 타입이 email, number, url일 경우 내부적으로 ng-pattern이 적용되므로 이 둘은 함께 사용하지 말아야한다. type이 checkbox 인 경우 사용가능한 어트리뷰터 디렉티브 ng-model ng-change ng-true-value ng-false-value ng-true-value와 ng-false-value는 체크 박스의 선택에 따라 ng-model에 들어갈 값을 결정한다. select ng-options ng-options=”‘item.action for item in items’” 와 같은 형태로 사용되며 item.action 부분이 라벨이 된다.ng-options=”‘item.id as item.action for item in items’” 와 같은 형태로 사용하면 item.id 부분이 라벨이 된다.ng-options=”‘item.action group by item.place for item in items’” 와 같은 형태로 사용하면 item.place로 그룹 정렬이 된다.as 와 group by 는 병행이 가능하다. Chapter 13: 컨트롤러 및 스코프 활용 ng-controller 디렉티브를 통해 지정되며 123Module.controller('controllerName', function($scope) &#123; $scope.fx = function() &#123; alert(); &#125;;&#125;); 와 같이 사용된다. $scope 아래로 달리는 함수는 뷰(DOM)에서 디렉티브를 통해 호출이 가능하다. ng-controller 디렉티브에이 의해서 컨트롤의 팩터리함수가 호출되고 인스턴스화된다. 컨트롤러에서 사용되는 내장 서비스 $rootScropt $scope $scope 구현상 $scope는 서비스는 아니며 $rootScope에서 제공하는 하나의 객체다 $rootScope 내장 서비스로 $scope 들과 연결되어 있어 $scope 간에 통신을 가능하게 한다. 이벤트 메서드 $broadcast(name, args) $emit(name, args) $on(name, handler) $broadcast는 아래로 $emit은 위로 이벤트를 전달하며 $on은 받는 역할을 한다. controller는 돔 구조와 동일하게 부무, 자식 관계가 정립되며 이 순수에 의해 그대로 상속되며 오버라이딩이 가능하다. 스코프리스 컨트롤러123Module.controller('scopelessCtrl', function() &#123; this.fx = function() &#123; alert(); &#125;;&#125;); 1&lt;div ng-controller=\"scopelessCtrl as ctrl\"&gt; 명시적 스코프 업데이트 $apply(expression) $watch(expression, handler) $watCollection(object, handler) AngularJS 외부에서의 업데이트를 통해 스코프가 업데이트 되지 않을 경우 명시적으로 업데이트 할 수 있다. 1angluar.element('#selector').scope().$apply('variableInScope()'); Chapter 14: 필터 활용필터는 데이터가 뷰에 표시되기전에 거치게 된며 파이프를 사용해 다중으로 적용 가능하다. 단일 값 내장 필터 currency date json number uppercase lowercase currency 123456789&#123;% raw %&#125;&#123;&#123; value | currency &#125;&#125;&#123;&#123; value | currency:\"£\" | number:0 &#125;&#125;&#123;&#123; value | date:\"dd MMM yy\" &#125;&#125;&#123;&#123; value | date:\"shortDate\" &#125;&#125;&#123;&#123; value | uppercase &#125;&#125;&#123;&#123; value | lowercase &#125;&#125;&#123;&#123; object | json &#125;&#125;&#123;% endraw %&#125; 컬렉션 필터링 limitTo 음수를 지정할수도 잇는데 이 경우에는 뒤부터 정렬된다. 1&lt;div ng-repeat=\"p in products | limitTo:'5'\"&gt; filter filter가 필터명이다. 오프젝트에서 키 밸류가 일치하는 값으로 필터링한다. 123$scope.filterFunction = function(item) &#123; return item.category === 'Fish';&#125; 12&lt;div ng-repeat=\"p in products | filter: &#123; key: 'value' &#125;\"&gt;&lt;div ng-repeat=\"p in products | filter: filterFunction\"&gt; 항목 정렬 orderBy 123$scope.myCustomSorter = function(item) &#123; return item.expiry &lt; 5 ? 0 : item.price;&#125; 1234&lt;div ng-repeat=\"p in products | orderBy:'price' &#125;\"&gt;&lt;div ng-repeat=\"p in products | orderBy:'-price' &#125;\"&gt;&lt;div ng-repeat=\"p in products | orderBy:myCustomSorter &#125;\"&gt;&lt;div ng-repeat=\"p in products | orderBy:[myCustomSorter, '-price'] &#125;\"&gt; 정렬값이 같을 경우 배열을 이용해 두번째 소트옵션을 활용해 정렬할 수 있다. 필터 체인파이프를 이용해 순차적, 연속적으로 필터를 적용한다. 1&lt;div ng-repeat=\"p in products | orderBy:[myCustomSorter, '-price'] | limitTo: 5 &#125;\"&gt; 커스텀 필터 구현첫번째 인자는 이름 두번째 인자는 팩터리함수로 작업자 함수를 리턴한다. 12345Module.filter('filterName', function() &#123; return function(input, argument) &#123; return 'output'; &#125;;&#125;); 필터를 정의하면서 기존의 필터를 가져와 사용이 가능하다. 123456Module.filter('filterName2', function($filter) &#123; return function(input, argument) &#123; var firstFilter = $filter('filterName')(input, argument); return $filter(\"limitTo\")(firstFilter, 2); &#125;;&#125;); 2016-01-22 추가 Chapter 15: 커스텀 디렉티브 구현Module.directive를 통해서 선언 가능하며 카멜 케이스로 선언하고 DOM에서 사용할 때는 - 로 구분하고 소문자로 쓰게 된다.디렉티브의 링크 함수중 element인자는 jqLite 객체다. 12345Module.directive('directiveName', function() &#123; return function(scope, element, attrs) &#123; var value = attrs['directiveName']; // 'test' &#125;;&#125;) 12&lt;div directive-name='test'&gt;&lt;/div&gt;&lt;div data-directive-name='test'&gt;&lt;/div&gt; 표현식 평가디렉티브의 사용 유저가 필터등을 사용할때는 디렉티브내에서 표현식을 평가해야한다. 1&lt;div directive-name='price | currency'&gt;&lt;/div&gt; 12345Module.directive('directiveName', function() &#123; return function(scope, element, attrs) &#123; var expression = scope.$eval(attrs['directiveName']); &#125;;&#125;) 데이터 변화 처리링크 함수 내에서 와처류의 함수를 통해 변화를 업데이트하도록 한다. jqLite 활용jQuery와 유사하니 대부분 패스하고 이벤트 처리등 몇가지 메서드만 정리한다. on(events, handler) off(events, handler) triggerHandler(event) data(key, value) data(key) removeData(key) jqLite를 통한 AngularJS 기능 접근 controller() controller(name) injector() isolatedScope() scope() inheritedData(key) jqLite -&gt; jQueryjqLite로 불편하면 angularjs 파일 로딩 전 jQuery를 로딩하면 대체됨. 2016-01-23 추가 Chapter 16: 고급 디렉티브 구현커스텀 디렉티브를 커스터마이징하기 위해 팩터리 함수(링크 함수)를 반환하는 대신 정의 객체를 반환해야한다. 링크 함수를 반환할 경우는 어튜리뷰트 방식의 적용만 가능한 디렉티브가 된다. 정의 객체 속성 comiple controller link replace require restrict scope template templateUrl transclude restrict 123return &#123; restrict: \"EACM\"&#125; E: 엘리먼트 형태의 적용 A: 어트리뷰트 형태의 적용 C: 클래스 형태의 적용 M: 주석 형태의 적용 1234&lt;unordered-list list-source=\"products\" list-property=\"price | currency\" /&gt;&lt;div unordered-list=\"products\" list-property=\"price | currency\" /&gt;&lt;div class=\"unordered-list: products, price | currency\" /&gt;&lt;!-* directive: unordered-list products --&gt; CM은 거의 사용되지 않는다. M의 경우 링크 함수에서 nodeName이 ‘#comment’인 것을 찾아 부모 엘리먼트에 생성하고자 하는 엘리먼트를 붙이는 방식으로 진행된다. template 링크에서 엘리먼트를 생성하지 않고 template 프로퍼티에 엘리먼트의 innerHTML 에 대입하는 것과 마찬가지로 HTML코드를 대입할 수 있고 함수를 지정할 수도 있다. 1234567891011&#123;% raw %&#125;return &#123; template: \"&lt;ul&gt;&lt;li ng-repeat='item in data'&gt;&#123;&#123;item.price&#125;&#125;&lt;/ul&gt;\"&#125;// orreturn &#123; template: function() &#123; return angular.element(document.querySelector(\"#listTemplate\")).html(); &#125;&#125;&#123;% endraw %&#125; templateUrl 123456789return &#123; templateUrl: \"itemTemplate.html\"&#125;// orreturn &#123; templateUrl: function(elem, attrs) &#123; return attrs[\"template\"] == \"table\" ? \"a.html\" : \"b.html\"; &#125;&#125; 일전에 책을 15, 16, 17장(커스텀 디렉티브 관련)만 읽고 https://github.com/deptno/autocomplete_hangul 를 연습삼아 만들어봤는데 templateUrl을 사용하게 되면 배포시에는 경로가 index.html(메인 파일)을 기준으로 정렬되면서 링크가 깨지고 만다. 빌드 툴 등을 이용해서 template 로 최종 배포시에는 넣는 것이 맞아보인다. replace 123return &#123; replace: true&#125; 생성되는 html은 아래와 같이 달라진다. 123456// replace undefined&lt;div user-directive&gt; &lt;table&gt;&lt;/table&gt;&lt;/div&gt;// replace true&lt;table user-directive&gt;&lt;/table&gt; ng-repeat등과 유용하게 쓸 수 있다고 책은 기술하고있다. 디렉티브 스코프 관리기본적으로 상위 컨트롤러의 스코프를 상속한다. 디렉티브 스코프 생성 123return &#123; scope: true&#125; 123&lt;div ng-controller='userCtrl'&gt; &lt;div user-directive&gt;&lt;/div&gt;&lt;/div&gt; 위와 같은 경우의 스코프는 디렉티브 스코프 &lt; 컨트롤러 스코프 &lt; 루트 스코프 순이 된다. 고립 스코프 생성 1234567return &#123; scope: &#123; local: \"@onewaybinding\", local2: \"=twowaybinding\", localFn: \"&amp;userFunction\" &#125;&#125; 12345&#123;% raw %&#125;&lt;div user-directive onewaybinding=\"&#123;&#123;data.name&#125;&#125;\" twowaybinding=\"data.other\" userFunction=\"functionNameInScope(userArgument)\"&gt; &#123;&#123; localFn(&#123; userArgument: local &#125;) &#125;&#125;&lt;/div&gt;&#123;% endraw %&#125; @ 단방향, = 양방향, &amp; 함수바인딩을 제공하는데 &amp;가 살짝 애매하다 실제 사용할때는 레퍼런스를 찾아봐야할 듯하다. Chapter 17: 고급 디렉티브 기능트랜스클루전 활용트랜스클루전이라는 용어는 참조를 통해 문서 영역의 일부를 다른 문서에 삽입하는 것이라고 되어있다.책을 읽어보면 대단히 특이한 기능으로 보이는데 디렉티브를 선언한 엘리먼트가 디렉티브로 교체되고 디렉티브 내의 ng-transclude 디렉티브가 디렉티브를 선언했던 디렉티브로 교체된다. 123456789101112131415&#123;% raw %&#125;&lt;script type=\"text/ng-template\" id=\"template\"&gt; &lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;This is the panel&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\" ng-transclude&gt;&lt;/div&gt; &lt;/div&gt;&lt;/script&gt;...&lt;body ng-controller=\"upperCtrl\"&gt;&lt;div user-directive&gt; &#123;&#123;forScopeTest&#125;&#125;&lt;/div&gt;&#123;% endraw %&#125; 디렉티브에서 template를 통해 참조할 돔트리를 작성하고 transclude를 확인할 user-directive 를 선언해다. 1234567891011121314Module.directive('userDirective', function() &#123; return &#123; template: function() &#123; return document.querySelector(\"#template\").html(); &#125;, link: function(scope) &#123; scope.forScopeTest = 'directive'; &#125;, scope: true, restrict: \"E\", transclude: true, //transclude: element &#125;&#125;) js파일에서는 디렉티브를 정의한다. 123456789101112&#123;% raw %&#125;...&lt;body ng-controller='upperCtrl'&gt;&lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;This is the panel&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &#123;&#123;forScopeTest&#125;&#125; &lt;/div&gt;&lt;/div&gt;&#123;% endraw %&#125; 책을 읽고 이해한 바로는 위와 같은 형태의 기능을 트렌스클루젼이라 한다. forScopeTest라는 인라인 바잉딩 표현식이 있는데 디렉티브 선언시에 scope를 true로하여 디렉티브 스코프를 생성한 경우에도 forScopeTest 데이터는 upperCtrl에서 가져오게 된다. false로 한 경우에는 forScopeTest 표현식에서 ‘directive’가 들어가 있는 것을 확인할 수 있다. 정리하면 transclude가 true인 디렉티브 를 선언한 엘리먼트의 컨트롤러 스코프 데이터만을 사용한다는 것이다. 이것은 transclude를 사용하지 않았을 경우와 동일하며 디렉티브 스코프를 false로 한경우 디렉티브의 링크 함수는 컨트롤러의 스코프를 가져오게되므로 표현식에 영향을 미칠 수 있게 된다. transclude를 true로 하면 엘리먼트의 컨텐츠만 감싸게 되는데 이를 element 로 하게되면 엘리먼트 자체를 감싸게 된다. 컴파일 함수 활용책을쓴 저자는 개인적으로 컴파일 함수를 사용하는 것을 선호하지 않는다고 밝히고 있다. 컴파일 함수를 정의하게 되면 링크함수의 정의는 무시되고 컴파일 함수가 리턴하는 함수가 링크 함수로 대체된다. 123456789101112Module.directive('userDirective', function() &#123; return &#123; compile: function(element, attrs, transcludeFn) &#123; return function($scope, $element, $attrs) &#123; var parent = $element.parent(); transcludeFn($scope.$new(), function(clone) &#123; parent.append(clone); &#125;); &#125; &#125; &#125;&#125;) compile에는 3번째 함수로 transclude에 사용되는 함수가 오게되는데 책의 내용만으로는 이해가 어렵다. 책에서는 디렉티브 선언에 template가 빠져있다. 첫번째인자는 스코프, 두번째 인자는 트랜스클루젼이 적용된 돔이 오게 될 것 같은데 정보가 온전치 않다. 디렉티브 내 컨트롤러 활용12345678910111213141516171819Module .directive('userDirective', function() &#123; return &#123; transclude: true, controller: function($scope, $element, $attrs) &#123; this.updateTotal = function() &#123; $scope.total = 1; &#125;; &#125; &#125; &#125;) .directive('userDirective2', function() &#123; return &#123; require: \"^userDirective\", link: function(scope, element, attrs, ctrl) &#123; ctrl.updateTotal(); &#125; &#125; &#125;) 디렉티브에 컨트롤러를 정의할 수 있다. require 속성에서 디렉티브 의존성을 선언하게 되며 의존성 앞에 접두어를 사용할 수 있다. 접두어가 없는 경우 두 디렉티브가 같은 엘리먼트에 적용된다고 가정한다. ^: 디렉티브가 적용된 엘리먼트의 부모 일레먼트에서 다른 디렉티브를 찾는다. ?: 디렉티브를 찾을 수 없더라도 에러를 보고하지 않는다(사용에 주의를 요한다). link함수에서의 ctrl 인자는 의존성 인자가 아니므로 다른 이름을 사용해도 상관없다.컨트롤러 함수에서 넘겨받는 $scope 인자는 컨트롤러를 정의하는 디렉티브의 스코프인데 이 부분은 실제 적용을 하면서 확인을 해봐야할 듯 하다. 기타 디렉티브 추가requrie 속성을 통해 종속성을 선언할때 기존 내부 디렉티브를 지정할 수도 있다. ngModel 기본 메서드 및 속성 $render(): 데이터 바인딩 값이 변할때 UI를 업데이트하기 위해 호출된다. $setViewValue(value): 데이터 바인딩 값을 업데이트한다. $viewValue: 디렉티브를 통해 표시할 포매팅 된 값. $modelValue: 스코프로 부터 포매팅되지 않은 값. $formatters: $modelValue를 $viewValue로 포매팅하는 포매터 함수 배열. ngModel 컨트롤러 에서 제공하는 유효성 검증 메서드 및 속성 $setPristine(): 컨트롤러의 유효성 검증 상태를 초기로 되돌려 유효성 검증 수행이 되지 않게 한다. $isEmpty(): 컨트롤에 값이 없을때 이를 알리기 위해 디렉티브에서 설정할 수 있다. $parsers: 모델 값의 유효성을 검증하는데 사용할 함수 배열 $error: 유효성 검증 에러에 대응되는 속성을 지닌 객체를 반환한다. $pristine: 사용자가 컨트롤을 수정하지 않은 경우 true $dirty: 사용자가 컨트롤을 수정한 경우 true $valid: 모델이 유효한 경우 true $invalid: 모델이 유효하지 않은 경우 true 12345678910111213141516Module.directive(\"triButton\", function() &#123; return &#123; replace: true, require: \"ngModel\", template: \"tags in here\", link: function(scope, element, attrs, ctrl) &#123; var validateParser = function(value) &#123; var valid = (value == \"Yes\" || value == \"no\"); ctrl.$setValidity(\"confidence\", valid); return valid ? value : undefined; &#125; ctrl.$parsers.push(validateParser); &#125; &#125;&#125;) 123&lt;form name=\"myForm\" novalidate&gt; &lt;div&gt;&lt;tri-button name=\"decision\" ng-model=\"dataValue\"/&gt;&lt;/div&gt;&lt;/form&gt; 전반적으로 내용이 어렵고 실제로 해보기전에는 파악이 어렵다. 모듈을 생산할 때는 필수적인 내용이니 만큼 실제 코딩을 할 때는 한번 더 정독이 필요하다. 2016-01-24 추가 Chapter 18: 모듈 및 서비스 활용서비스는 횡단 관심사(cross-cutting concerns)를 구현하는데 쓰인다라는 SW공학책에서나 쓰일 것 같은 이해도 한번에 안가면서 모호해 보이는 언어를 사용하는데 결국 모델이나 뷰에 비종속적인 어느 곳에서나 쓰일 수 있는 프로세스의 집합체(작게는 함수)를 말하는 것으로 보인다. 서비스 생성서비스를 생성하는 방법에는 세 가지가 존재한다. 방법에 상관없이 리턴된 서비스 객체는 싱글턴으로 하나의 인스턴스가 유지된다. factory service provider factory 팩터리 함수를 통해 싱글턴 객체를 리턴하는 구조로 팩터리 함수는 최초한번 실행후 리턴된 객체를 사용한다. 12345678Module.factory('serviceName', function() &#123; var privateVariable = 10; return &#123; api01: function() &#123; return privateVariable; &#125; &#125;&#125;) service 책에서는 new 키워드가 일반적으로 쓰이지 않는다고 설명하고 있지만 타입스크립트 와 같은 상위 셋의 언어를 사용하거나 ES6의 추세를 봤을 땐 언어 자체가 클래스 기반으로 움직이고 있기 때문에 상속이 가능한 구조로서 활용도가 매우 높을 것으로 생각하고 있다. 팩터리 함수위치에 있는 함수를 new 키워드로 생성하여 사용하게 된다. 123456Module.service('serviceName', function() &#123; var privateVariable = 10; this.api01 = function() &#123; return privateVariable; &#125;&#125;) provider 프로바이더는 조금 특이한데 리턴된 객체의 $get 속성을 팩터리함수로 이용하여 객체를 반환한다. 이 반환하는 객체가 factory방식인지 service방식인지는 조금 더 공부를 해봐야 알겠으나 책의 예제 상으로는 factory방식으로 보이며 이런 경우라면 prototype 상속을 통한 구조화를 할 수 없으므로 활용폭이 제한되거나 팩터리 함수에서 객체를 생성해서 리턴하는 방식을 통해 가능할 것으로 생각된다. 그럼에도 불구하고 Module.config 메서드를 통해 설정을 지원하므로 유용해 보인다. 1234567891011121314151617181920212223242526Module.provider('serviceName', function() &#123; var debug = false; return &#123; setDebugMode: function(set) &#123; if (set) &#123; debug = true; &#125; else &#123; debug = false; &#125; &#125; $get: function() &#123; var privateVariable = 10; return &#123; api01: function() &#123; if (debug) &#123; console.log(privateVariable); &#125; return privateVariable; &#125; &#125; &#125; &#125;&#125;).config(function(serviceNameProvider) &#123; serviceNameProvider.setDebugMode(true);&#125;); AngularJS 내장 서비스 $anchorScroll $animate $compile $controller $document $exceptionHandler $filter $http $injector $interpolate $interval $location $log $parser $provide $q $resource $rootElement $rootScope $routeProvider $routeParams $sanitize $sce $swipe $timeout $window 2016-01-26 추가 Chapter 19: 전역 객체, 에러, 표현식을 위한 서비스DOM API 전역 객체 접근 $window $document $interval $timeout $location $log $anchorScroll $window, $document 단순 브라우저 전역객체인 window, document의 jqLite 래핑객체다. $interval, $timeout window.setInterval, window.setTimeout을 접근하게 해주는 API로 AngularJS와의 연동을 위해 추가 기능이 정의되어 있다. $interval, $timeout 서비스와 함께 사용하는 인자 fn: 실행을 지연할 함수 delay: 지연 값 ms count: $interval에서 반복 횟수를 정의 0은 무한반복을 의미하며 기본값이다. invokeApply: true가 기본값이며 fn이 scope.$apply메서드 내에서 실행하게 된다. $location window.location의 래퍼로. 현재 URL에 접근 가능하게 해주며 인덱스 URL(시작 URL)이 픽스되고 뒤의 # 이후를 제어할 수 있다. http://domain.com/index.html#**user/can/control?this=yes#youcan** URL은 경로, 검색어, 해시라는 3개의 구성 요소로 이루어져있다. 경로: http://domain.com/index.html#**user/can/control**?this=yes#youcan 검색어: http://domain.com/index.html#user/can/control?**this=yes**#youcan 해시: http://domain.com/index.html#user/can/control?this=yes#**youcan** $location 서비스에서 제공하는 메서드는 아래와 같다. absUrl(): 전체 URL을 반환한다. hash(target?): 해시를 가져오거나 설정한다 hoset(): 호스트네임 컴포넌트를 반환한다. path(target?): 경로 컴포넌트를 가져오거나 설정한다. port(): 포트번호를 반환한다. protocol(): URL의 프로토컬 컴포넌트를 반환한다. replace(): URL이 바뀔 때 새브라우저 히스토리가 생기는 대신 가장 최신 희스토리 항목을 대체한다. search(term?, params?): 검색어를 가져오거나 설정한다. url(target?): 경로, 쿼리 문자열, 해시를 한꺼번에 가져오거나 설정한다. $location 서비스에서 정의하는 이벤트 $locationChangeStart: URL이 변경되기 전에 호출된다. Event객체에서 preventDefault 메서드를 호출하면 URL 변경을 막을 수 있다. $locationChangeSuccess 123456789101112Module.controller(\"defaultCtrl\", function($scope, $location) &#123; $scope.$on(\"$locationChangeSuccess\", function(event, newUrl) &#123; $scope.url = newUrl; &#125;); $location.path(\"\"); $location.hash(\"\"); $location.search(\"\"); $location.path(\"/cities/london\"); $location.hash(\"north\"); $location.search(\"select\", \"hotels\"); $location.url(\"/cities/london?select=hotels#north\");&#125;); HTML5 URL 활용저자는 위 API들이 브라우저가 새 HTML문서를 로드하지 않게끔 #문자 이후의 URL 컴포넌트 영영을 매번 복제해야하는 것을 우아하지 않다고 지적한다. 이를 위해 HTML5 히스토리 API가 있으며 더 우아한 방식으로 문서를 재로드하지 않고 URL을 변경할 수 있게 해준다고 기술하고 있다. 주요 브라우저의 최신 버전에서 는 모두 이 같은 히스토리 API를 지원하며, AngularJS에서 이 기능을 활용하려면 $location 서비스의 프로바이더인 $locationProvider를 통해 지원 기능을 활성화하면 된다. HTML5 모드를 활성 화 하고 위 코드를 다시 실행시켰을때 URL이 더 깔끔하게 변한다고 기술하고 있으나 책이 잘못된 것인지 차이를 알 수 없게 기술되어 있어 실제로 테스트가 필요하다. 12345Module.config(function($locationProvider) &#123; if (window.history &amp;&amp; history.pushState) &#123; $locationProvider.html5Mode(true); &#125;&#125;); 위 코드에서 $window 서비스를 주입하지 않는 이유는 config 함수로는 상수 값이나 프로바이더만이 주입될 수 있기 때문이다. $anchorScroll 이 서비스는 $location.hash 메서드에서 반환한 값과 id가 일치하는 엘리먼트가 보이게끔 브라우저 창의 스크롤을 조정해준다. 사용 방법이 독특한데 $anchorScroll 서비스는 서비스 객체를 참조할 필요가 없으며 단지 의존성만을 선언하면 된다. 서비스 객체가 생성되면(의존성 선언을 통해) $location.hash 값의 모니터링을 시작하고, 값이 변할 때 자동으로 스크롤을 조정한다. 12345Module.controller(\"defaultCtrl\", function($scope, $location, $anchorScroll) &#123; $scope.scrollToTop = function() &#123; $location.hash('top'); &#125;;&#125;); 12345...&lt;body&gt; &lt;p id='top'&gt;This is the top&lt;/p&gt; &lt;button ng-click='scrollToTop()'&gt;Go&lt;/button&gt;&lt;/body&gt; 클릭을 하면서 호출된 함수에서 $location.hash 함수를 호출하게되고 자동으로 스크롤이 일어나게 된다. 자동 스크롤이 일어나지 않게 하려면 프로바이더를 통해 선언을 하면된다. 12345678910111213Module .config(function($anchorScrollProvider) &#123; $anchorScrollProvider.disableAutoScrolling(); &#125;) .controller(\"defaultCtrl\", function($scope, $location, $anchorScroll) &#123; $scope.scrollToTop = function() &#123; var wantToScroll = true; $location.hash('top'); if (wantToScroll) &#123; $anchorScroll(); &#125; &#125;);&#125;); $log $log는 console객체의 래퍼로 debug, error, info, log, warn 메서드를 정의하고 있다. $log는 기본적으로 debug 메서드가 활성화되지 않으며 컨피그를 통해 활성화 시켜야한다. $exceptionHandler 실행 도중 일어난 에러를 처리한다. 기본 구현체에서는 $log 서비스에 정의 된 error 메서드를 호출하며 이 메서드는 console.error 를 호출하게 된다. $exceptionHandler는 기본적으로 처리되지 않은 예외만을 대상으로한다. 라고 되어있는데 예제가 별로 쓸모 없는 것 같다. 강제로 익섹션을 내는 용도의 예제가 실려있다. 좀 보기 편하게 $exceptionHandler 서비스를 재정의 할 수 도 있으나 주의를 요한다. 정도로만 알고 있으면 될 것으로 보인다. 위험한 데이터 처리해커들이 폼을 통해 악의적인 코드를 주입하는 이를 막기 위한 서비스들이 있다. AngularJS에서는 위험한 문자열이 ng-model, 인라인 바인딩등에서 표현되지 못하도록 자동 이스케이프한다. 위험한 문자열은 태그등을 생각하면된다. $sanitize $sanitize는 AngularJS에서 ngSanitize 모듈을 추가로 받아 로드하여 사용할 수 있으며 모듈 선언에서 ngSanitize를 주입 해야한다. $sanitize 서비스는 HTML 문자열에서 위험한 문자열을 이스케이프된 대체 문자열로 대체하게된다. 아까 자동으로 적용이 된다고 했는데 아래와 같은 차이점이 있다. ng-bind-html 디렉티브등을 이용해서 html을 태그상태로 표현하려고 할때 이스케이핑을 하지 않고 HTML 태그 상태로 보여주되 보여주는 과정에서 script 및 css 엘리먼트, 인라인 자바스크립트 핸들러 및 스타일 어트리뷰트등 문제를 일으킬 만한 요소를 모두 제거한다. ngSanitize 모듈을 인젝션하게되면 ng-bind-html 디렉티브를 사용할때 자동으로 적용되게 된다. 이를 책에서는 위생화 로 표현하고있다. ng-bind-html이 아닌 다른 곳에 표현될 때 이런 위생화가 표현하다고 한다면 컨트롤러에서 $sanitize(targetData) 메서드를 명시적으로 호출할 수 있다. $sce $sce는 명시적으로 데이터를 신뢰할 때 사용하나 저자는 사용할 일이 거의 없을 뿐더러 위험하니 사용하지 않기를 권하고 있다. 이는 HTML태그를 사용할 수 있게 허용한다. 123456789angular .module('itIsModule', ['ngSanitize']) .controller(\"defaultCtrl\", function($scope, $sce) &#123; $scope.htmlData = \"&lt;p&gt;This is &lt;b onmouseover=alert('Attack!')&gt;dangerous&lt;/b&gt; data&lt;/p&gt;\"; $scope.$watch(\"htmlData\", function(newValue) &#123; $scope.trustedData = $sce.trustAsHtml(newValue); &#125;); &#125;);&#125;); 12&lt;p&gt;&lt;input class=\"form-control\" ng-model=\"htmlData\"/&gt;&lt;/p&gt;&lt;p ng-bind-html=\"trustedData\"&gt;&lt;/p&gt; 위 태그의 인라인 이벤트 코드는 명시적으로 신뢰를 선언했으므로 실행된다. 2016-01-27 추가 AngularJS 표현식 및 디렉티브 활용 $parse AngularJS 표현식을 인자로받아 스코프 객체를 사용해 표현식을 평가하는데 사용할 수 있는 함수 로 변환한다. 1234567891011121314151617181920Module .controller(\"defaultCtrl\", function($scope) &#123; $scope.price = \"100.23\"; &#125;) .directive(\"evalExpression\", function($parse) &#123; return function(scope, element, attrs) &#123; scope.$watch(attrs[\"evalExpression\"], function(newValue) &#123; try &#123; var expressionFn = $parse(newValue); var result = expressionFn(scope); if (result == undefined) &#123; result = \"No result\"; &#125; &#125; catch(ex) &#123; result = \"Cannot evaluate expression\"; &#125; element.text(result); &#125;); &#125; &#125;); 12&lt;p&gt;&lt;input class=\"form-control\" ng-model=\"expr\" /&gt;&lt;/p&gt;&lt;div&gt;Result: &lt;span eval-expression=\"expr\"&gt;&lt;/span&gt;&lt;/div&gt; 스코프를 인자로 받는 함수를 받는 것만 눈여겨 보면 활용도가 있을 것으로 보인다. price | currency 라고 input 태그에 입력하게 되면 표현식이 평가되어 span태그에 결과가 나타나게된다. 표현식이 유효하지 않은 경우를 대비해 try-catch 문은 필수적이다.로컬 데이터를 제공할 수 있는데 123456var expressionFn = $parse(\"total | currency\");...var localData = &#123; total: Number(newValue) + (number(newValue) * (number(scope.tax) / 100))&#125;;element.text(expressionFn(scope, localData)); 스코프에 존재하지 않는 total 속성에 대한 참조를 localData에 대입하여 사용했다. $interpolate $interpolate 서비스는 단순히 표현식 자체가 아닌 표현식이 들어 있는 문자열과 연동이 가능해 $parse 보다 더 유연하다. 1234&#123;% raw %&#125;$parse(\"total | currency\");$interpolate(\"The total is &#123;&#123;total | currency&#125;&#125;\");&#123;% endraw %&#125; 이런식의 차이다. 인라인 바인딩을 처리하며 **{{** 같은 문자열을 보간문자라 하는데 이 문자가 다른 프레임워크와의 사용으로 바꿔야할 필요성이 있다면 $interpolateProvider를 통해 해결할 수 있다. * startSymbol(symbol): {{를 대체한다. * endSymbol(symbol): }}를 대체한다. 이 설정은 HTML 마크업을 포함해 AngularJS 영향 영역 전체에 영향을 미치니 주의해야한다. $compile 바인딩 및 표현식이 들어있는 HTML 스트링을 처리해 스코프로부터 콘텐처를 생성할 수 있는 함수를 제공하며 디렉티브를 지원한다는 차별점이 있다. 123456789101112Module .controller(\"defaultCtrl\", function($scope) &#123; $scope.cities = [\"London\", \"Paris\", \"Seoul\"]; &#125;) .directive(\"evalExpression\", function($compile) &#123; return function(scope, element, attrs) &#123; var content = \"&lt;ul&gt;&lt;li ng-repeat='city in cities'&gt;&#123;&#123;city&#125;&#125;&lt;/li&gt;&lt;/ul&gt;\"; var listElem = angular.element(content); var compileFn = $compile(listElem); compileFn(scope); element.append(listElem); &#125;); Chapter 20: Ajax 서비스 및 프로미스 $http get(url, config?) post(url, data, config) delete(url, config) put(url, data, config) head(url, config) jsonp(url, config) W3C에 따르면 get은 안전한 post는 안전하지 않은 상호작용으로 정의되어 있으며 get은 읽기 전용 정보 조회, post는 앱의 상태 변경 작업에 사용해야 한다. 2016-01-30 추가 ajax 통신에 따른 리던값으로는 프로미스 객체를 받게 된다. 프로미스 객체가 정의하는 메서드는 아래와 가다. success(fn) error(fn) then(fn, fn) 기존에 개인적으로 쓰던 프로미스 라이브러에서는 error가 아닌 catch 라는 메서드가 존재했으나 스펙상 어떤 것이 맞는 것인지는 모르겠다. 응답이 JSON형식일 경우 파싱된 상태로 콜백 함수에 전달된다.then 메서드에서는 단순히 success와 error콜백을 함께 등록하는 것 뿐만이 아니라 추가적인 상세 정보에 접근 할 수 잇는 인자가 넘어오는데 정의하고 있는 속성은 아래와 같다. error는 편의상 추가된 것이라고 이 장의 뒷 부분에서 언급하고 있다. data status header config JSON의 경우 AngularJS에서 내부적으로 직렬화 하여 요청을 하고 들어온 데이터를 파싱하여 객체상태로 넘겨주는 등의 역할을 해주지면 나머지는 그대로 들어오게 된다. Ajax 요청 설정$http의 메서드들은 config 인자를 옵션으로 지원하여 다양한 설정이 가능하다. config인자의 속성은 아래와 같다. data header method params timeout transformRequest transformResponse url withCredentials xsrfHeaderNamexsrfCookieName transformRequest, transformResponse 사용자에게 프로미스로 인자로 값이 전달되기 전의 프로미스 콜백함수라고 보면 될 듯 하다. 책에서는 중요한 듯 설명하고 있으나 응답 데이터가 XML일 경우 이를 파싱하여 필요한 정보만 사용자에게 건내는 등의 사전 작업 함수를 등록하는 일 정도다. 뒤에 프로바이더에서 한번 더 설명하므로 여기선 생략한다 $httpProvider Ajax 기본값 설정 defaults.headers.common defaults.headers.post defaults.headers.put defaults.transformResponse defaults.transformRequest interceptors withCredentials 기본 헤더, post 메서드, put 메서드 사용시의 헤더 정의가 있고 transfromRe* 함수는 배열로써 존재하는데 이 곳에서 JSON데이터를 기본으로 파싱하여 자바스크립트 오브젝트를 넘겨주는 것으로 예상된다. 응답시에 리턴되는 프로미스 콜백의 이전 체인 함수라고 생각하고 등록하면서 된다. 배열이니 push를 통해 넣는다. defaults 객체는 $http.defaults를 통해서 접근이 가능하며 기본 값이기 때문에 전역적으로 영향을 준다. Ajax 인터셉터 활용 interceptors 변형 함수(transformRe*)를 정교한 로직으로 대체할 수 있는 기능으로 사용된다. 1234567891011121314.config(function($httpProvider) &#123; $httpProvider.interceptors.push(function() &#123; return &#123; request: function(config) &#123; config.url = \"fix_url.json\" return config; &#125;, response: function(response) &#123; console.log(\"count: \" + response.data.length); return response; &#125; &#125; &#125;);&#125;); 이런식이다 요청을 하게 되면 최종적으로 config 함수에서 url을 바꿔버리니 요청이 “fix_url.json”으로만 가게 될 것이 응답 시에는 로그를 찍을 것이다. 팩터리 함로 특정 속성을 포함하는 객체를 리턴하는 것을 눈여겨보고 이 함수가 변형 함수 이 전에 호출되는지 이 후에 호출되는지를 확인할 필요가 있다. 책에서는 변형함수 이후에 호출 되는 뉘앙스를 풍긴다. 리턴하는 객체에 정의할 수 있는 속성은 아래와 같다. request requestError response responseError 에러는 프로미스의 error 메서드 콜백으로 들어갈 함수를 등록한다고 보면 될 듯 하다. 프로미스의 활용 ##promise에 대한 내용을 공부하고 싶다면 한빛미디어에서 무료로 제공하고 있는 책(JavaScript Promise)이 있으니 이를 참고하면 도움이 될 듯 하다. 프로미스는 스펙이며 여러 구현체가 존재하고 AngularJS에서는 $q 서비스를 통해 프로미스를 제공한다. $q all(promises[]): 프로미스 배열의 모든 프로미스가 리졸브되거나 하나의 에러가 발생할 경우 리졸브된 프로미스가 반환된다. defer(): 지연 객체를 생성한다. reject(reason): 거부된 프로미스를 반환한다. when(value): 항상 리졸브되는 프로미스를 사용해 값을 감싼다(이해불능) defer() 지연객체를 반환하는데 지연 객체에서 정의하는 멤버는 아래오 ㅏ같다. resolve(result) reject(reason) notify(result) promise notify는 처음보는데 지연활동으로 부터 중간 결과를 제공한다고 되어 있다. 프로미스가 정의하는 메서드는 아래오 ㅏ같다. then(success, error, notify) catch(error) finally(fn) 프로미스의 콜백 함수에는 지연 객체가 인자로 들어오게된다. then은 프로미스 객체를 리턴하므로 체인이 가능하다. Chapter 21: REST 서비스 REST(Representational State Transfer)는 API 스타일이다. $http 서비스의 활용$http 서비스를 이용해서 RESTful을 처리하는 장들을 보여주고 로컬 데이터와 서버 데이터간의 동기화를 해야하기 때문에 신경을 많이 써야하며 AngularJS가 추구하는 방식과 대치된다고 말하고 있다. Ajax 요청 숨기기ngResource모듈을 설치해야한다. AngularJS 홈페이지에서 받을 수 있다. $resource 12var baseUrl = 'http://localhost:5500/products/';var 접근객체 = $resource(basUrl + ':id', &#123; id: \"@id\"&#125;); 접근 객체가 지원하는 메서드는 아래와 같다. query() get(id) delete(params, product) remove(params, product) save(product) query() GET. baseUrl 부분을 호출한다. 리턴값은 컬레션이며 비어있다. 쿼리 완료에 따라 내용이 업데이트된다. 컬렉션에 $promise 속성이 존재한다.http://localhost:5500/products get(id) GET.http://localhost:5500/products/id delete, remove(param, product) DELETE.http://localhost:5500/products/id save(product) POST.http://localhost:5500/products/id 데이터 객체 수정query 메서드는 Resource 객체를 사용해 컬렉션을 채운다(컬렉션 개별 요소가 Resource 객체라는 듯). Resource 객체는 서버에서 반환한 데이터에 지정된 송석을 모두 정의하며, 컬렉션 배열을 사용하지 않고도 데이터를 조작할 수 있는 메서드를 정의한다. Resource 객체 $get(): 서버로부터 객체를 가져와 갱신하며, 커밋하지 않은 로컬 변경 사항은 모두 제거된다. $delete(): 서버에서 객체를 삭제한다. $remove(): 서버에서 객체를 삭제한다. $save(): 객체를 서버에 저장한다. 모두 리턴값으로 프로미스 객체를 리턴한다. 주의할 점은 $delete, $remove의 경우 삭제요청을 보내지면 컬렉션 배열에서 스스로 제거될 수 는 없다는 점을 알아야한다. 새 객체 생성사실 코드로 이해가 안가는 부분인데 $scope.productsResource는 $resource 서비스를 통해 반환받은 접근 객체인데 예제 코드는 일단 아래와 같다. 1234567function(product) &#123; new $scope.productsResource(product) .$save() .then(function(newProduct) &#123; $scope.products.push(newProduct); &#125;);&#125; new $scope.productsResource(product) 이 부분이 new에 해당하는 코드인것 같은데 책에서는 접근객체의 메서드 정의에 바로 호출이 가능하다라는 부분이 없는데 일단은 new 키워드와 데이터를 통해 새 Resource 객체 생성이 가능하다고 봐야할 것 같다. $resource 서비스 행동 설정RESTful은 API 스타일이므로 서버에 따라 정의가 다를 수 있다. 그래서 CRUD에 맞춰 요청 방식을 직접 지정할 수 있다. 123$scope.productsResource = $resource(baseUrl + \":id\", &#123; id: \"@id\" &#125;, &#123; create: &#123; method: \"POST\", save: &#123; method: \"PUT\"&#125; &#125;&#125;) Resource 객체의 메서드들($로 시작)을 액션이라 칭하는데 지금 $resource의 3번째 인자를 통해 액션을 정의하고 있다. method: HTTP 방식 결정 params: $resource 서비스 함수의 첫번째 인자로 전달되는 영역 변수 값 지정 url: 이 액션의 기본 URL을 오버라이드. isArray: true일 경우 JSON데이터 배열이 응답으로 온다고 지정한다. 기본값은 false고 요청응답이 단일 객체라고 지정한다. 추가로 transformRequest transformResponse cache timeout withCredentials responseType interceptor 속성을 사용해 액션에서 생성하는 Ajax요청을 설정할 수 있다. 1234567function(product) &#123; new $scope.productsResource(product) .$create() .then(function(newProduct) &#123; $scope.products.push(newProduct); &#125;);&#125; 커스텀 액션인 $create()를 호출하고 있다. resource 활용에 적합한 컴포넌트 구현$resource 서비스에서 제공하는 데이터와 연동할 수 있는 컴포넌트를 작성할 대는 RESTful 지원 기능의 on/off 설정 옵션부터 서버에서 업데이트하는데 필요한 메서드 및 HTTP 방식등을 지정할 수 있게끔 구현해야한다. 비동기적 데이터 함정 피하기한글의 탈을쓴 외계어로 작성된 듯 하다. 이해가 가지 않으나 스코프 와처와 이벤트 핸들러를 사용해 자동으로 클라이언트 뷰와 서버와 동기화 되는 코드를 짜려고할때 조심해야한다고 말하고 있는 듯 하다. 2016-01-31 추가 Chapter 22: 뷰를 위한 서비스ngRouteAngularJS 홈페이지에서 추가로 route파일을 다운로드 받아야한다. ng-view 디렉티브가 이 곳에 정의되어 있는 것으로 보인다. 123456789101112131415161718.config(function($routeProvider, $locationProvider) &#123; $locationProvider.html5Mode(true); $routeProvider.when(\"/list\", &#123; templateUrl: \"/tableView.html\" &#125;); $routeProvider.when(\"/conservative/:id\", &#123; templateUrl: \"/tableView.html\" &#125;); $routeProvider.when(\"/eager/:id/:data*\", &#123; templateUrl: \"/tableView.html\" &#125;); $routeProvider.otherwise(\"/list\", &#123; templateUrl: \"/tableView.html\" &#125;);&#125;)controller(function($location) &#123; $location.path(\"/list\");&#125;); when에서 정의된 URL은 $location.path(URL)을 통해 이동가능하며 코드가 아닌 브라우저에 실제 주소를 입력할 경우에는 요청으로 간주되어 라우터는 동작하지 않는다. ng-view 디렉티브가 선언된 곳에 templateUrl에서 지정한 위치의 파일이 로드되게 된다. 라우트 및 라우트 파라미터 접근12345678910111213.controller(\"ctrl\", function($scope, $http, $resource, $location, $route, $routeParam, baseUrl) &#123; $scope.$on(\"$routeChangeSuccess\", function() &#123; if ($location.path().indexOf(\"/edit/\") == 0) &#123; var id = $routeParams[\"id\"]; for (var i = 0; i &lt; $scope.products.length; i++) &#123; if ($scope.products[i].id == id) &#123; $scope.currentProduct = $scope.products[i]; break; &#125; &#125; &#125; &#125;)&#125;) 라우팅 주소가 /edit/ 으로 시작하는 경우 id 파라미터에 접근하고 있다. $route 메서드 및 속성 current reload() routes 이벤트 $routeChangeStart $routeChangeSuccess $routeUpdate $routeChangeError 라우트 설정 $routeProvider 위의 예제에서는 단순히 templateUrl만 정의했는데 추가적인 설정이 가능하다. controller: 컨트롤러 설정 controllerAs template templateUrl resolve: 의존성 redirectTo reloadOnSearch caseInsensitiveMatch resolve 컨트롤러에 주입할 의존성을 지정할 수 있다. 의존성으로 서비스를 지정할 수도 있지만, resolve속성은 뷰를 초기화하는 데 필요한 작업을 수행하는 데 더 도움이 되며 resolve 속성의 의존성으로 프로미스 객체를 반환할 경우, 라우트에서 의존성이 리졸브되기 전까지 컨트롤러에 인스턴스화하지 않기 때문이다. 말이 어렵게 되어있어 이해 불능이니 한번 더 살펴봐야할 듯하다. 123456789101112131415161718192021.factory(\"productsResource\", function($resource, baseUrl) &#123; return $resource(basUrl + \":id\", &#123; id: \"@id\" &#125;, &#123; create: &#123; method: \"POST\" &#125;, save: &#123; method: \"PUT\" &#125; &#125;);&#125;).config(function($routeProvider) &#123; $routeProvider.otherwise(&#123; templateUrl: \"/tableView.html\", controller: \"tableCtrl\", resolve: &#123; data: function(productsResource) &#123; return productsResource.query(); &#125; &#125; &#125;);&#125;).controller(\"tableCtrl\", function($scope, data) &#123; $scope.data = data;&#125;);resolve 속성에 data 를 정의하고 productsResource 를 주입하고 프로미스를 리턴한다. 프로미스가 리졸브 될 때까지 인스턴스화가 미뤄져서 tableView.html가 늦게 보일 것이라고 말하고 있다. 컨트롤러에서는 정의한 data 속성을 주입하고 있다. 라우트와 연계해 컨트롤러를 사용할 때는 컨트롤러/스코프 상속 규칙이 적용됨을 책은 강조하고 있다. Chapter 23: 애니메이션 및 터치를 위한 서비스ngAnimation모듈 설치AngularJS홈페이지에서 내려받아서 사용하면 된다. css를 통해 애니메이션을 처리한다고 했는데 예제를 봤을 땐 이 파일이 왜 필요한지 이해가 가지 않는다. 애니메이션의 정의 및 적용애니메이션을 지원하는 내장 디렉티브 및 애니메이션과 관련한 이름 ng-repeat: enter, leave, move ng-view: enter, leave ng-include: enter, leave ng-switch: enter, leave ng-if: enter, leave ng-class: add, remove ng-show: add, remove ng-hide: add, remove 병렬적 애니메이션의 위험성ng-view의 경우 새 뷰를 DOM에 추가한 후기존 뷰를 DOM에서 제거한다. 애니메이션 예제가 스스로 css를 통해 애니메이션을 만들고 그 클래스를 직접 입히고 있어 모듈의 왜 필요한지 다른 자료를 참고해야할 듯 하다. 터치 이벤트 지원ngTouch모듈이 필요하며 AngularJS 홈페이지에서 받을 수 있다. ng-click 디렉티브가 터치 환경에서 적합하게 동작할 수 있도록 대체되며 ng-swipe-left, ng-swipe-right 디렉티브를 통해 스와이프가 발생했을 때의 동작을 지정할 수 있다. 2016-02-01 추가 Chapter 24: 프로비전 및 주입을 위한 서비스프로비전이라는 말이 다소 어려운데다가 책에 설명도 없다 사전적인 의미로 검색해보니 제공하다, 규정하다 등이 나오는데 이와 유사한 의미로 이해하고 AngularJS 내부에서 동작하는 함수로 알아두면 될 것 같다. AngularJS 컴포넌트 등록 $provide $provide 서비스는 의존성을 충족할 수 있게끔 서비스 같은 컴포넌트를 주입할 수 있게 등록하는 데 사용된다. 대부분의 경우 $provide 서비스에서 정의하는 메서드는 Module 타입을 통해 외부로 노출되고 접근할 수 있지만 Module에서 제공하지 않는 특수 메서드도 하나 존재한다 $provide 서비스가 정의하는 메서드 value(name, service) constant(name, value) factory(name, service) provider(name, service) service(name, service) decorator(name, service) Module 타입을 통해 외부로 노출되지 않는 메서드는 decorator 메서드다. 123456789.config(function($provide) &#123; $provide.decorator(\"$log\", function($delegate) &#123; $delegate.originalLog = $delegate.log; $delegate.log = function(message) &#123; $delegate.originalLog(\"Decorated: \" + message); &#125;; return $delegate; &#125;);&#125;); decorator는 원본 서비스명을 첫 번째 인자로하며 두번째 콜백에 반드시 $delegate 의존성을 선언하여 원본 서비스의 인스턴스를 받게 된다. 여기서 리턴되는 객체가 원본 객체를 대신하여 의존성을 리졸브 한다고 이해하면 될 듯 하다. 주입 관리 $injector $injector 서비스는 함수에서 선언하는 의존성을 판단하고, 의존성을 리졸브하는 책임을 진다. $injector 서비스가 정의하는 메서드 annotate(fn) get(name) has(name) invoke(fn, self, locals) annotate(fn) 함수 인자를 스트링으로 가져오는 역할을 한다. AngaulrJS의 의존성 주입에 대해 역할을 할 것으로 보이는데 아마도 코드로는 이런식이 아닐까 한다.(AngularJS의 코드를 확인해보지는 않았다.) 12345function annotate(fn) &#123; var str = fn.toString(); var regexp = \"()안으로부터 인자의 이름을 가져와서 ','로 split하여 배열로 리턴하는 RegExp\"; return regexp.exec(str);&#125; get(name) name에 맞는 서비스를 리턴한다. has(name) 인자로 스트링을 넣으면 그 인자가 의존성 객체인지를 리턴한다. invoke(fn, self, locals) fn은 호출하고자 하는 함수가 되고 self 인자는 context(this)가 될 객체다.locals는 객체인데 의존성 인자가 아닌, 즉 $injector.has(name)에 의해 false 리턴된 인자의 이름에 맞는 객체를 속성으로 제공하게 되는 역할을 하게 된다. 123456var logClick = function($log, $exceptionHandler, message) &#123; return false;&#125;$injector.invoke(logClick, null, &#123; message: \"Button Clicked\"&#125;); $rootElement $rootElement는 ng-app 디렉티브를 가진 엘리먼트의 jqLite 객체의 확장이며 $injector 서비스를 반환하는 injector 메서드를 제공한다. 123$rootElement.injector().invoke(logClick, null, &#123; message: \"Button Clicked\"&#125;); 이런식의 접근을 할 이유가 전혀 없지만 이를 통해 AngularJS 내부의 모습을 볼 수 있다. 의존성을 리졸브한다는 난해한 말을 하고 있는데 AngularJS 내부에서 읜존성 주입을 어떻게 처리하는 지를 보여주는 함수라고 생각되며 딱히 쓸일은 없어보인다. Chapter 25: 단위 테스트source codehttp://www.apress.com/9781430264484?gtmf=sZ 이동 후 Source Code/Downloads","categories":[{"name":"summary","slug":"summary","permalink":"http://blog.bglee.me/categories/summary/"}],"tags":[]},{"title":"Jekyll 블로그 운영","slug":"jekyll_setup","date":"2016-01-29T15:00:00.000Z","updated":"2018-03-29T06:03:19.627Z","comments":true,"path":"posts/2016/jekyll_setup/","link":"","permalink":"http://blog.bglee.me/posts/2016/jekyll_setup/","excerpt":"","text":"나는 메모장을 열고 .md 로 저장을 했더니 블로그에 글이 포스팅 되어 있다. 설치install Jekyll1$ gem install jekyll 지킬 인스톨 가이드를 참고하면 되겠다. Forking theme테마를 하나 포킹해야한다. 유료건 무료건 지킬 버전에 맞는 테마를 구글에서 검색해서 포킹한다. “jekyll theme“ 로 구글에서 검색하면 쉽게 얻을 수 있다. 포킹한 후에는 이를 반드시 클론 하여 버전관리를 포함한 시작 뼈대를 갖추도록 한다. configuration테마 루트에 있는 _config.yml 파일을 자신에 맞게 수정한다. operate Jekyll두가지 방법이 있다. 지킬 자체가 웹서버를 런칭하고 스스로 빌드 웹서버는 Apache, Nginx등에 위탁하고 지킬을 통해 빌드만 하는 방법이다. 내 선택 기준은 다음과 같았다. 기타 이미 서비스를 하고 있는 웹 페이지등이 있다면 후자를 이용하고 아무것도 해본적이 없으면 첫번째 방법을 이용하면 된다. 어차피 웹서비스는 80포트를 통해 제공되며 이는 겹쳐선 안되므로 하나만 사용 가능하다. 전자의 방법은 지킬 인스톨 가이드를 참고하면 되겠다.후자는 이미 다른 웹서버가 사용되고 있다는 가정하에 지킬 테마 밑의 제네레이트된 파일 폴더인 _site 폴더를 운영되고 있는 웹 서버에서 서빙할 수 있도록 해주면된다. 이 부분은 각자 웹서버 프로그램의 설정 가이드를 참고해야한다.(그래봤자 아파치 아니면 Nginx다)_site 폴더는 빌드를 통해 업데이트된다. 1$ jekyll build --watch #watch option은 변경된 파일이 생기면 그 파일을 리빌딩한다. 빌드는 위 커맨드를 통해 가능하다. 운영설치가 끝나면 이제 포스팅을 작성해야하는데 하고자 하는 바는 아래와 같았다. 서드파티 댓글 시스템 추가 이미지와 컨텐츠(마크다운 파일) 분리 컨텐츠 버전 관리 테마 버전 관리 서드파티 댓글 시스템 추가(Disqus)디스커스로 정했다. 설치도 너무 쉬워서 가입하고 방식에 맞는 스크립트를 받아(유니버설 스크립트) 포스트에 사용되는 레이아웃 파일을 _layout 폴더에서 찾아 수정해주면 된다. HTML을 조금 이해하고 있으면 도움이 되겠지만 눈치로 잡을 수 있는 수준이다. 이미지와 컨텐츠 분리이런 공수를 따로 들이는 이유는 관리적인 측면에서의 차이 때문이다. 코딩을 하다보면 재사용성을 높이기 위해 모듈화, 캡슐화가 진행되는데 그와 다르지 않다. 컨텐츠를 버전관리할 터인데 이미지를 여기에 함께 관리하는건 바람직하지 않다는 개인적인 의견이다.드롭박스, 원드라이브, 구글 포토등 여러가지 클라우드 저장소가 있는데 여기서는 무제한 용량을 제공하는 구글 포토를 이용했다. 사용하는 방법은 간단하다. 어차피 사진은 폰으로 찍을 것이므로 폰에 구글 포토(안드로이드라면 기본적으로 깔려있을지도 모른다.)를 설치하고 공유 앨범을 하나 만든다. 공유 앨범의 이름을 블로그 포스팅을 위한 무언가로 지정해주면 관리하기 편하겠다.사진을 찍고 구글 포토를 열어서 공유 폴더에 추가해준다. 글은 어차피 PC에서 작성하므로 구글 포토에 접속한후 공유 폴더에 있는 사진을 열고 이미지 링크 복사를 통해 이미지 주소를 가져와 이를 컨텐츠파일에서 사용하면된다. 컨텐츠 버전 관리테마 폴더 아래 _posts 폴더가 우리가 마크다운 파일을 작성하는 곳이 될 것이므로 이 폴더를 버전관리 하면 된다. 깃허브나 비트버킷이 있는데 비공개 저장소는 비트버킷이 가능하므로 나는 이를 이용했다. 테마 버전 관리말이 테마지 지킬에서는 테마가 서빙에 필요한 모든 구조를 다 포함하고 있으므로 설정파일인 _config.yml 파일을 포함해 layout파일들이 모두 여기에 포함되므로 UI와 관련된 모든 수정이 여기서 발생하게 된다. 이 때문에 포킹이 필요하게 되며 무료 테마의 경우 보통 깃 허브를 통해 포킹하게 될 것이므로 포킹후 테마를 클론하여 여기서부터 시작하면 이미 버전관리는 시작됐고 수정하는 것들에 대해서 커밋, 푸쉬등을 퉁해 그대로 버전관리를 진행하면된다. 추가적인 운영 팁(?)마크다운을 통해 로컬 텍스트 에디터를 통해 포스팅을 할 수 있다는 강력한 장점이 있지만, 글 도입부에 YAML을 통한 포맷을 반복적으로 해줘야하는데 이런 부분은 각자가 사용하는 에디터에 대한 무언가로 해결 할 수 있으리라 생각된다.단순하게는 포맷 파일을 하나 두고 열어서 복사하는 방법이 있겠고 개인적으로는 아톰을 사용하는데 아톰은 자바스크립트를 통한 핵이 가능하고 플러그인을 만들기는 공수가 큼으로 아래와 같은 방법을 통해 하고있다. 2016-01-30 웹페이지를 통한 이메일 발송구매한 지킬 테마에 contact 페이지가 포함되어있는데 이메일을 웹페이지에서 바로 보낼 수 있는 서비스다. 이를 위해선 서드파티 이메일 서비스가 필요하다.","categories":[{"name":"setup","slug":"setup","permalink":"http://blog.bglee.me/categories/setup/"},{"name":"draft","slug":"setup/draft","permalink":"http://blog.bglee.me/categories/setup/draft/"}],"tags":[]},{"title":"그린스모크 구매, 사용 후기","slug":"greensmoke","date":"2016-01-15T15:00:00.000Z","updated":"2018-03-29T06:03:19.626Z","comments":true,"path":"posts/2016/greensmoke/","link":"","permalink":"http://blog.bglee.me/posts/2016/greensmoke/","excerpt":"","text":"작년 블랙프라이때 부터 고민을 하다가 1년이나 밀려서 지금 구매를 하게 되었다. 구매동기 음주후 숙취. 역류성 식도염의 직접적인 원인. 2014 블랙 프라이데이 때는 국내에서 아마도 리차져블 키트라고 해서 팔고 있는 배터리 2 + 카트리지 2 조합의 키트가 아마 무료 또는 $1였던 것으로 기억한다. 뭐 이벤트였지만 당시에는 국내 직배송도 했었던 것 같고 그 때 구매를 미루면서 친구에게 전자담배 하카를 구매해 사용했었으나 세척 귀찮음, 너무 잦은 망가짐(아마 이것도 암페어가 안맞는 충전기를 이용해서 그런 것 같다)으로 연초를 태울 수 밖에 없었고 어느샌가 그렇게 시간이 흘러버렸다. 2015 에도 나름의 블랙프라이 데이를 맞아 이참에 직구 경험도 해볼 겸 해서 구매를 하게 되었다. 구매 과정그린스모크 홈페이지인 http://www.greensmoke.com/에서 그냥 구매를 하면된다. 구매 이전에 배대지 싸이트에 하나 가입을 해서 배대지 주소를 받아놓고 그 쪽으로 주문을 하면 되겠다. 본인 같은 경우는 직구직구를 통해 주문하였으며 DE 주소로 배송을 했다.니코틴이 20ml이상이 되면 추가적인 세금이 붙는 걸로 알고 있어서 키트에 포함된 카트리지를 포함해서 카트리지는 20개로 맞추어 주문했다.익스프레스 키트 + 카트리지 3팩을 주문하면서 첫 주문이니 만큼 다양한 향과 몸에 맞는 니코틴 양을 경험하기 주문을 아래와 같이 했다. 익스프레스 키트(RED LABEL 1.2%) Tabacco GOLD 1.8% Mocha MIST 1.8% Smooth CREAM 1.8% 원래 피우던 담배는 슬림형 1mg를 피웠고 그에 맞추면 0.6%가 맞겠지만 카트리지 구매가 쉽지 않은점을 고려해 한두 단계 강한 것으로 결정했다. 주문은 Visa나 Master카드가 있으면 어렵지 않게 주문을 하고 주소는 배대지로 신청을 했다. 2016-01-16 http://www.couponbox.com에서 greensmoke 로 검색하면 쿠폰 코드가 나오는데 실제로 적용이 된다. 단돈 몇 달러라도 아낄 수 있다. 배송 과정 배송일은 5-6 영업일이라고 되어 있었지만 배송중 딜레이가 되어 이틀이 추가 되었으며 주말로 밀리면서 한국행 비행기가 월요일로 잡혀 실제로는 +4일 이상 연기되었다. 배대지에 도착하기 전에 트래킹 넘버와 오더 넘버를 배대지에 기입해 줘야하고 입고가 완료된 경우 결재를 해주어야한다. 전자 담배같은 경우는 일반통관으로 분류된다.금요일날 한국에 도착해서 토요일 오전에 집에 도착했다. 영업상의 이유로 토요일 배송을 하지 않던 우체국이 9월 부로 토요일 배송을 재개했다고한다. 사용기 4가지 카트리지 향을 모두 피워 봤는데 니코틴 양에 따라서 타격감이 당연히 다르겠지만 이게 향에 따라서 다르다 스무스 크림 같은 경우는 1.8%인데도 더 부드럽게 느껴진다. 처음와서 이것 저것 해본다고 많이 빨았더니.. 목이 좀 부은 것을 보니 다음 주문에는 0.6%두개 1.2%두개가 될 것 같다. 향 (2016년 이름) RED LABEL 1.2% (SIGNATURE RED)말보로 레드의 향과 비슷하다고 홍보하는 것 같으나, 처음에 하카 전자담배를 사용하면서 골랐던 향(무슨 향인지 기억은 못하나 당시에는 연초와 비슷하다고 느껴서 구매)과 매우 흡사하다. 그냥 전자담배 기본 향인거 같다. 연초랑은 잘.. Tabacco GOLD 1.8% (SOUTHERN GOLD)좀 구수한 맛이 난다. 다른 1.8% 향보다 더 묵직하게 들어온다. 피자마자 별로네 했는데.. 나름 묵직한게 매력이 있는 것 같다. Mocha MIST 1.8%원두향이라고 보는게 옳다. 이 향을 피울때는 감기상태여서.. 감기가 돌아올때 즈음엔 카트리지를 다펴서 탄내가 나서 아직은 파악이 잘 안되고 있으나 특별히 매력적이진 않다. Smooth CREAM 1.8%아마 이전에 바닐라 드림즈 로 알려졌던 향인 것으로 보인다. 많은 사람들의 평가와 같이 좋았다. 가장 많이 피고 있는 카트리지. 추가 Menthole Ice 1.8%박하맛인데 연초의 멘솔처럼 시원하진않다 판매를 보면 1위인거 같은데 시원한 박하맛이 아닌 달달한 느낌이라고해야하나 나쁘진 않은데 기대했던 멘솔은 아니다. Absolute Tabacco 1.8% (CLASSIC)말보로 미둠을 모델로 나온 향으로 알고 있다. 개인적로는 시그니쳐 레드보다 더 묵직한 것 같다. 타바코 골드와 그나마 비슷한다 더 강하고 묵직하다. 개인적으로는 타바코 골드가 난 것 같다. 아마 이전에 바닐라 드림즈 로 알려졌던 그 향인 것 같은데 많은 사람들의 평가와 같이 역시 좋다. 전자담배를 피면서 왜 꼭 연초 향을 따라가야하는 의문을 던진다. 목넘김도 부드럽고 주변에서의 거부감도 없다. 향은 좋은데 많이 피면 혀가 약간 떫떠름한 느낌이 있다. 스무스 크림이 주력이 될 것 같다. 다른 향도 사용을 해보겠지만 스무스 크림의 약간 혀가 떫은 느낌과 달달한 느낌을 커버 할 수 있는 향 하나(지금으로선 타바코 골드)를 병행하면 무난할 것으로 보인다. 연초는?도착한 순간 부로 바로 연초를 대체했고 오늘로 10일째다. 이전에 이미 한달 가량 끊었다가 입을 대서 그게 다시 서서히 늘어나 돌아왔던 경험이 있어 그린스모크로 잘 참고 있다. 밥을 많이 먹었을때가 위긴데 이럴땐 묵직한 놈으로.. 평소때는 스무스 크림으로.. 뭐 이런식이다. 추가해마다 인지는 모르겠어 2016년이 되면서 3개 향에 대한 이름이 바꼈다. 2015에 오면서 바닐라 드림즈가 스무스 크림이 된게 아닌가 한다. 연초를 일주일에 한번 정도 태워보고 있는데 담배 처음 피울 때 느껴지는 종이가 타는 향이 느껴지고 손에서 향이 너무 심하게 나서 오히려 안피게되는 것 같아 현재 만족 중이다. 2016-01-11 그린스모크로 넘어온지 한달째 날. 연초를 산적은 없고 술자리에서 한대씩 빌려(?) 폈으나 10가치가 안되는 것 같다. 연초 냄새가 너무 강하고 피고나면 손 씼어야하는 불필요한 일들이 없어져서 좋다. 집에서 나가는 일이 줄어들어 집중도도 좋아진 것 같고, 숙취가 엄청 심한데 이 또한 현저히 줄어들었다. 흡연량은 초반에 신기해서 많이 피던 때(이틀에 한개 소모)나 술을 오래마신 날(하루 한개 소모)을 포함해서 현재 13카트리지를 소모했으니 한개의 카트리지로 평균 2.4일 정도를 피우는 것 같다. 기존 연초도 하루 반갑, 술마신날은 한갑 이상을 태웠었다. 지금은 술자리에서 연초 생각이 거의 안나고 니코틴을 줄이려고 카트리지 주문을 니코틴 레벨 1.2%로 내려서 주문했다. 개인적으로 맨솔이나, 담배맛이 별로 입에 맞지않아. 더 줄어들었던 것 같다. 관세 관련 경험담배를 구매하면 관세를 물게 되는데 특별한 이벤트에 구매시에는 카트리지명이 아닌 물품명이 ‘Black Friday 2015 Sale’, ‘Snowy savings’등으로 바뀌게 된다. 기존 세일이 아닐시에는 물품명이 ‘FlavorMax™ Cartridges’ 이런 것들이 세관에서 잡히느냐 마느냐에 영향을 주는 것 같다. 2016-01-21 2016년도 부터는 익스프레스 킷에 들어있는 케이스가 플라스틱 케이스에서 가죽 케이스로 대체됐다. 가죽케이스가 생각보다 커서 갤럭시 노트 급 사이즈가 아닌가 한다. 가죽 케이스에는 롱 배터리와 카트리지가 결합된 상태로 넣을 수 있고 단종된 플라스틱 케이스는 숏 배터리도 결합상태로는 캐리가 불가능하다. 그냥 주머니에 넣고 다니고 카트리지 하나 가지고 다니는게 편해 쓸일은 없을 듯하다. 케이스를 닫은 상태 케이스 내부 쿠폰 코드 구매시에 디스카운트 받을 수 있는 쿠폰 코드가 메일로 제공되고 있어 이 부분을 공유한다. January10 : Offer expires 11:59pm, PST January 12, 2015Gh435pE9 : 10% Off Your Next Purchase. This Coupon expires on: 01/31/16 2015-12-29: 18일차 마트리지 9개째 이용중이 이틀에 하나 꼴로 소비하고 있는 것 같다. 배송기간을 생각해서 오늘 추가로 4팩을 주문했다.2016-01-02: 멘솔향 추가2016-01-11: 한달 사용기, 추가 구입 정보, 쿠폰2016-01-16: 클래식향 추가2016-01-21: 케이스 추가2016-01-27: 쿠폰","categories":[{"name":"device","slug":"device","permalink":"http://blog.bglee.me/categories/device/"}],"tags":[]},{"title":"Jaybird BBX 본사 A/S 후기","slug":"jaybird_bbx_as","date":"2016-01-07T15:00:00.000Z","updated":"2018-03-29T06:03:19.626Z","comments":true,"path":"posts/2016/jaybird_bbx_as/","link":"","permalink":"http://blog.bglee.me/posts/2016/jaybird_bbx_as/","excerpt":"","text":"Jaybird BBX2013년 4월 제이버드 BBX를 랏츠몰에서 19만원에 가까운 돈을 주고 구매했다. 디자인도 디자인이고 배터리 지속시간등이 너무 마음에 들어 잘 썼던 제품이다. 2013년 7월 고장이 나서 한번 교품을 받았었고 2015년 10월 다시 고장이 났을땐 팬택 계열의 랏츠몰은 더 이상 운영을 하지 않는 상황이었다. A/S는 아직 된다는 설도 있으나 구입한지 1년이 지나 보증기간이 지난 상태에서 A/S관련 포스트를 읽고 미국 본사 A/S를 진행하기로 했다. 증상고장난 내 BBX의 증상은 블루투스 페어링이 된 상태에서 음악이 나 게임등을 하다가 중간에 스스로 “Power off” =&gt; “Power on” =&gt; “Searching for your music devices” 뭐 이런식의 멘트가 반복되는 일종의 무한루프였다. 하드웨어 리셋을 검색하여 시도해 봤으나 동일 증상이 반복되어 일단 이에 대한 메일을 제이버드 서포트 홈페이지를 통하여 보냈다. 시차가 완전히 꼬이는 관계로 하루에 메일을 하나 받고 하나 회신을 하는데 새벽 4시경에 회신이 와서 바로 회신을 한 경우에도 다음날 새벽에 회신이 오는 것을 보면 LIVE HELP 메뉴를 통해 채팅으로 서비스를 받는편이 나을 것 같다. 과정2015-12-09 나: 고장 증상, 구매 위치를 알리고 고객 지원을 받을 수 있는가?2015-12-09 Jaybird: 구매 증명을 할 수 있는가?2015-12-09 나: 랏츠몰에서 주문증명 서류발급은 아직 가능한 관계로 캡쳐 이미지 및 PDF 파일 전송2015-12-10 Jaybird: 좋다. 이름, 이메일(메일로 대화하고있는데…?) 주소, 주소, 전화번호를 다오2015-12-15 나: 정보를 보냄*2015-12-15 Jaybird: 보증 교환을 해주겠다. 자세한 상황은 메일 보냈다. 그리고 x2s(x2?)를 보내주겠다2015-12-15 나:(RMA코드 메일을 받음), 내가 x2를 받게 되는게 맞는지 재차 확인해달라.2015-12-16 Jaybird: 맞다. 2015-12-16 우체국 EMS를 통해 발송(27,600(배송비) + 400(박스비)) 2015-12-16 나: EMS으로 보냈고 tracking number 첨부했다.2015-12-17 Jaybird: 들어오면 메일 주겠다. 2015-12-23 Jaybird에 EMS 도착 2015-12-24 Jaybird: x2 배송추적이 안되는 써있는데 트래킹 넘버를 포함해서 배송을 알려왔고 주문서 형식으로 이메일이 발신되었다. 추적이 끊긴지 일주일이 되었고 검색 결과 LN으로 시장하는 경우 원래 갑자기 추적이 안된다고한다. 2016-01-08 택배가 아닌 우편 형식인지라 박스인데도 불구하고 우편함에 들어가있었다. 추적은 안되지만 미국 본사에서 발송한지 15일만에 X2를 받아 볼 수 있게됐다. 후기집에 IT기기가 굉장히 많은관계로 잭이 맞다고 아무 충전기나 사용했던게 잦은 고장의 원인이 될 수 있다는 생각이 왜 지금 드는지 모르겟다. 출력 암페어를 잘 봐야할 것 같다. 국내 A/S는 1년이였는데… 본사에서… 하.. 미국. 게다가 BBX가 아닌 X2로 돌아오다니.","categories":[{"name":"device","slug":"device","permalink":"http://blog.bglee.me/categories/device/"}],"tags":[]},{"title":"제이버드 X2","slug":"jaybird_x2","date":"2016-01-07T15:00:00.000Z","updated":"2018-03-29T06:03:19.627Z","comments":true,"path":"posts/2016/jaybird_x2/","link":"","permalink":"http://blog.bglee.me/posts/2016/jaybird_x2/","excerpt":"","text":"어쩌다 보니(BBX가 망가져서 A/S보내 X2로 교환받은 포스트)를 갖게 되었다. 성능상으로의 스펙의 차이는 크게 없고 둘다 검정인데(미드나잇 블랙) X2의 색상은 무광으로 처리되어 있어 조금더 고급스러운 느낌이 든다. 2016-01-22 어제 간만에 외출을 하면서 간만에 사용하려고 핸드폰의 블루투스를 키고 X2전원을 눌렀는데 바로 연결됐다는 소리가 들렸다. 대기전력 상태였나? 홈페이지에서 매뉴얼을 참고해보니 맞는 것 같다. 250시간. 몇일동안 안쓰다가 바로 연결했는데 배터리가 반이나 차있어서 좋았다. 아이폰은 페어링시 배터리 잔량이 폰에 표시된다.","categories":[{"name":"device","slug":"device","permalink":"http://blog.bglee.me/categories/device/"}],"tags":[]},{"title":"돈주고 구매한 프로그램들","slug":"programs","date":"2016-01-05T15:00:00.000Z","updated":"2018-03-29T06:03:19.631Z","comments":true,"path":"posts/2016/programs/","link":"","permalink":"http://blog.bglee.me/posts/2016/programs/","excerpt":"","text":"Windows 반디캠 WebStorm NetDrive2","categories":[{"name":"draft","slug":"draft","permalink":"http://blog.bglee.me/categories/draft/"}],"tags":[]},{"title":"Jekyll","slug":"blog_with_jekyll","date":"2016-01-05T15:00:00.000Z","updated":"2018-03-29T06:03:19.623Z","comments":true,"path":"posts/2016/blog_with_jekyll/","link":"","permalink":"http://blog.bglee.me/posts/2016/blog_with_jekyll/","excerpt":"","text":"기존 블로그 플랫폼의 경험네이버, 티스토리, 텀블러, 고스트 등등 블로그 플랫폼을 맛만 봤었다. 각자 장, 단점이 있는데 내가 느끼는 바를 표로 정리해봤다. 네이버 - 쉽다, 네이버에서 유저 유입, 네이버 내에서의 강력한 커뮤니티 티스토리 - 쉽다, 광고 플랫폼과의 연동, 다음에서의 유저 유입 텀블러 - 마크다운 지원 워드프레스 - 기억 안남 고스트 - 기억 안남 지킬을 선택한 이유 자유도를 원했다. 컨텐츠가 플랫폼 독립적이길 원했다. 마크다운 언어 사용. 자유도는 물론 설치형 플랫폼을 선택하는 경우 얻어진다. 워드프레스, 고스트등이 해당될 것으로 보인다. 사용하는 입장에서는 스킨 사용 폭 정도가 되지 않을까 한다. 컨텐츠가 플랫폼 독립적이다. 이 말은 컨텐츠가 물건이면 플랫폼은 그걸 그저 전시하는 공간으로 사용하겠다는 이야기다. 지킬이 가장 마음에 들었던 것은 마크다운으로 컨텐츠가 관리된다는 점이다. 마크다운 언어는 매우 간결하며 text파일 이면서도 가독성이 좋다. 때문에 글을 쓰는 입장에서는 마크다운 언어 하나를 배워서 텍스트 에디터 하나만으로도 포맷을 갖춘 글 작성이 가능해진다. 마크다운을 지원하는 블로그 플랫폼은 몇 가지 존재한다. 텀블러나 고스트 등이 그랬던 것으로 기억한다. 그러나 텀블러는 마크다운을 지원할 뿐 컨텐츠 독립적이진 않다.지킬은 글을 마크다운 언어만을 통해 작성한다. 그리고 설치형이기 때문에 지킬을 설치하고 인터넷에 있는 테마 하나를 받고 지킬을 통해 실행시키면 바로 서버는 운영상태가 된다. 테마 폴더안에 있는 _post 폴더에 마크다운 파일만 작성하면 된다. 컨텐츠가 플랫폼 독립적이다.컨텐츠의 독립블로그 운영을 위해 깃허브등에서 원하는 테마를 포크했다고 해보자. 테마에는 각자의 설정파일이 존재하고 버전관리를 위해 포킹이 필요하다. 포크를 하고 샘플로 들어있는 _post 폴더를 삭제한다. 그리고 문서를 관리할 새로운 저장소를 하나 만들고 이를 여기에 클론을 한다. 그럼 테마는 테마대로 버전관리를 하면서 테마를 바꾸고 싶거나 할 때 아무 상관없이 포스트들이 저장되어있는 저장소를 다시 테마 안으로 클론 함으로써 컨텐츠는 플랫폼과 무관하게 계속 사용이 가능하게 된다. 댓글도 독립댓글 은 컨텐츠 이상의 가치를 지닌다. 그러면서도 컨텐츠와 연관되어 있다. 컨텐츠가 플랫폼과 독립지 적이지 않은경우 여기서 문제가 발생한다. 댓글이 플랫폼에 종속적이기 때문에 만약 다른 플랫폼으로의 이전을 하고 싶은 경우에는 그 동안 다른 사람들과의 소통을 하며 가치를 키워돈 댓글들을 상실하게 된다. 이를 위해선 서드파티 댓글 시스템을 도입해야하고. 이는 소셜 댓글 서비스라는 이름으로 많이 알려져있다. 이런 점들이 자유도 를 가진 플랫폼을 선택했을 때 얻어지는 점이다. 지킬의 장점지킬이 내세우는 장점은 사실 이런게 아니라 스태틱 웹 서버라 하여 php등이 서버 연산을 하여 뿌려지는 반면에 지킬은 문서가 작성되면(마크다운으로) 이를 Html로 컨버팅한 파일을 생성하고 이를 바로 서빙하는 것이다. 이를 통해 서버는 적은 연산으로 더 많은 사용자를 감당할 수 있게 될 것이다.내게는 이런 점보다 서버 효율적인 면보다 자유도가 더 크게 다가온다. 지킬의 단점귀찮다. 지금도 테마 폰트 가독성등의 문제를 잡고 이미지 셋업등을 해야하는데 아직도 못하고 있다.","categories":[{"name":"draft","slug":"draft","permalink":"http://blog.bglee.me/categories/draft/"}],"tags":[]},{"title":"Ionic + TypeScript","slug":"ionic-typescript","date":"2016-01-03T09:19:28.244Z","updated":"2018-03-29T06:03:19.626Z","comments":true,"path":"posts/2016/ionic-typescript/","link":"","permalink":"http://blog.bglee.me/posts/2016/ionic-typescript/","excerpt":"","text":"Angular.js와 Ionic을 공부할 겸 해서 TypeScript와 함께 앱을 제작해 보려고 한다. 프로토타입 제작Ionic framework을 이용하기로 했는데 이미 Ionic은 플랫폼화가 되어버려 지금은 Ionic Creator라는 프로토타입 제작 툴을 제공한다. 여러가지 도전을 해본 결과 UI디자이너가 없는 경우라면 프로토타입을 만드는데 시간이 오래걸려(UI를 만들어야하기 때문) 실패하는 경우가 꽤 있었다. 그래서 이를 이용하기로 했다. Ionic CreatorIonic Creator는 Ionic에서 앱을 생성할때 불러올 수 있는 장점이 있어 빠르게 프로토타입을 제작할 수 있을 것 같아 바로 선택했다. 1$ ionic start [APP NAME] [TEMPLATE] 기본적으로 TEMPLATE에 템플릿을 지정해서 앱 생성을 하게 된다. 1$ ionic start [APP NAME] creator:[IONIC CREATOR PROJECT CODE] 이때 만들어 놓은 프로토 타입을 불러와서 만드려면 위와 같이 하면 된다.Ionic Creator에서 Export를 누르면 영상을 포함해서 친절하게 설명해준다. 프로젝트 생성환경 셋업1$ npm -g install cordova ionic typescript gulp bower 프로젝트 생성프로토 타입을 만들었으면 코드 그릇이 될 프로젝트를 생성한다. 123$ ionic start [APP NAME] creator:[IONIC CREATOR PROJECT CODE]$ cd [APP NAME]$ ionic serve APP NAME 은 앱 이름인 동시에 폴더 이름이 된다. 위 코드를 실행하면 브라우저가 뜨면서 제작한 프로토 타입이 동작하는 것이 확인된다. 여기서 부터 시작이다. 2016-01-03 아이오닉 프로젝트에서 관리되는 gulpfile.js 를 열고 ts파일을 와치할 수 있도록 해준다 1$ npm -g install gulp-tsc 12345var typescript = require('gulp-tsc');gulp.task('compile', function() &#123; &#125;) 진행중 참조 Automating Icons and Splash Screens","categories":[{"name":"draft","slug":"draft","permalink":"http://blog.bglee.me/categories/draft/"}],"tags":[]},{"title":"리디북스 페이퍼 라이트","slug":"ridibooks_paper_lite","date":"2016-01-02T15:00:00.000Z","updated":"2018-03-29T06:03:19.632Z","comments":true,"path":"posts/2016/ridibooks_paper_lite/","link":"","permalink":"http://blog.bglee.me/posts/2016/ridibooks_paper_lite/","excerpt":"","text":"리디북스의 대국민 독서지원 프로젝트 이벤트를 모르고 지나갔는데 앵콜로 다시하길래 1, 2, 3차를 모두 지르고 4차 이벤트로 베스트컬렉션을 169,000원에 리디북스 페이퍼 라이트를 껴서 파는 이벤트까지 모두 질렀다. 재밌는 이벤트인게 1, 2, 3차를 모두 결재하게되면 16만원 4차 이벤트는 16만 9천원인데 1, 2, 3차로 들어온 포인트를 여기에 사용할 수 있다. 추가로 9천원을 결재하면 된다는 이야기인데 어쨋건 페이퍼 라이트가 8만 9천원에 들어오는 상황에서 읽을지 안읽을지는 모르지만 800권 수준의 명작(?)을 8만원에 50년 대여하는… 왠지 안하면 손해보는 느낌이 들게하는 이벤트라 구매를 하게 되었다.","categories":[{"name":"draft","slug":"draft","permalink":"http://blog.bglee.me/categories/draft/"}],"tags":[]},{"title":"진행 내역","slug":"milestone","date":"2015-12-20T15:00:00.000Z","updated":"2018-03-29T06:03:19.627Z","comments":true,"path":"posts/2015/milestone/","link":"","permalink":"http://blog.bglee.me/posts/2015/milestone/","excerpt":"","text":"블로그 public git repository 생성 &amp; 테마 적용 포스팅을 위한 private git repository 생성 포스팅을 위한 사진 공유 서비스 환경 설정 운영 서버(odroid-xu3-lite) domain 구매 및 DNS 등록 ruby &amp; jekyll 설치 및 운영 node.js 설치(via NVM) external storage dock 연결 WebDAV를 이용한 NAS 구성 netatalk을 통해 afp 지원 transmission-daemon을 통해 torrent 원격 다운로드 지원 게임 C# 공부 게임 제작 일지(via Unity)","categories":[{"name":"draft","slug":"draft","permalink":"http://blog.bglee.me/categories/draft/"}],"tags":[{"name":"계획","slug":"계획","permalink":"http://blog.bglee.me/tags/계획/"},{"name":"지킬","slug":"지킬","permalink":"http://blog.bglee.me/tags/지킬/"},{"name":"jekyll","slug":"jekyll","permalink":"http://blog.bglee.me/tags/jekyll/"},{"name":"milestone","slug":"milestone","permalink":"http://blog.bglee.me/tags/milestone/"}]},{"title":"Atom","slug":"atom_plugin_list","date":"2015-12-19T15:00:00.000Z","updated":"2018-03-29T06:03:19.621Z","comments":true,"path":"posts/2015/atom_plugin_list/","link":"","permalink":"http://blog.bglee.me/posts/2015/atom_plugin_list/","excerpt":"","text":"plugins seti-icons","categories":[{"name":"draft","slug":"draft","permalink":"http://blog.bglee.me/categories/draft/"}],"tags":[]},{"title":"netatalk 3","slug":"afp","date":"2015-07-25T00:00:00.000Z","updated":"2018-03-29T06:03:19.621Z","comments":true,"path":"posts/2015/afp/","link":"","permalink":"http://blog.bglee.me/posts/2015/afp/","excerpt":"","text":"netatalk OSX finder 에서 cmd + k를 통해 네트워크 드라이브를 쉽게 연결하여 쓸 수 있는데, afp:// 프로토콜로 연결하려면 server에 netatalk 설치가 필요하다. 이 시점에서는 3.1.7버전이 사용되었고 설치된 서버는 hardkernel odroid xu3 lite가 사용됐으며 os는 ubuntu 14.04 32bit다. http://netatalk.sourceforge.net/123$ ./configure --with-init-sytle=debian$ sudo apt-get install libdb-dev$ make O_IGNORE관련 에러가 날 수 있는데 해결방법 은 아래와 같다. include/atalk/acl.h, line 63, #define O_IGNORE 0를 추가한다.123#define O_NETATALK_ACL 0#define O_IGNORE 0 // added#define chmod_acl chmod 1$ sudo make install afp는 ln -s로 생성되는 symbolic link를 지원하지 않는 것으로 보인다.","categories":[{"name":"program","slug":"program","permalink":"http://blog.bglee.me/categories/program/"}],"tags":[]},{"title":"nginx-webdav","slug":"nginxwebdav","date":"2015-07-23T15:00:00.000Z","updated":"2018-03-29T06:03:19.630Z","comments":true,"path":"posts/2015/nginxwebdav/","link":"","permalink":"http://blog.bglee.me/posts/2015/nginxwebdav/","excerpt":"","text":"NGINX WebDAV setupnginx에 모듈을 추가하기 위해 빌드를 다시 해야하므로 nginx stable 버전 source와 nginx-dav-ext-module을 다운로드 받아 압축을 푼다. nginx nginx-dav-ext-module 기존 설치되어 있는 nginx의 설정을 복사하기 위해 아래 명령어를 실행하고 –with부터 복사를 해둔다. 12345bglee@deptno:~/tmp/nginx/nginx-1.8.0$ nginx -Vnginx version: nginx/1.4.6 (Ubuntu)built by gcc 4.8.2 (Ubuntu/Linaro 4.8.2-19ubuntu1)TLS SNI support enabledconfigure arguments: --with-cc-opt='-g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security -D_FORTIFY_SOURCE=2' --with-ld-opt='-Wl,-Bsymbolic-functions -Wl,-z,relro' --prefix=/usr/share/nginx --conf-path=/etc/nginx/nginx.conf --http-log-path=/var/log/nginx/access.log --error-log-path=/var/log/nginx/error.log --lock-path=/var/lock/nginx.lock --pid-path=/run/nginx.pid --http-client-body-temp-path=/var/lib/nginx/body --http-fastcgi-temp-path=/var/lib/nginx/fastcgi --http-proxy-temp-path=/var/lib/nginx/proxy --http-scgi-temp-path=/var/lib/nginx/scgi --http-uwsgi-temp-path=/var/lib/nginx/uwsgi --with-debug --with-pcre-jit --with-ipv6 --with-http_ssl_module --with-http_stub_status_module --with-http_realip_module --with-http_addition_module --with-http_dav_module --with-http_geoip_module --with-http_gzip_static_module --with-http_image_filter_module --with-http_spdy_module --with-http_sub_module --with-http_xslt_module --with-mail --with-mail_ssl_module 압축을 해제한 nginx source 디렉토리에서 아래와 같이 configure를 설정한다 12bglee@deptno:~/tmp/nginx/nginx-1.8.0$ ./configure --prefix=/etc/nginx --conf-path=/etc/nginx/nginx.conf --sbin-path=/usr/sbin/nginx --pid-path=/var/run/nginx.pid --lock-path=/var/lock/nginx.lock --user=http --group=http --http-log-path=/var/log/nginx/access.log --error-log-path=/var/log/nginx/error.log --http-client-body-temp-path=/var/lib/nginx/client-body --http-proxy-temp-path=/var/lib/nginx/proxy --http-fastcgi-temp-path=/var/lib/nginx/fastcgi --http-scgi-temp-path=/var/lib/nginx/scgi --http-uwsgi-temp-path=/var/lib/nginx/uwsgi --with-imap --with-imap_ssl_module --with-ipv6 --with-pcre-jit --with-file-aio --with-http_dav_module --add-module=/home/bglee/tmp/nginx/nginx-dav-ext-module-master --with-http_geoip_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_realip_module --with-http_spdy_module --with-http_ssl_module --with-http_stub_status_modulebglee@deptno:~/tmp/nginx/nginx-1.8.0$ service nginx start 설정이 끝났으면 빌드와 설치를 하기 위해 아래와 같이 입력한다 12bglee@deptno:~/tmp/nginx/nginx-1.8.0$ make &amp;&amp; make installbglee@deptno:~/tmp/nginx/nginx-1.8.0$ service nginx start 빌드 오류일 경우 make에서, 퍼미션 오류일 경우 make install이 nginx를 설치하는 과정에 났다고 보면된다.전자의 경우는 구글에서 솔루션으르 검색하고 후자의 경우는 sudo make install로 설치하면 해결된다 마지막으로 nginx 구동을 위해 아래 명령어를 실행하고 퍼미션 오류의 경우는 sudo를 붙여주면 된다. 123bglee@deptno:~/tmp/nginx/nginx-1.8.0$ service nginx stopbglee@deptno:~/tmp/nginx/nginx-1.8.0$ service nginx reloadbglee@deptno:~/tmp/nginx/nginx-1.8.0$ service nginx start 인증을 통해 제공하려면 https://www.digitalocean.com/community/tutorials/how-to-set-up-http-authentication-with-nginx-on-ubuntu-12-10를 참고한다.","categories":[{"name":"program","slug":"program","permalink":"http://blog.bglee.me/categories/program/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://blog.bglee.me/tags/nginx/"},{"name":"nginx webdav","slug":"nginx-webdav","permalink":"http://blog.bglee.me/tags/nginx-webdav/"},{"name":"webdav","slug":"webdav","permalink":"http://blog.bglee.me/tags/webdav/"},{"name":"dav","slug":"dav","permalink":"http://blog.bglee.me/tags/dav/"}]},{"title":"LEARN: Unity & C#","slug":"unity-csharp","date":"2015-07-21T15:00:00.000Z","updated":"2018-03-29T06:03:19.633Z","comments":true,"path":"posts/2015/unity-csharp/","link":"","permalink":"http://blog.bglee.me/posts/2015/unity-csharp/","excerpt":"","text":"교재 유니티와 C#으로 배우는 게임 개발 교과서 002. 디지털 프로토타입 제작18장: HELLO WORLD: 첫 번째 프로그램Rigidbox의 mass는 질량으로 단위는 1KG가 된다.Rigidbox 속성을 추가해야지만 물리각 작동된다.prefab은 instance화가 가능한 GameObject다.code에서 Instantiate를 통해 연결된 prefab을 생성할 수 있다.프로젝트 파네에 instance화가 가능한 prefab은 항상 큐브 모양의 아이콘이 왼쪽에 표시된다. 19장: 변수와 컴포넌트float은 double보다 정확도가 떨어지지만 속도가 빠르기 때문에 모든 기본 제공 유니티 함수는 double이 아닌 flaot형을 사용한다.float은 1이하 수천 이상에서 심각하게 정확도가 떨어지기 때문에 게임의 요소는 1이상 수천 이하에 유지되는 것이 효율적이다.char는 ‘’ string은 “”으로 감싸져야지만 된다. 주요 유니티 변수 타입 변수 설명 Vector3 3개의 flaot 변수의 집합 Color 투명 정보가 포함된 색 Quaternion 회전 정보 Mathf 수학 함수 라이브러리 Screen 디스플레이에 대한 정보 SystemInfo 장치에 대한 정보 GameObject 씬에 포함된 모든 게임오브젝트 형식 유니티 게임오브젝트와컴포넌트 컴포넌트 설명 트랜스폼 위치, 회전 배율 MeshFilter 화면에 보이는 모델 Renderer 게임오브젝트 표시 Collinder 게임오브젝트의 물리적 존재 Rigidbody 물리 시뮬레이션 스크립트 여러분이 작성하는 C# 스크립트 20장: 부울 연산과 조건문 &&, || 는 단축 연산자로써 첫 번째 구문에서 답이 나온경우 두번째 구문을 실행하지 않는다. &, | 는 첫 번째 구문과 상관없이 두번째 구문까지 평가한다. &는 | 보다 우선순위가 높다. switch문은 리터럴의 동등 비교만 허용 21장: 루프22장: 리스트와 배열23장: 함수와 매개 변수params keyword를 통해 동일한 형식의 매개 변수를 수에 제한 없이 받도록 할 수 있다. 1234567int Add(params int[] ints) &#123; int sum = 0; foreach (int i in ints) &#123; sum += i; &#125; return (sum);&#125; 24장: 디버깅 클래스 명과 파일 명은 동일해야 한다. 재생중이거나 일시정지 상태에서의 변경사항은 적용되지 않는다. 25장: 클래스set 접근자에는 암시적 변수 value가 존재한다.[SerializeField] 특성은 private 변수를 인스펙터에서 확인하고 편집할 수 있게 해준다. 123int Add(params int[] ints) &#123;[SerializeField]private int _num = 0; 26장: 객체 지향적 사고27장: 애자일 사고방식 너무 귀찮아서 더 이상 읽을 수가 없다. 003. 게임 프로토타입 예제와 실습28장: 프로토타입 1: 사과 받기코드보다 인스펙터에서의 public 변수 수정이 우선하게 된다.Destroy(this);는 Script 컴포넌트 자체를 삭제하게 되며 인스턴스 삭제를 위해서는 Destroy(this.gameObject);를 사용한다. 123456789// MonoBehaviour ClassAwake() // Start() 보다 먼저 호출된다. 데이타 세팅등에 사용된다.Start() // 시작할 때 한번 호출 된다.Update() // 프레임 마다 호출 된다.// 외Camera.main // main camera 접근 전역 변수PlayerPref // javascript localStorage 역할을 한다.Application.LoadLevel(\"Scene Name\"); // Scene을 로드한다. 29장: 프로토타입 1: 미션 데몰리션magnitude는 Vector의 length다12transform.Find(\"Object Name\"); // 하위 오브젝트를 찾을때&lt;GameObject&gt;gameObject.SetActive(false); // GameObject가 비활성화 되면 이벤트, 렌더링 함수가 호출 되지 않는다.","categories":[{"name":"summary","slug":"summary","permalink":"http://blog.bglee.me/categories/summary/"}],"tags":[{"name":"유니티와 C#으로 배우는 게임 개발 교과서","slug":"유니티와-C-으로-배우는-게임-개발-교과서","permalink":"http://blog.bglee.me/tags/유니티와-C-으로-배우는-게임-개발-교과서/"},{"name":"unity","slug":"unity","permalink":"http://blog.bglee.me/tags/unity/"},{"name":"unity3d","slug":"unity3d","permalink":"http://blog.bglee.me/tags/unity3d/"},{"name":"게임 개발","slug":"게임-개발","permalink":"http://blog.bglee.me/tags/게임-개발/"},{"name":"C#","slug":"C","permalink":"http://blog.bglee.me/tags/C/"},{"name":"씨샵","slug":"씨샵","permalink":"http://blog.bglee.me/tags/씨샵/"}]},{"title":"Google IO extended Seoul","slug":"google_io_extension_session.web","date":"2015-07-14T15:00:00.000Z","updated":"2018-03-29T06:03:19.625Z","comments":true,"path":"posts/2015/google_io_extension_session.web/","link":"","permalink":"http://blog.bglee.me/posts/2015/google_io_extension_session.web/","excerpt":"","text":"Google IO extendedChrome exchanted 2015GeoLocation API permission META TAG meta tag theme, content 로 주소창의 색을 바꿀 수 있다. simply recommend installing your web app 설치 유도 웹 배너, 크롬에서 동작 가능(install banner) 일반적으로 manifest.json을 생성html의 link태그에서 ref=’manifest’ href=’xxx.json’과 같은 형식 123window.addEventListener('beforeinstallprompt', function(e) &#123; //e.userChoice.then&#125;); chrome custom tab프로그램을 실행시키는 방법 browser webview둘간에 컨텍스트 공유가 되지 않는다.chrome custom tab은 컨텍스트 공유가 가능하다.(로그인 정보 등)sugar의 홈메뉴와 같은 느낌인듯weight: browser &gt; chrome custom tab &gt; webviewcct가 뜨기전에 pre-start, pre-fetch등이 가능하다. native app install banner android만 가능 자주들어오는 방문자(2주 2일 2회이상)일 경우 네이티브 앱 설치 프로모션 배너를 띄울 수 있음 service workeroff-line지원가능.web worker와는 다르게 대몬과 같이 동작한다 생성이 아닌 설치의 개념으로 말해진다.web worker는 ui thread와는 다르게 dom에 대한 접근이 불가능한데 이 점은 web worker와 같다. push 서비스의 구현이 가능하다. chrome browser에서만 지원이 된다. service worker의 경우 타 브라우저에서도 지원을 하기로 한 상태, 사파리는 모르겠음.service worker가 지원되지 않는 경우에도 기존과 같이 동작이 가능한 장점이 있다. Polymer첫 폴리머 사이트: google-status.com?translate comnunitysantatracker.google폴리머를 구성하는 4개의 스펙에 대한 관심을 가져달라. Polymer Starter KitWeb Starter Kit 프로젝트 템플릿 &amp; 워크플로 speaker: @ragingwind vulcanize: concat과 비슷한 과정(crisper?)stream도 한번써보시구요celenium은 무엇인지? 12345$ npm install -g generator-polymer$ yo polymer$ // yo polymer:element new-element$ // yo polymer:seed new-element$ // yo polymer:gh mkcd 명령어가 존재했었나? 커스텀 엘레먼트들이 모이는 곳 FireBase와 Angular.js 기본적으로 PaaSParse, Firebase, bass.ioAngularFire라는 라이브리가 존재AngularFire쓰지말고 mvc.js쓰지 말라고 RAILResponseAnimationIdleLoad Critical Rendering PathrequestAnimationFrame API를 사용하라selector는 복잡도를 낮게 하라wil-change(transform) 사용크롬 실행실 화면에서 shift키 6번 히든메뉴 디자이너가 없어도 괜찮아무료 이미지 사이트 unsplash lifeofpix floating action button은 1개정도lazied button 10개 정도 버튼은 대문자 Guideline getmdl.io","categories":[{"name":"summary","slug":"summary","permalink":"http://blog.bglee.me/categories/summary/"}],"tags":[{"name":"google io","slug":"google-io","permalink":"http://blog.bglee.me/tags/google-io/"},{"name":"google io extended","slug":"google-io-extended","permalink":"http://blog.bglee.me/tags/google-io-extended/"},{"name":"web 세미나","slug":"web-세미나","permalink":"http://blog.bglee.me/tags/web-세미나/"}]}]}