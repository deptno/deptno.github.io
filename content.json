{"meta":{"title":"봉로그","subtitle":"봉지니어링","description":"코드를 넘어","author":"deptno@gmail.com","url":"http://blog.bglee.me"},"pages":[{"title":"All categories","date":"2017-07-09T07:29:04.000Z","updated":"2018-03-29T06:03:19.634Z","comments":true,"path":"categories/index.html","permalink":"http://blog.bglee.me/categories/index.html","excerpt":"","text":""},{"title":"All tags","date":"2017-07-09T07:28:08.000Z","updated":"2018-03-29T06:03:19.635Z","comments":true,"path":"tags/index.html","permalink":"http://blog.bglee.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"AWS AppSync, Amplify를 이용한 IAM 롤 기반의 풀스택 GraphQL 프로젝트 구현","slug":"aws-appsync-iam","date":"2018-08-18T04:13:02.000Z","updated":"2018-08-18T04:23:19.912Z","comments":true,"path":"posts/2018/aws-appsync-iam/","link":"","permalink":"http://blog.bglee.me/posts/2018/aws-appsync-iam/","excerpt":"","text":"&#x1f508; 진행 과정의 원할함을 위해 프로젝트 명은 deptno 로 가정한다.&#x1f508; IAM 을 통한 비인증 유저의 AppSync GraphQL 접근을 목표로 한다.서론😭 이 글은 눈물로 작성되었다. 눈물없이 가능하지 않았던 처절한 삽질을 말끔히 정리하고자 한다.인증은 매우 복잡하면서도 중요한 파트로 여러가지 방식이 존재하고 일단 설정하면 바꾸기 어렵다. 때문에 시행착오를 통합 삽질을 하기에도 매우 두려운 부분이다. 그래서 명확히 이해 해야만 했고 거의 그럴뻔 했으나 만들어진 코드나 매우 소중이 다루자는 결론에 이르렀다?react-apollo 와 같이 표준에 가까운 라이브러리 들이 있지만 여기선 aws-amplify 에서 제공하는 최소한만을 사용했다. AWS의 코드 샘플 자체가 react-apollo 기준이라 이 편이 더 도움이 될 거라 생각했다. 타 서비스도 GraphQL 를 사용해서 엔드포인트가 두개가 될 경우 골치아파지는데 그런 경우에 대응하기 위한 점도 고려됐다.글은 프로젝트와 함께 진행된다. 이 프로젝트는 AWS AppSync, Cognito, Amplify, DynamoDB 를 통해 비인증 유저에게 Graph QL API 콜을 통한 데이터를 제공한다. 추가적으로 인증 유저에게 다른 권한을 부여하기 위함이다. 이 부분은 나중에 풀어보겠다. 아마도 이 길인 것 같아서 선택했다. &#x1f338;프론트엔드 프로젝트와 함께 설정값을 넣으면서 그때 그때 필요한 AWS 리소스를 생성해가면서 진행하도록 한다. 때문에 진행은 프론트엔드와 AWS가 함께 진행된다. configure.js 파일을 채워나가면서 진행해보자.동작에 대한 궁금증은 마지막 프론트엔드 프로젝트를 구현하면서 우리가 해왔던 것들이 어떤 영향을 갖는지 최대한 설명 해보겠다.AWS Amplify 설정설치프로젝트 디렉토리에 진입해서 aws-amplify패키지를 설치한다.1yarn add aws-amplify프로젝트의 원활한 진행을 위해 내가 자주쓰는 Next.jS 를 기준으로 작성하겠다.1yarn add next설정1touch configure.js설정 파일을 만들고 다음과 같은 코드를 삽입한다.1234567891011// configure.jsimport Amplify from 'aws-amplify'Amplify.configure(&#123; Auth: &#123; identityPoolId: 'XX-XXXX-X:XXXXXXXX-XXXX-1234-abcd-1234567890ab', region: 'XX-XXXX-X', userPoolId: 'XX-XXXX-X_abcd1234', userPoolWebClientId: 'XX-XXXX-X_abcd1234', &#125;&#125;)설정에 입력된 바와 같이 4가지 필요하다.identityPoolId - 코그니토 연동 자격 증명에 대한 풀 IDregion - 서울이라면 ‘ap-northeast-2’userPoolId: - 코그니토 유저 풀 IDuserPoolWebClientId - 코그니토 유저 풀 생성 후 앱 클라이언트 설정 에서 시크릿 키 체크 해제 후 생성된 IDCognito 설정먼저 유저풀을 생성한다.코그니토 유저 풀 생성(Optional)https://ap-northeast-2.console.aws.amazon.com/cognito/users 에 접속 후 사용자 풀 생성 버튼을 클릭한다.Dev Deptno User Pool 를 입력하고 기본값 검토를 누른다.정책 &gt; 암호 강도에서 체크박스를 모두 해제하고 자릿수를 6으로 설정한다.앱 클라이언트 &gt; 클라이언트를 추가하되 클라이언트 보안키 생성 을 해제한다. 이름은 Dev Deptno Web Client 로 했다.다시 검토 로 이동해서 풀 생성 버튼을 누른다.이전 설정 에서 만들었던 configure.js 에서 userPoolId 를 풀 생성 후 나오는 풀 ID 로 교체한다. 앱 클라이언트 설정 으로 이동해서 클라이언트 ID 를 userPoolWebClientId 에 입력한다.코그니토 자격 증명 풀 생성(Required)Dev Deptno Identity Pool 이름을 지정하고 인증되지 않은 자격 증명에 대한 액세스 활성화 를 체크 한다.인증 공급자에서 Cognito 탭에 configure 에 입력한 userPoolId 와 userPoolWebClientId 를 순서대로 입력한다.풀 생성 버튼을 눌러 풀을 생성한다. IAM 설정이 나오는데 허용 을 눌러서 인증, 비인증 유저에 대한 롤을 생성한다. 추가 후 나오는 자격 증명 풀 ID 를 configure.js 의 identityPoolId 에 넣는다.IAM Role 설정코그니토 자격 증명 풀을 생성할 때 인증되지 않은 자격 증명에 대한 액세스를 활성화 했다. 이때 미인증에 대한 IAM ROLE 도 함께 생성했는데 Cognito Sync 가 AppSync 로 대체되면서 정책 설정이 제대로 않아 401 에러가 발생한다.이를 해결하기 위해 IAM &gt; 역할 로 가면 역할을 이름을 변경하지 않고 그대로 갔다라면 Cognito_DevDeptnoIdentityPoolUnauth_Role 형식의 이름으로 역할이 존재한다. 이를 선택하고 인라인 정책 &gt; JSON 을 선택하고 아래 데이터를 붙여넣는다.123456789101112&#123; \"Version\": \"2012-10-17\", \"Statement\": [ &#123; \"Effect\": \"Allow\", \"Action\": [ \"appsync:GraphQL\" ], \"Resource\": \"*\" &#125; ]&#125;그리고 역할을 생성한다. 아래와 같은 형식으로 이름을 넣어주면 보기 편하겠다.역할을 생성하고 정책이 연결됬으면 미인증 유저의 GraphQL 엔드포인트에 대한 접근이 허가된다.AppSyncAppSync 는 아직 서울 리전이 지원되지 않는다. 때문에 우린 도쿄로 간다.&#x26c8; awsmobile cli 커맨드를 통해 생성하면 GraphQL 엔드포인트가 ap-northeast-2(서울) 로 설정파일이 생성되지만 서울 리전에는 아직 AppSync 가 존재 하지 않는다. 템플릿 예외 처리 오류로 보인다.https://ap-northeast-1.console.aws.amazon.com/appsync/home?region=ap-northeast-1#/create AWS 콘솔에서 AppSync 를 선택하고 Create API 를 누른다. 템플릿이 몇개 주어지는데 Author from scratch 를 선택해서 깔끔하게 시작한다.이름은 Dev Deptno GraphQL 정도면 멋진것 같다.Settings 섹션으로 이동하면 인증 타입을 선택할 수 있다.기본은 API key 다 헤더에 추가만 해주면 동작하므로 매우 간편한 방식이다. 우리는 AWS Identity and Access Management 를 선택한다.이제 클라이언트에서 콜을 할때 가지고 있는 인증 권한에 따라 API 가 제한되게된다.DynamoDB 설정&#x1f508; AppSync 가 서울에서 지원이 안되다보니 서비스를 이동하다보면 리전이 꼬일 수 있다. 나머지 리소스는 서울임을 계속 확인하는 것이 좋다.AppSync 가 데이터를 퍼다 나르기 위해서 데이터 소스를 연결해야하는데 이 프로젝트에서는 다이나모디비를 이용한다. AWS 콘솔에서 DynamoDB 를 선택한다.테이블 섹션에서 테이블 만들기 를 누르고 이름이랑 키만 설정하면 바로 테이블이 생성된다.(어썸..👍)파티션 키는 email 이라고 쓰고 대충 생성을 하자. 테이블 이름은 Dev Deptno User 로 한다.&#x1f914; 테이블 이름은 단수로 해야 GraphQL 스키마 자동생성을 할 때 깔끔하게 맞는 느낌이 있다..Data Source 추가다시 AWS 콘솔에서 AppSync 로 돌아온 뒤 Data Source 섹션을 선택하고 새로운 소스를 추가하기 위해 New 를 누른다.Data source name 을 설정하는데 여기선 공백이 먹지 않으므로 다이나모디비 프리픽스를 붙이고 파스칼 케이스로 이름을 정했다.DDB_DevDeptnoUserData source type 에서는 Amazon DynamoDB Table 을 선택한다.Region 은 서울이므로 AP-NORTHEAST-2 를 선택한다.Table name 은 아까 생성한 Dev Deptno User 를 선택하거나 입력한다.&#x1f914; 가끔 테이블을 제대로 불러오지 못하니 그럴경우 그냥 입력한다.Create or use an existing role 에서는 New role 을 선택한다.Automatically generate GraphQL 를 활성화하면 친절하게도 스키마를 바로 뽑아준다. 활성화 하자.Create 를 눌러 데이터 소스를 생성하자. 생성이 완료되면 Schema 섹션으로 이동해서 스키마가 잘 생성됐는지 확인한다. 생성된 스키마에 대한 테스트는 바로 아래 섹션인 Queries 에 Graphiql 느낌의 클라이언트가 들어가있어 바로 확인이 가능하다.이제 생성된 AppSync API 정보를 바탕으로 configure.js 파일을 업데이트 하자.1234567891011//configure.jsimport &#123;AUTH_TYPE&#125; from 'aws-appsync/lib'const configuration = &#123; Auth: &#123; //... &#125;, aws_appsync_graphqlEndpoint: 'https://xxx.appsync-api.xx-xxxxx.amazonaws.com/graphql', aws_appsync_region: 'xx-xxxx-x', aws_appsync_authenticationType: AUTH_TYPE.AWS_IAM, graphql_endpoint_iam_region: 'xx-xxxx-x'&#125;API Details 에 있는 API URL 이 aws_appsync_graphqlEndpoint 다. aws_appsync_region, graphql_endpoint_iam_region 은 모두 도쿄에서 생성했으므로 ap-northeast-1 을 넣어주면 된다. aws_appsync_authenticationType 은 &quot;AWS_IAM&quot; 인데 상수가 정의되어 있으므로 그를 이용한다.&#x1f481; AUTH_TYPEAUTH_TYPE 에 따른 추가적인 데이터가 반드시 필요하다.AWS_IAM - graphql_endpoint_iam_regionAWS_API - aws_appsync_apiKeyAMAZON_COGNITO_USER_POOLS -Front-end드디어 프론트엔드다. 그럼 이제 설정만 있는 프론트엔드 프로젝트를 고도화해보자.Next.jsNext.js 기반이므로 그에 대한 구조를 갖춰주자. Next.js 는 pages 디렉토리 밑을 통해 라우팅이 된다는 점이 특징이니 따로 라우터 설정은 하지 않아도 된다. CRA(create-react-app) 의 컨벤션 룰이 내겐 너무 갑갑해서 사용하는 것일 뿐 어려운 점은 없다. 그냥 파일 두개를 만들면 된다.123mkdir pagestouch pages/index.jsxtouch graphql.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546//pages/index.jsimport * as React from 'react'import '../configure'import &#123;createUser, getUsers&#125; from '../graphql'export default class extends React.Component &#123; readonly state = &#123; users: null, email: '' &#125; render() &#123; return ( &lt;div&gt; Hello world!&lt;br/&gt; &#123;this.state.users &amp;&amp; &lt;pre&gt;&#123;JSON.stringify(this.state.users, null, 2)&#125;&lt;/pre&gt;&#125; &lt;form onSubmit=&#123;this.handleOnSubmit&#125;&gt; &lt;input type=\"text\" value=&#123;this.state.email&#125; onChange=&#123;this.handleOnChangeEmail&#125; /&gt; &lt;button&gt;추가&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; ) &#125; async componentDidMount() &#123; this.users() &#125; async users() &#123; this.setState(&#123;users: await getUsers()&#125;) &#125; handleOnChangeEmail = (e) =&gt; &#123; this.setState(&#123;email: e.target.value&#125;) &#125; handleOnSubmit = async (e) =&gt; &#123; e.preventDefault() await createUser(this.state.email) this.users() &#125;&#125;12345678910111213141516171819202122232425//graphql.jsimport &#123;API, graphqlOperation&#125; from 'aws-amplify'export const getUsers = () =&gt; API .graphql(graphqlOperation(queryUsers)) .catch(_ =&gt; [])export const createUser = (email: string) =&gt; API .graphql(graphqlOperation(mutationCreateUser, &#123;email&#125;)) .catch(_ =&gt; null)const queryUsers = `query DeptnoUsers &#123; listDeptnoUsers &#123; items &#123; email &#125; nextToken &#125;&#125;`const mutationCreateUser = `mutation CreateDeptnoUser($email: String!) &#123; createDeptnoUser(input: &#123;email: $email&#125;) &#123; email &#125;&#125;`코드에 대한 설명은 따로 필요 없을 것 같다. React 와 GraphQL 에 대한 지식이 조금 있으면 된다. query 는 AWS 콘솔에서 AppSync, 생성한 API를 선택한후 Schema 누르면 참조할 수 있다.실행이제 코드를 만들었으니 실행을 하면 된다.1npx next연관 링크깃허브에 코드가 공개되어 있으며 코드는 타입스크립트를 기준으로 짜여졌으나 이해하기에 다르지 않다.https://github.com/deptno/aws-appsync-iam-example 예제 코드 깃허브 저장소.https://blog.bglee.me/posts/2018/aws-appsync-iam 본 글의 블로그 포스트.부록&#x1f481; aws-amplify-react 를 사용하면 인증에 대한 처리 분기를 리액트에서 보다 쉽게 할 수 있다. 공식 문서&#x1f481; aws-appsync-react 패키지는 apollo-react 를 사용할때 오프라인 제어 및 로컬 캐싱을 위한 지원이 있는 것으로 보인다. apollo-react 의 사용 유저라면 반드시 문서를 참조해보도록 한다. 깃허브","categories":[],"tags":[{"name":"aws","slug":"aws","permalink":"http://blog.bglee.me/tags/aws/"},{"name":"cognito","slug":"cognito","permalink":"http://blog.bglee.me/tags/cognito/"},{"name":"amplify","slug":"amplify","permalink":"http://blog.bglee.me/tags/amplify/"},{"name":"dynamodb","slug":"dynamodb","permalink":"http://blog.bglee.me/tags/dynamodb/"},{"name":"unauthenticated","slug":"unauthenticated","permalink":"http://blog.bglee.me/tags/unauthenticated/"},{"name":"iam","slug":"iam","permalink":"http://blog.bglee.me/tags/iam/"},{"name":"role","slug":"role","permalink":"http://blog.bglee.me/tags/role/"},{"name":"graphql","slug":"graphql","permalink":"http://blog.bglee.me/tags/graphql/"}]},{"title":"타입스크립트 모노레포","slug":"typescript-monorepo","date":"2018-08-15T09:45:58.000Z","updated":"2018-08-15T09:45:58.538Z","comments":true,"path":"posts/2018/typescript-monorepo/","link":"","permalink":"http://blog.bglee.me/posts/2018/typescript-monorepo/","excerpt":"","text":"TypeScript, Monorepo타입스크립트와 모노레포 셋업은 매우 지난한 싸움이다. 맞지 않는 부분도 상당히 많다. 내가 일전에 무엇을 남겼는지 기억은 나지 않으나 비슷한 글을 남겼었다.🌸 모노레포. Lerna? Yarn Worksapce!위 글에 모노레포가 왜 필요지에 대해서는 남겨 놨을 것이라 생각한다. 어떻게 셋업을 하는지 글을 남겼었지만 그럼에도 불구하고 타입스크립트를 마주하면 쉽지않은 상황이 발생한다. 특히 프론트엔드에서 그러하다.프로젝트를 가볍게 생성한다고 해보자. 내가 자주 쓰는 Next.js 의 빵판 이나 아니면 그냥 create-react-app 에 react-scripts-ts 를 먹여서 TypeScript 로 프로젝트를 셋업하면 작업하는 내내 .js , .map 등은 더이상 밖으로 노출되지 않고 메모리안에서 처리된다. 때문에 우리는 .gitignore 를 따로 처리하면서 파일 IO에 대한 성능 이슈등으로 부터 자유롭다. 바람직하다.그럼 무엇이 문제인가?모노레포의 구성은 아래 사진과 유사하다.이 이미지는 이전에 쓴 글에서 가져온 것인데 프론트엔드가 없는 라이브러리의 구현 구조다. 구조를 보면 feed, html, readme, speech 의 패키지가 존재한다. 편의상 readme 를 create-react-app 등으로 생성한 메인 클라이언트 앱 이라고 생각하자. 그럼 여기서 packages/readme/index.js 는 지워진다. 프로젝트 셋업에 따라 .js는 관리하지도 보여지지도 않는다.나머지 패키지들은 컴파일의 결과로써 .js 을 유지해야한다. 각 패키지를 리엑트 컴포넌트 라고 생각하고 메인인 readme 에서 참조를 하게 되면 모노레포의 구성 이유와 같이 외부 모듈로 처리하므로 import 구문을 통해 로드시에 .js 가 로드되므로 반드시 .js 가 필요하다.그럼 메인 프로젝트인 readme 는 컴파일을 따로 돌려서 .js 를 생성하면 안되고 나머지 패키지들에 대해서는 컴파일을 통해 .js 를 생성해야한다. 이 부분이 타입스크립트와 모노레포의 조합을 매우 어렵게 만든다. 부분마다 따로 컴파일을 돌리고 IDE 셋업에 매이는등 많은 삽질을 하다가 아마 그만뒀던 경험을 가진 개발자들도 여럿(나만? &#x1f440;)있을지 모르겠다.TypeScript 3섹션이 하나 더 들어가야하는데 시행착오에 대해서 적을까 하다가 그에 대한 잘 씌여진 글로 대체한다. TypeScript 공식 사이트의 프로젝트 레퍼런스 핸드북과 후이서울에서 작성한 글이다.https://engineering.huiseoul.com/타입스크립트-3-0-99e5d45ec439https://www.typescriptlang.org/docs/handbook/project-references.html모노레포에 관련된 글은 아니다. 그러나 프로젝트 빌드와 관련해서 인상적인 발전이 있었다. --build 명령어와 프로젝트 참조를 통해 순차적으로 효율적인 빌드를 적용한다 뭐 이런 내용인데 자세한 내용은 문서에 있다.Monorepo그럼 다시 모노레포로 돌아오자. next 나 create-react-app 의 개발환경이 돌면서 추가적으로 나머지 패키지들에서 빌드가 같이 돌아줘야한다. 나머지 패키지들은 컴파일을 통해서 .js 를 생산해 낼 것이고 메인 앱에서는 이들이 .js 를 가지고 있으므로 개발환경에서 바로바로 import 를 할 수 있게 된다.드디어 추가된 타입스크립트@3 의 프로젝트 레퍼런스와 --build 를 통해 더러운 프론트엔드 + 타입스크립트 + 모노레포 가능해진다.이에 대한 설명은 글보다 코드로 대신한다.Next.js 버전create-react-app 버전등아파서 글을 길게 못쓰겠다…","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://blog.bglee.me/tags/react/"},{"name":"typescript","slug":"typescript","permalink":"http://blog.bglee.me/tags/typescript/"},{"name":"monorepo","slug":"monorepo","permalink":"http://blog.bglee.me/tags/monorepo/"},{"name":"next","slug":"next","permalink":"http://blog.bglee.me/tags/next/"},{"name":"create-react-app","slug":"create-react-app","permalink":"http://blog.bglee.me/tags/create-react-app/"},{"name":"cra","slug":"cra","permalink":"http://blog.bglee.me/tags/cra/"}]},{"title":"RxJS 에 대한 고민과 Quick start RxJS 서평","slug":"rxjs","date":"2018-08-15T09:09:17.000Z","updated":"2018-08-15T09:09:17.567Z","comments":true,"path":"posts/2018/rxjs/","link":"","permalink":"http://blog.bglee.me/posts/2018/rxjs/","excerpt":"","text":"책도 읽은 겸rxjs 의 도입에 대한 고민과, 책에 대한 후기를 남긴다.RxJS 도입의 어려움대부분의 작업을 혼자 함에도 불구하고유독 rxjs 만이 더욱 도입하기가 어려웠다. 공식 문서를 통해 메서드들을 영어 단어 외우는 느낌으로 출, 퇴근 길에 보면서 다니기도 했으나 역시 코드를 작성하는 것이 아니면 기억이 나지 않는다.rxjs 는 접근하기도 사용하기도 어려웠다. rxjs 의 도입 허들에는 3가지 정도의 이슈가 있을 것이라 생각됐다.필요성러닝 커브감염적 코드필요성일단 필요성이다. rxjs 가 없이도 잘 구현할 수 있으며 오히려 도입했는데도 불구하고 지식이 모자라면 유지 보수에서 어려움을 겪는다. 편리한 메서드들이 많이 있지만 lodash 에서도 충분히 지원되며 EventEmitter 클래스등을 이용하면 독립성을 가지는 코드를 가질 수 있다. 코드가 길어지는 경향이 있지만 충분했고, 익숙했다.하지만 ramda 의 도입 필요성과 마찬가지로 rxjs 를 통해 많은 비동기 처리를 독립적으로 처리하고, 직관적이면서도 더 적은 코드를 통해 생산성에 니즈는 언제나 있다.러닝 커브일단 홈페이지를 열면 너무 많은 메서드들이 나온다. rxjs 의 도입 이슈는 FP(ramda.js) 를 도입할 때와 같다. 코드가 줄어들고 가독성이 확보되며 직관적이다. 반면 이를 위한 많은 메서드들도 방대해서 도입이 쉽지않다.그러나 ramda 를 통해 꽤나 익숙해진 메서드들이 있었고, FRP 라이브러리로 불리는 rxjs 에서도 많이 쓰였다.pluck, map, tap, take, first 등등감염적 코드어쩌다 보니 영문을 번역한 듯한 문구가 됐는데, 비동기 처리는 관련 코드를 시작하면 상용하는 측에서도 패턴이 강제되는 연속성이 있다. 이에 대한 가장 유명한 예가 Callback hell 이다.Callback hell, Promise, Async-Await1234567asyncWork(_, (err, data) =&gt; &#123; asyncWork(data, (err, data) =&gt; &#123; asyncWork(data, (err, data) =&gt; &#123; // Callback hell &#125; &#125;)&#125;)Promise 도 다르지 않다.123asyncWork .then(data =&gt; asyncWork(data)) .then(data =&gt; asyncWork(data))async-await 을 보자.12345async function asyncWork(data) &#123; data = await asyncWork(data) data = await asyncWork(data) return data // Promise 반환&#125;코드가 보기 좋은가, 안좋은가 대한 이야기가 아니라 패턴의 강제성에 대한 이야기다. 가독성은 좋아지고 있다. 그럴드 수 밖에 없지만 어쨋건 Promise 에 한번 발을 들이면 Promise 체인 패턴에 묶인다.RxJS 는?이 부분에 있어서 오히려 rxjs 는 Promise 체인의 형태와 유사한데 뭐 워낙 익숙해서 이제 이런 감염성은 문제가 되지 않는 것 같기도하다.Quick start RxJS출근 버스에서 3일 봤다. 3장은 다 보지 못했으나 버스내에서 주어진 시간이 45분 정도인데 그 시간에 한장을 다 읽을 수 있었다(3장으로 구성 되어 있다).책 읽는 속도가 느린 편임에도 불구하고 잘씌여진 책은 잘 읽히는구나 라고 생각했다. 아는 개념들에 대해서는 패스하고 RxJS 자체에 집중에서 책을 읽었을 때의 얘기다.1장은 RxJS 가 나오게 된 배경, 2장은 RxJS 자체에 대해 작은 프로젝트를 진행해가며 그때마다 필요한 메서드를 추가하면서 설명이 진행된다. 3장은 배운 것을 바탕으로 실제 RxJS를 사용하는 프로젝트를 구현하는데 초점을 맞춘다.또 좋았던 점은 책이 최신을 반영하기 위해 RxJS 6.x 를 반영했다는 점이다. 잘은 모르지만 큰 변화중 하나는 체인형태의 메서드 콜 방식에서 파이프라인 형태로 사용 방식이 변경됬다는 점이라고 생각되며 코어의 가벼움을 유지하면서 순수함수인 오퍼레이터를 프로토타입 체인에 유지할 필요가 없다고 생각했던 것 같다. 개인적으로 매우 바람직한 방향이라고 생각된다.독서의 순서책을 읽을때도 프로젝트를 진행할때도 에너지가 있어서 에너지가 많은 초반을 서론에서 빼고싶지 않았다. 대충 훑어보고 바로 2장으로 들어갔다. 1장은 깃헙에 공개되어 꽤나 읽은 내용이 있는 것도 한 몫했다.Observable 이 무엇인지, Subject 와는 어떻게 다른지 잘 설명해주고 있다. rxjs 를 이해함에 있어서 대단히 중요한 개념이고 이를 가지고 여러 메소드 들이 파생된다. 책에서 진행하는 프로젝트가 진행됨에 따라 필요한 메서드들을 적시 설명하며 지루하지 않으면서도 필요한 설명은 모두 하고 있다.2장 -&gt; 1장 -&gt; 3장 순서로 읽었는데 메인은 2장이다. 3장은 실제 프로젝트인데 2장에서 배운 범위를 넘어가지 않는 점이 정말 좋았다. 공부와 프로젝트와 완전히 분리되어있다. 부록들도 훌륭하다 이해를 높일 수 있는 결코 가볍지 않은 주제를 표로 잘 풀어준다. 꼭필요한 메소드는 설명하고간다.2장은 두번 읽어야한다.https://www.youtube.com/watch?v=3LKMwkuK0ZE 추가적으로 벤 아저씨의 영상을 보면 이해에 더 많은 도움이 된다.","categories":[],"tags":[{"name":"rxjs","slug":"rxjs","permalink":"http://blog.bglee.me/tags/rxjs/"},{"name":"reactive","slug":"reactive","permalink":"http://blog.bglee.me/tags/reactive/"}]},{"title":"Github OAuth 404, 그리고 헤더의 중요성","slug":"Github-OAuth-404","date":"2018-08-07T11:32:50.000Z","updated":"2018-08-07T12:14:31.970Z","comments":true,"path":"posts/2018/Github-OAuth-404/","link":"","permalink":"http://blog.bglee.me/posts/2018/Github-OAuth-404/","excerpt":"","text":"이 것도 한 3번인가 삽질을 한 것 같은데.. 기록을 해두지 않아 매번 삽질을 한다. 오늘도 4시간 정도 날린거같다…3 티어 인증 프로세스클라이언트(웹)에서 깃헙로 리다이렉션을 시도한다.깃헙에서는 스코프랑 유저 허락 받고 허락 되면 어플리케이션 정보 저장시에 사용했던 콜백(서버)로 code 를 전송한다.서버는 code 를 token 으로 교환한다.교환 후에는 token 을 가지고 다시 클라이언트로 돌아갈 수 있도록 302 리턴을 하면서 쿼리 파라메터로 token 을 넘긴다.이슈코드에서 토큰으로 교환하는 과정에서 깃헙이 404 를 내뱉는다. 무엇이 문제인가 &#x1f440;12345678910const response = await fetch(`https://github.com/login/oauth/access_token`, &#123; method: 'POST', body: &#123; client_id : GITHUB_CLIENT_ID, client_secret: GITHUB_CLIENT_SECRET, code, // state, // redirect_uri &#125;&#125;)Content-Type 헤더의 중요성문제는 이것 저것 해보다가 설마 헤더 때문인가? 라는 생각에 이르렀다. 코드는 다음과 같이 수정해봤다.1234567891011const response = await fetch(`https://github.com/login/oauth/access_token`, &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json' &#125;, body: &#123; client_id : GITHUB_CLIENT_ID, client_secret: GITHUB_CLIENT_SECRET, code &#125;&#125;)바로 200 OK 가 떨어진다. &#x270a;서버는 서버 엔지니어 마음언젠가는 URL에 뒤에 / 를 붙이냐 마느냐로, 200 vs 201, 200 vs 404 등등 피곤하고 시나리오적인 흐름과 주관이 섞일 수 밖에 없는 문제가 있다.소 제목은 서버는 서버 엔지니어 마음이다. 라고 달았지만 흥분을 가라 앉히고 보면 내가 잘못한게 맞다. 이런 날들을 위해 준비되어있는 스펙을 무시했다. 최근 근무한 직장도 그렇고 기본적으로 JSON 이 일반화 된 세상에서 살고 있다보니 기본이 JSON 일 것이라 예단했다. 깃헙도 꽤나 오랜 시간을 버텨왔고 매우 많은 유저가 사용하는 만큼 바꾸지 못하는 레거시가 있기 마련이다.리턴 값자성을 하고 리턴 값을 확인하려고 코드를 짜니 또 에러가 난다.1const json = await response.json()고통을 교훈으로 헤더를 확인했다.123&#123; 'content-type': [ 'application/x-www-form-urlencoded; charset=utf-8' ],&#125;두번 반성한다. 리턴값도 당연히 JSON 일리가 없었다. response.text() 도 가능하지만 요청 헤더에 Accept 를 추가했다.123456&#123; headers: &#123; 'Content-Type': 'application/json', 'Accept': 'application/json' &#125;&#125;이제 잘 날아온다. &#x1f94a;다시 한번 헤더의 중요성, 다시 한번 서버는 서버 엔지니어의 마음API 를 사용하다보면 헤더도 마음데로 들어온다. 서버리스의 serverless offline 플러그인을 통하면 event.headers.referer 가 들어오는데 반해 실제 서버에 디플로이되면 event.headers.Referer 가 들어온다. 이 경우는 플러그인 버그라 할 수 있겠지만 대소문자도 예단해선 안된다.","categories":[],"tags":[{"name":"github","slug":"github","permalink":"http://blog.bglee.me/tags/github/"},{"name":"OAuth","slug":"OAuth","permalink":"http://blog.bglee.me/tags/OAuth/"},{"name":"login","slug":"login","permalink":"http://blog.bglee.me/tags/login/"},{"name":"깃허브","slug":"깃허브","permalink":"http://blog.bglee.me/tags/깃허브/"},{"name":"로그인","slug":"로그인","permalink":"http://blog.bglee.me/tags/로그인/"},{"name":"404","slug":"404","permalink":"http://blog.bglee.me/tags/404/"}]},{"title":"서평. 진화된 마케팅 그로스 해킹","slug":"review-진화된-마케팅-그로스-해킹","date":"2018-08-02T09:38:38.506Z","updated":"2018-08-02T09:59:28.304Z","comments":true,"path":"posts/2018/review-진화된-마케팅-그로스-해킹/","link":"","permalink":"http://blog.bglee.me/posts/2018/review-진화된-마케팅-그로스-해킹/","excerpt":"","text":"초반을 제외하고는 읽는 내내 상당히 괴로웠다. 그로스 해킹 이었구나 라고 충분히 이해할 수 있었음에도 불구하고 너무나도 반복적이라 읽은 글이 5초 이후에 기억이 안나 같은 부분을 계속 읽은 것 같다. 책 자체는 그로스 해킹이 적용되지 않은 것 같아 아쉽다.그로스 해킹 은 용어 자체가 마케팅적으로 훌륭하게 정립됐다. 용어 자체만으로 관심을 끌기에 충분하다.그로스 해킹그로스 해킹은 정의를 한번에 내리기에는 너무 광범위 하다. 추적 데이터를 기반으로한 분석, 실험 설계, 적용, 수정 정도의 서클이라고 생각하면 쉬울 것 같다. 누군가는 이미 너무 많이 가지고 있는 지식과 직관을 기반으로 이런 실험으로 도출 할 수 있는 단계를 건너 띌 수도 있다 생각한다.그럼에도 불구하고 모든 면을 다 분석하기에는 무리며 일반적인 사람들로 이루어진 집단은 이런 그로스 해킹 싸이클을 통해 검증된 데이터를 얻고 이를 통해 설득의 커뮤니케이션을 비용을 낮추고 성장에 다가갈 수 있다.그로스 해킹은 심리적인 영역부터 시작하여 상당히 많은 영역을 포괄하며 실험할 수 있는 모든 분야에 적용된다.아쉬운 점아마도 저자가 마케터로 생각되는데 책이 후반부로 갈 수록 이메일, 설문조사 영역으로 치우치는 점은 아쉽다. 아마도 책에서 그로스 해킹, 깔데기 분석 등 몇 가지 단어만 줄여도 분량이 대폭 줄 것 같다. 특히 깔데기 분석같은 건 100번을 읽어도 직관적으로 다가오지 않아 역자분께 아쉬운 느낌이 있다. 왜 이렇게 안읽히나 계속 읽어보면 문장은 정상인데 접속사가 많아서 그런지 잘 읽히지 않는다.내 문제인지, 아님 너무 직역이라 어색한 것인지, 아님 안읽히는 문장을 매우 천천히 계속 적으로 시도해도 읽는다 하더라도 이미 초반 챕터에서 설명한 부분과 다르지 않을거라는 이미 실망이 마음에 반영됐을지 모른다.그럼에도책 그로스 해킹이란 개념을 심어주기에는 충분하다 중간까지 읽으면 충분하지 않을까 한다. 너무 두껍다. 좀 더 얇았어야 했다.그로스 해킹은 광범위 함에도 불구하고 데이터에 기반하여 개인화 단계까지 추적한다는 개념 자체는 직관적이면서도 누구나 공감 할, 그러나 이름이 붙어 있지 않았던 영역이라고 생각되기 때문에 이해가 된다. 정책이 명확하다랄까?어렵지 않은 내용을 너무 많은 예를 들어 접속사가 많은 문장으로 설명하다보니 결국 책을 끝까지 읽지 못했다. 시간도 오래걸리고 10번은 더 잠든거 같다. 의무가 된거같아 2챕터를 남기고 접었다. 평가는 좋은거 보니 나한테만 지루했을 지 모르겠다.이미 책을 읽는 순간에 데이터레이크 구성에 대해 관심이 고정됐다.","categories":[],"tags":[{"name":"서평","slug":"서평","permalink":"http://blog.bglee.me/tags/서평/"},{"name":"스타트업","slug":"스타트업","permalink":"http://blog.bglee.me/tags/스타트업/"},{"name":"창업","slug":"창업","permalink":"http://blog.bglee.me/tags/창업/"},{"name":"마케팅","slug":"마케팅","permalink":"http://blog.bglee.me/tags/마케팅/"},{"name":"그로스 해킹","slug":"그로스-해킹","permalink":"http://blog.bglee.me/tags/그로스-해킹/"}]},{"title":"세미나, 스타트업의 노무인사관리","slug":"seminar-스타트업의-노무인사관리","date":"2018-07-28T13:00:23.000Z","updated":"2018-07-28T13:00:23.199Z","comments":true,"path":"posts/2018/seminar-스타트업의-노무인사관리/","link":"","permalink":"http://blog.bglee.me/posts/2018/seminar-스타트업의-노무인사관리/","excerpt":"","text":"어제(2018-07-27) 스타트업의 노무 인사관리 라는 세미나(주최측에선 아카데미라 부른다)에 참석했다. 저번엔 팀 빌딩 에 들으러 참석을 했었는데 생각보다 좋은 내용이 많다.마침 집하고도 가까워서 좋은 내용이 있으면 자주 가려고하는데 노무인사관리에 대해 들은 감상은 민방위를 다녀왔을때와 비슷하다.강사님도 매우 열정적이셔서 많은걸 배울 수 있었다. 2시간을 초과해서 2시간 반이나 진행됐다.민방위민방위는 주방에서 불났을 때 대응 방법, 지진시 대피, 아파트 화재시 완강기 사용법, 소화기 사용법, 심폐소생술 등 매우 살아가는 필요한 것들을 알려준다. 민방위라는게 예비군의 연장선이라서 남자만 듣는지 모르겠으나 모두에게 필요한 매우 중요한 내용들을 가르친다고 생각이 들었었다.인사노무관리인사노무관리도 다르지 않다. 창업 아카데미라는 이름의 커리큘럼이지만 노동자와 사용자 모두에게 중요하다. 아무래도 예전에 노동 집약적 산업을 기준으로 설계된 감이 없지 않다. 그 만큼 노동자의 권리가 매우 강한 느낌인데 때문에 사용자 측에선 채용에 더 신중해 질 수 밖에 없을 것 같다.IT 분야에서는 일반 노동자가 아닌 지식 노동자고, 계속 적으로 성장하며 그에 따라 대체 불가능해진다. 때문에 스스로도 회사가 더러우면 다른데가면 그만이라는 인식과, 이직의 일상화, 당연히 평생직장은 같은 것 생각 안함으로 생각했는데 내 생각일 수 있으니 채용은 매우 신중해야한다고 느껴진다.","categories":[],"tags":[{"name":"스타트업","slug":"스타트업","permalink":"http://blog.bglee.me/tags/스타트업/"},{"name":"창업","slug":"창업","permalink":"http://blog.bglee.me/tags/창업/"},{"name":"노무","slug":"노무","permalink":"http://blog.bglee.me/tags/노무/"},{"name":"인사","slug":"인사","permalink":"http://blog.bglee.me/tags/인사/"}]},{"title":"서평, 권도균의 스타트업 경영 수업","slug":"review-권도균의-스타트업-경영-수업","date":"2018-07-26T16:20:01.000Z","updated":"2018-07-28T05:12:35.925Z","comments":true,"path":"posts/2018/review-권도균의-스타트업-경영-수업/","link":"","permalink":"http://blog.bglee.me/posts/2018/review-권도균의-스타트업-경영-수업/","excerpt":"","text":"서평, 권도균의 스타트업 경영 수업이번엔 스타트업의 경영에 대해 알고 싶어 이 책을 선택했다.경영 에 대해 무지하기 때문에 사기전에 경영이 문과인지 이과인지 부터 검색했다. &#x1f40f; 그냥 말로 풀어진 책이었다. 수치나 이런게 나올 수도 있겠다 했었는데 그냥 읽을 수 있는 책이었다. &#x1f606; 역시 좋은 책이고 뭐라도 읽어야하는 나에게 또 지식과 경험을 줬다.구성무려 12챕터에 챕터당 10개정도의 소 주제를 가지고 이루어져있다. 필요한 부분만 찾아보기에 좋을 것 같고 저자의 경험을 위주로 씌여져있다.내용원론적이고 바른 얘기가 많이 쓰여져 있다.공감아래는 주인공이 나구나 (하아…)🍶 하면서 읽은 부분들 중 몇가지다.기업가 정신의 네가지 특징저자는 보통 기업가 정신이라 하면 피상적이고 모호하며 사람마다 다르게 해석되는 말로 정의 하고 있다고 말하며 자신이 본 네가지를 말한다.낙관주의낙관주의에 대해 저자는 미래 지향성을 이야기한다. 현재보다 미래에 배팅하고 움직인다. 저자의 생각에 첨언을 하자면 공무원이 안정적이라 하여 지금 공무원을 준비하는 것은 사람에 따라서 미래에도 그 일이 가장 안정적이라 생각하기 배팅하는 것일 수 있다. 그런데 여기서 이미 안정적을 추구한다는 모순이 있다. 이경우는 미래 지향적이지 않다. 현재에서 발전하지 않을 것이라 생각하는 것이므로, 보다 나은 내일에 낙관한다.주도성주도성이라 한다면 누구나 “나는 주도적인데?” 할 수 있다. 저자는 예를 들어 설명한다. 금융 기관보다 자신이 직접 돈을 관리하는 것. &#x1f604; 직접 경기에 뛰어 들어 흐름을 바꾸고자 하는 사람들이다.책임감주도성과 연관성이 깊어 보인다. 주어진 상황을 타박하지 않고 경기를 뛰는 선수처럼 심판의 오심도 경기의 일부인 것을 받아들인다. 저자는 일본 경영 컨설턴트 하마구치 다카노리 의 말을 인용한다.“경영자는 눈이 내리는 것도 내 책임이라고 말해야한다.”결과중심적 사고기업가는 행동하는 사람이다. 경영을 통해 경제적 성과 를 실체화 한다. 몽상가가 아니다. 수필가도 아니다.시작은가능한 부담 없는 상태를 유지해야한다. 매출과 자본이 없는 상태에서의 고용, 사업자 등록, 의리와 팀의 오해등이다.채용채용은 너무도 중요하다. 저자는 사람은 변하지 않는다 라는 가정을 여러 인용을 통해 말하며 그만큼 중요하다 이야기한다. 채용은 일을 얼마나 잘 하느냐 보다 내가 만드려는 문화를 보존할 수 있는가? 에 더 초점을 맞춰야한다고 말한다. 특히 초반엔비즈니스의 터나는 돈이 내게 잠깐 흐르게 하는 것이라 생각하고 그 돈의 물줄기가 나에게도 오도록 강 근처에 땅을 파서 내 근처에도 흐르게 한다는 생각을 주로했었는데 저자도 비슷한 표현을 했다. 아이디어에서도 비슷한 생각을 볼 수 있었는데 대충 이런 거다.뭔가 자신이 대단한 아이디어를 생각해냈다고 생각하고 취할 수 있지만 그 아이디어의 작동 여부는 고객에 의해서 판단된다는 것이다. 저자는 흐르는 강물에 배를 띄워라 라고 말을 한다.사업 아이템은 고객들이 필요로하는 그 곳에 생성하는 것이지 자신이 시장을 만들고나면 사람이 오는 그런게 아니라는 뜻이다. 비슷한 생각을 가지고 있다. 난 이런 생각을 니즈의 자연 발생 이라고 말하곤 한다. 예를 들면 이런거다.뭘 지원하려고 하면 주민등록등본을 스캔해서 보내란다.그럼 이걸 주민센터가서 발급하고 스캔해서 메일로 보내는데 왜이렇게 불편하게 하는건가? 한참 이전에 발전된 인증 기술을 이용해서, 서비스에 접속해서 회사에서 받을 수 있도록 인가해주면 회사에서 직접 출력하게 하면 누구에게 제출되었는지까지 추적되고, 더 투명하고, 더 편하지 않은가?많은 사람들이 고통받고 있는 것, 필요로 하는 곳에 사업을 트면된다. 하고자 하는 것을 하고 사람들이 사용하길 바라는 것이 아니다.지표책에서 지표 의 중요성을 설명한다. 근데 포커스는 측정이 아닌 선택이다. 무엇을 지표로 선택하는지는 고객의 반응을 어떻게 해석할지, 이해할지에 대한 것이기 때문에 매우 중요하며 경영자 본인이 판단해야한다.이 부분이 “호오?” 하면서 봤는데, 서비스를 하면서 중요한 데이터를 뽑아내고 수치화하고 이걸 다시 적용하는 사이클을 갖는 시스템(자동화)을 만드는 것, 이 부분이 엔지니어로써 매우 탐나면서도 수긍이 가능 부분이었다. 사실 대부분의 회사에서 이미 하고 있을텐데 생각없이 애널리틱스 하나 뿌려놓고 있는게 아니라 지표 자체도 비즈니스마다 필요한 것을 제대로 설정해서 그를 달성하는 것, 이것은 중요하고 재밌을 것 같다.팀저자는 다른 사람의 글도 많이 인용하는데 이 부분이 사실 궁금했다. 현실적이면서도 초기 팀을 구성하며 지분을 어떻게 할지, 지금 두권째 읽는 것인데 이에 대한 디테일한 수치는 나오지 않는다. 초기에 창업멤버끼리 C레벨을 구성하는데 실력이 거기에 미치지 못한다는 걸 깨달았는데 어떻게 행동해야 할 것인지, 그런일이 벌어지게 둘 것인가 등 창업을 해보곤 알수 없는 베일을 안을 잠시 들여다 볼 수 있었다.계약계약도 창업 경험이 없는 사람에게는 블랙박스인데 이 부분에 대해서도 꽤나 갈증을 풀어준다. 연봉 협상이랑 다를바가 없어보인다. 역시 최고의 협상카드는 “안할래요” 인가 ㅋㅋ요약개인 정리라 두서가 없다. 한번읽고 서머리 할 분량은 아니었다. 좋은 책이고 궁금한 걸 말해준다. 내용이 꽤 되는데다가 같은 류의 생각을 가진 것 같아 멍한 상태로 읽으면 기억에 남지 않는다. 공감을 많이해서 당연한말이 많아서 그런 것 같은데, 난 옳은 말이기 때문에 당연한 말이라고 생각한다, 다시 한번 되새길 수 있는 시간을 갖게 하고, 경험에서 나오는 실질적인 조언을 해준다.저자를 조금 찾아보니 최근 인터뷰에 왜 한국에선 유니콘이 안나오느냐 묻자. 경영이 문제라 한다.저자가 책에서 쉽게 풀어쓴 것인지 모르겠으나 경영은 특별한 학문 같은게 아니었다. 뭐랄까 회사 생활 하는 방법처럼 회사 굴리는 타이쿤 게임 공략본 같은…","categories":[],"tags":[{"name":"권도균의 스타트업 경영 수업","slug":"권도균의-스타트업-경영-수업","permalink":"http://blog.bglee.me/tags/권도균의-스타트업-경영-수업/"},{"name":"서평","slug":"서평","permalink":"http://blog.bglee.me/tags/서평/"},{"name":"경영","slug":"경영","permalink":"http://blog.bglee.me/tags/경영/"},{"name":"스타트업","slug":"스타트업","permalink":"http://blog.bglee.me/tags/스타트업/"}]},{"title":"서평, 장병규의 스타트업 한국","slug":"review-장병규의-스타트업-한국","date":"2018-07-20T15:05:26.000Z","updated":"2018-07-20T15:07:40.428Z","comments":true,"path":"posts/2018/review-장병규의-스타트업-한국/","link":"","permalink":"http://blog.bglee.me/posts/2018/review-장병규의-스타트업-한국/","excerpt":"","text":"서평, 장병규의 스타트업 한국읽은지 4-5일 됐다고 벌써 기억이 가물거리는걸 보니 역시 정리는 빠르면 빠를 수록 좋다.궁금했다.스타트업은 어떻게 운영되는가?스타트업은 어떻게 시작할 수 있는가?시작을 하게 되면 지분등은 어떻게 분배되는가?이 책을 고른 이유목차에 지분 얘기가 있는 책을 이 것 밖에 못 찾아서 이 책을 구매했다. 가격은 고려 대상은 아니었다. 가격도 쌌다. IT 창업자다.결론적으로이 책은 훌륭한 책이다. 가격도 싸다. 군더더기 없다. 경험담이다. 솔직히다. 케이스 스터디도 있다.책의 저자이 책의 저자인 장병규 대표에 대해 구두로는 많이 들어봤는데 얼굴은 책 표지를 통해 처음 알았다. 배틀그라운드의 성공, 블루홀 스튜디오 정도는 알았는데 호랑이 담배피던 시절의 원 클릭 으로 시작했다는 건 알지 못했다. 또 네오위즈 의 창업자다. 내 이전 직장 부동산 다이렉트의 투자자다.공감책을 읽으면서 초반에는 장병규 대표가 생각하는 스타트업, 뭐 그런 것들에 대해 상당히 공감을 많이 했다. 기술 서적외에는 사실 거의 읽질 않기 때문에 책 이란게 원래 이런 느낌을 받으면서 읽는 것인지는 모르겠으나 일전에 읽은 소프트웨어 장인 정신 이란 책도 상당히 공감을 많이 했다.합리화의 귀신 같은 존재인 난 소프트웨어 장인 정신 을 읽는 순간 장인이었는데, 이번엔 인맥 없고 끈 없는 장병규 대표였다. &#x1f914; 일단 생각의 방향성을 느낄 수 있는데 그 점이 와 닿아서 좋았다.책의 중간 중간, 해서 4개 정도의 창업자 케이스 소개가 있다. 모두 장병규 대표와 연관성이 있는 사람들로 지금 장병규 대표가 있는 본엔젤스의 투자를 받은 회사라던가, 하여 창업에 대한 스토리텔링이 있다. 재밌는건 여기서 3인칭 화법을 사용하는데… 나쁘지 않았다.케이스 소개이 부분이 꽤나 좋은데 교과서 마냥 케이스를 상당히 다른 것들로 구성해놔서 궁금했던 얘기를 예를 들어 전해 듣는 느낌이랄까? 이런 예에는 성공한 케이스도 있는 반면 망한 케이스도 있다. 이런 것들이 도움이 되려면 공감이 되야하는데 여기서 창업하는 사람들은 창업에 대해 아무 것도 모른체 창업하는 케이스도 포함되어 있었기에 더 도움이 됐다.(유명한 우아한형제들의 이야기도 있다.)조언조언에 내 감상은 필요 없을 것 같다. 굳이 조금 말하자면 창업자와 투자자, 그리고 예비(?) 선배로써의 경험에서 나오는 실질적인 충고가 있다. 굳이 책에 거짓을 이야기할 이유도 없겠지만 이러한 충고들에 신뢰성을 더 하는 몇가지 양념 &#x1f336; 들이있다. 이 글은 주관적인 글이지만 이 부분은 매우 주관적이다.배틀그라운드의 성공 이후 성공에 대한 분배를 이토록 하는 기업을 본적이 없다.책 가격이 싸다(책으로 돈벌 생각은 없어보인다.)공동 창업, 스타트 업의 성장 뭐 이런 내용은 책을 보는게 빠르겠다.추천값도 싸고 필요한 말만 들어있는 그런 책이다. 그냥 해주고 싶은 얘기를 하는 것 같은데, 듣는 입장에서 궁금한 것들을 많이 얘기해준다. 저자가 독자를 공감해주는, 그렇게 씌여진 느낌을 받았다. 좋은 책이다.","categories":[],"tags":[{"name":"서평","slug":"서평","permalink":"http://blog.bglee.me/tags/서평/"},{"name":"스타트업","slug":"스타트업","permalink":"http://blog.bglee.me/tags/스타트업/"},{"name":"장병규의 스타트업 한국","slug":"장병규의-스타트업-한국","permalink":"http://blog.bglee.me/tags/장병규의-스타트업-한국/"},{"name":"창업","slug":"창업","permalink":"http://blog.bglee.me/tags/창업/"}]},{"title":"Typora ♥️  Hexo","slug":"typora-hexo","date":"2018-07-18T06:15:02.000Z","updated":"2018-07-20T13:33:23.610Z","comments":true,"path":"posts/2018/typora-hexo/","link":"","permalink":"http://blog.bglee.me/posts/2018/typora-hexo/","excerpt":"","text":"Typora, Hexo 이미지 설정⚠️ Typora와 Hexo의 소개는 이 글의 주제가 아니다. Typora 에 대한 소개는 이전 글 을 참조한다.마크다운 글 작성, 블로그 포스트, Typora 하나로 끝을 내자.서문생산성 때문에 미디움 으로 옮겨서 글을 작성한 것이었는데, 미디움의 웹 에디터가 그 다지 성능이 좋지가 않아서 다시 고민중이다.대표적인 문제는 두가지다.글 작성중 저장이 꼬였다고 리로드하라고 한다.코드 하이라이팅이 매우 취약하다.반면 여기서 쓰고 있는 Hexo는 지킬과 달리 쓸만한 테마가 그리 많지 않았다. 그렇다고 만들자니… “내가 그런 것 까지?” 하는 생각이 들고, 그나마 마음에 드는 테마를 골라도 시간이 지나면 질리기 마련이니, 여기서 또 시간이 소모된다. 글 생산에 집중하고자 했고 그래서 미디움 으로 옮기게 되었다.그런데 여기서 가볍게 글을 쓰고자 하는 나의 마음과는 달리 팔로우 라는 시스템이 붙어 버리니 조금 부담스럽게 된 것도 사실이다. 많은 사람이 글을 읽으면 더 좋으니까 라는 마음도 있었지만,그래서 좀 더 정리 안되면서도 개인적인 쏟아낼 공간이 필요해서 다시 이 곳을 활용하기로 했다.Typora &#x1f91d; HexoTypora 라는 내가 써본 마크다운 에디터중 가장 강력하며 안정화되어 있다. Hexo 는 작성된 마크다운을 가지고 포스팅을 만들어준다.그럼 여기서 소개하고자 하는, 해결하고자 하는 문제는 무엇인가?이미지 첨부이미지 첨부를 하게 되면 Typora 라는 친절하게도 몇가지 옵션을 제시한다. Hexo는 포스팅의 파일 명을 기반으로 동일 명의 디렉토리를 참조하여 이미지를 업로드하고 이를 참조한다.1234.├── cognito│ └── federated_identities_logins.png├── cognito.md이런 형태다. 즉, cognito.md 는 cognito 의 참조를 통해야 디플로이시에 문제가 발생하지 않는다.문제는 이 설정이 Hexo 의 설정과 맞지 않는다는데 있다.현재 폴더로 복사와 몇가지 프리셋이 준비되어 있는데 동일 폴더명을 선택할 수 없다. 그래서 플러그인을 작성하려다가 잠시 멈추고 몇 가지 문서를 검색해서 참조하니 간단한 해결책이 있었다.typora-copy-images-to:포스팅 글에는 마크다운 문서 상단부에 YAML 포맷으로 메타 정보를 기입할 수 있는데 이 메타 정보는 HTML 을 생성하는데 관여하고 글 자체에 영향을 주지는 않는다.이런 방식이 블로그 포스팅에 관련해서는 일반적이기 때문인지 이를 활용해서 Typora 에 설정을 주입할 수 있다. 플러그인도 아니고 기존 환경을 이용하는, 이건 뭐 매우 신박한 방식이다.결론적으로는 typeora-copy-images-to 속성을 주입놓으면 Typora 강 이를 읽고 설정보다 우선시하여 적용한다. 확인은 드래고 이미지를 넣게 되면 typora-copy-images-to 에 의해 설정된 디렉토리를 읽어 자동으로 복사가 이루어지고 그에 따른 경로도 수정되어진다. :+1:scaffoldsHexo 의 디렉토리 구조에 scaffolds 라는 디렉토리가 존재한다. 이 곳을 열어보면 일반적으로 draft.md, page.md, post.md 가 들어있다. 이를 레이아웃이라고 하는데 cli 를 통해 포스트(파일)를 기본 구조와 함께 생성할 수 있다.문서를 참조하면 기본 레이아웃은 post 다. 즉 hexo new &lt;filename&gt; 은 post, post.md 파일을 참조해서 생성된다.post.md1234567$ cat scaffolds/post.md---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;typora-copy-images-to: &#123;&#123; title &#125;&#125;tags:---파일을 열어 보면 위와 같이 되어 있다. typora-copy-images-to 속성을 눈 여겨 보자. 그럼 아까 포스트를 생성하고자 했던 명령어에 실질적으로 파일 이름을 부여해보자. 파일 이름은 타이틀도 함께 매칭된다.123hexo new typora-hexoINFO Created: ~/workspace/src/github.com/deptno/blog/source/_posts/typora-hexo.md✨ Done in 1.30s.파일이 생성되었다.123456---title: typora-hexodate: 2018-07-17 14:48:06typora-copy-images-to: typora-hexotags:---파일을 열어보면 위와 같다. 우리가 주목해야할 것은 typora-copy-images-to 속성이다. 뒤에는 을 매칭해 뒀기 때문에 값은 파일명과 같이 typora-hexo 다.때문에 이제 그냥 글을 작성하면서 이미지를 드래그해서 넣으면 알아서 typora-hexo/&lt;image-file&gt; 형식으로 삽입되게 되며 복사 또한 자동으로 이루어져 이미지에 대한 고민에서 해방된다.Generate 후 HTML에서 이미지가 깨지는 문제Hexo 의 설정 파일인 _config.yml 에서 post_asset_folder: true 를 설정하게 되면 `hexo new을 통해 파일을 생성할때 파일이름과 동일한 어셋 폴더가 자동으로 생성된다.우리는 위에서 typora-copy-images-to: 메타 속성의 주입을 통해 이미지 드래그시 파일명과 동일한 디렉토리에 이미지를 복사하게 설정을 해둬서 글을 작성할 때는 이미지 잘 보인다. 문제는 Hexo 가 hexo generate 를 할 때는 이미지를 알아서 어셋 디렉토리를 참조하게 되어어서 발생하는데 이 때문에 생성된 HTML 에서는 이미지가 깨지게 된다.hexo generate 시 경로를 중복 참조하지 않도록 플러그인을 작성했으니 동일한 이슈로 고통받는 이가 있으면 플러그인을 사용하자.https://github.com/deptno/hexo-typora-plugins/tree/master/packages/hexo-typora-imagehexo generate 전에 플러그인을 인스톨하면 자동으로 적용된다.터미널에서 Typora 를 통해 markdown 열기Hexo 에서 템플릿(scffold)을 통해 파일을 생성하기 위해서는 terminal 을 이용해야하므로 Typora 또한 터미널에서 열 수 있어야 작은 스트레스를 면할 수 있다.aliasTypora 의 공식 문서에 칠절하게 나와있어서 한줄 복사해서 사용하는 쉘의 설정파일에 추가하면된다.1alias typora=\"open -a typora\"난는 개인적으로 zsh 을 이용하고 있으므로 ~/.zshrc 파일이다. 이렇게 하면 쉘에서 파일을 생성한후 타이포라를 통해 바로 열 수 있다. typora typora-hexo.md &#x1f40f;참조https://hexo.io/ko/docs/writing.htmlhttps://support.typora.io/Use-Typora-From-Shell-or-cmd/https://support.typora.io/Images/#when-insert-local-image","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.bglee.me/tags/hexo/"},{"name":"typora","slug":"typora","permalink":"http://blog.bglee.me/tags/typora/"},{"name":"typora image","slug":"typora-image","permalink":"http://blog.bglee.me/tags/typora-image/"}]},{"title":"Cognito, Multi IDP Login 분석","slug":"cognito","date":"2018-07-16T18:00:00.000Z","updated":"2018-07-17T16:43:30.661Z","comments":true,"path":"posts/2018/cognito/","link":"","permalink":"http://blog.bglee.me/posts/2018/cognito/","excerpt":"","text":"&#x26a0; 작성 중&#x26a0; 개인적인 정리라 확실성을 띄는 단어를 사용하지만 실제론 그렇지 않을 수 있다.이 글은 목적이 존재하며 Cognito 의 소개 글이 아니다. Cognito 는 AWS 문서를 참조 바란다.현재라는 문구가 사용되면 작성 시점인 2018년 7월 17일이다.사용자 풀 과 연동 자격 증명 풀 두 가지가 존재하며 각각 따로 생성이 가능하며 연동도 가능하다. 궁극적으로 알고자 하는 것은 아래 와 같다.여러 IDP의 로그인을 통해 정보를 취합하는 앱을 만들경우 이 로그인 정보들을 어떻게 취합해서 어떻게 관리할 것인가?사용자 풀 에서도 IDP 를 연동할 수 있고, 연동 자격 증명에서도 사용자 풀과 여타 IDP 연결이 가능한데, 무엇이 다른가?특별히 궁금한 부분은 AWS 문서에도 노트로도 표시되어 있다.참고타사(연동)를 통한 로그인을 Amazon Cognito 사용자 풀에서 사용할 수 있습니다. 이 기능은 Amazon Cognito 자격 증명 풀(연동 자격 증명)을 통한 연동과 무관합니다.결국 두 방식은 다르다는 뜻으로 해석되며 2 번과 관련해서는 예상 되는 결과 는 아래와 같다.사용자 풀 베이스회원가입 후 로그인 이후에 IDP 로그인을 지원하며 이에 따라 정보가 자연스럽게 취합이 가능.연동 자격 증명 베이스로그인 퍼스트 전략으로 인증된 IDP와 앱이라면 일단 로그인이 가능하며 그에 따른 인가가 이루어짐.사용자 풀사용자 풀은 자체 DB를 갖는 일반적인 구현 형태와 같다. 때문에 회원 가입, 회원 정보, 로그인 방식(MFA 와 같은), SMS, Email 인증등을 전반적으로 제어 할 수 있다.연동 &gt; 자격 증명 공급자일단 연동 자격 증명과는 달리 입력 요구사항이 다르다.ID(Client ID) 외에 앱 보안(Secret Key)를 요구하고 인증 범위(Scope)에 대한 지정이 가능하다. 명시적(explicit) 또는 3-way 로그인 방식에서 쓰이는 요구 사항과 같으며 이에 대한 뒷 작업을 Cognito가 해주는 것으로 예상 된다.현재 지원되는 IDPFacebookGoogleLogin with AmazonSAMLOpenID Connect연동 &gt; 속성IDP 로그인을 통해 들어온 정보와 가입시의 정보가 다른 경우 어떤 정보가 저장되는가?연동 자격 증명(Federated Identities)기본적으로는 사용자 풀 없이도 단지 인증된 IDP와 앱 정보를 통해 유저를 인증하고 롤(IAM)에 따라 인가할 수 있다. 간단한 어플리케이션에서 유용할 것으로 보인다.자격 증명 풀 편집인증되지 않은 역할, 인증된 역할에 IAM을 할당하여 권한을 지정 함인증 공급자인증 공급자(Identity Provider - IDP)를 등록한다. 인증 공급자는 OAuth를 지원 업체로 생각 할 수 있다.IDP 등록을 위해서는 각 IDP 에서 생성한 App ID 가 필요하며 여기서 등록해 둔다.예제 0 페이스북을 통해 얻은 토큰 등록123456AWS.config.credentials = new AWS.CognitoIdentityCredentials(&#123; IdentityPoolId: &lt;연동 자격 증명 풀 ID&gt;, Logins : &#123; 'graph.facebook.com': response.authResponse.accessToken&lt;Facebook access token&gt; &#125;&#125;)이렇게 credentials 를 등록함으로써 로그인이 된 것으로 간주하고 인증된 역할 의 권한을 얻는다.여러 IDP를 통해 로그인이 필요한 경우여러 IDP를 통해서 로그인이 필요한 경우에는 각 로그인마다 다른 유저로 인식 되므로 이전 로그인 정보를 취합하여 다시 저장할 필요가 있다. 즉, Logins 의 오브젝트를 확장해야한다. 코드로 표현하면 다음과 같을 것으로 보인다.예제 1 여러 IDP 토콘을 저장하는 경우1234567AWS.config.credentials = new AWS.CognitoIdentityCredentials(&#123; IdentityPoolId: &lt;연동 자격 증명 풀 ID&gt;, Logins : &#123; 'graph.facebook.com': response.authResponse.accessToken&lt;Facebook 억세스 토큰&gt;, 'cognito-idp.&lt;리전&gt;.amazonaws.com/&lt;유저풀 ID&gt;': result.getIdToken().getJwtToken() &#125;&#125;)예제 2 순서가 정의되고 이미 credentials 이 이미 등록어 있어 이를 확장하는 경우1234567AWS.config.credentials = new AWS.CognitoIdentityCredentials(&#123; IdentityPoolId: &lt;연동 자격 증명 풀 ID&gt;, Logins : &#123; ...AWS.config.credentials, 'cognito-idp.&lt;리전&gt;.amazonaws.com/&lt;유저풀 ID&gt;': result.getIdToken().getJwtToken() &#125;&#125;)현재 지원되는 IDP 목록CognitoAmazonFacebookGoogle+Twitter / DigitsOpenIDSAML사용자 지정Use Case두개의 IDP: Facebook 으로 로그인 후, Cognito 로 다시 인증하는 경우예제 0 의 코드와 같은 방식으로 두번 각기 등록하는 경우는 유저가 2명으로 인식되나 Logins 에 두 정보를 함께 등록하는 경우 이 정보가 취합되어 한명의 유저로 인식된다.Logins 에 한번이라도 함께 등록되면 각기 다른 IDP에 의해 발급된 두개의 토큰은 함께 연결되는 것으로 보인다. 때문에 함께 저장하는 순간 유저 수 인식이 2 에서 1명으로 변경된다.위 이미지는 Logins 에 함께 저장 후 대쉬보드의 화면이며 Facebook 로그인(파란색)과 Cognito 로그인(녹색)이 각각 카운트가 1이나 총 자격 증명이 1 로 인식되는 걸 확인 할 수 있다. 함께 저장하기 전에는 총 자격 증명이 2 였다.","categories":[],"tags":[{"name":"cognito","slug":"cognito","permalink":"http://blog.bglee.me/tags/cognito/"},{"name":"multi idp","slug":"multi-idp","permalink":"http://blog.bglee.me/tags/multi-idp/"},{"name":"idp","slug":"idp","permalink":"http://blog.bglee.me/tags/idp/"},{"name":"user pool","slug":"user-pool","permalink":"http://blog.bglee.me/tags/user-pool/"},{"name":"federated Identities","slug":"federated-Identities","permalink":"http://blog.bglee.me/tags/federated-Identities/"}]},{"title":"✒️  Typora, 마크다운 에디터","slug":"typora","date":"2018-07-16T04:48:06.000Z","updated":"2018-07-19T09:31:34.616Z","comments":true,"path":"posts/2018/typora/","link":"","permalink":"http://blog.bglee.me/posts/2018/typora/","excerpt":"","text":"Typora, 마크다운 에디터 소개.Typora 를 주제로 Typora 를 사용하여 글 작성을 테스트 중이다. &#x1f408; 때문에 글 자체 보다는 이를 통해서 블로그 포스팅에 대한 생산성 검증 목적이 있다.마크다운 에디터 연대기사용하는 혹은 사용했었던 에디터들이다.에디터평ViM오픈소스, 지금도 간혹 쓴다. 한글 사용시 ViM 커맨드에 대한 고질적인 문제, 외부 프리뷰 이슈, 플러그인 설정 필요.Byword앱스토어 추천, 할인에 샀으나 특이점 없음.하루패드오픈소스, 독립 프로개름으로는 아마도 ViM을 지원하는 유일한 에디터가 아닐까한다. 국내 개발자이신 Rhio 님이 개발했다.VSCode오픈소스, 마소의 오픈소스 에디터, 마크다운을 기본적으로 지원.Webstorm개발 툴인데 붙어 있으니 가끔 README.md 작성용으로 사용MarkText오픈소스, 가장 최근에 사용했던 에디터, 테이블 삽입, 에디팅과 프리뷰가 함께 어우러진 것이 인상적.한동안 미디움에서 글을 쓰고 있었는데 Typora 라는 끝내주는 마크다운 에디터를 발견했다. 사실 본지는 좀 오래되었는데 최근에 쓰고 있던 마크다운 에디터가 만족스러워서 시도는 하지 않고 있다가 한글 타이핑시 문장 마지막에 Tab 입력시 글자가 사라지는 버그로 인해 고생해서 옮겨타게 되었다.Typora타이포라는 아직 베타 버전이며 곧 상용화 될 것으로 보인다. 안정적이며 별 버그가 없다. 테마도 다양하게 지원되고 있으며 마크다운을 통해 작성되며 글은 바로 테마가 입혀진 모습으로 보여진다. 프리뷰와 에디터가 빌트인 된 것으로 생각하면 된다.이모지(emoji)이모지를 훌륭하게 지원한다. 찾아볼 필요없이 : 를 입력하는 순간 자동 완성이 이미지와 함께 지원된다.테이블일반적인 에디터를 이용할 때 가장 문제가 되는 것은 테이블 작성이다. 테이블 작성 문법이 시간이 오래걸려 여기서 생산성에 대한 이슈가 생기는데 커맨드를 통해 빠르고 직관적으로 테이블 생성이 가능하다.이미지이미지 지원도 다소 짜증이 나는 영역인데, 블로그 글을 포스팅 할 때 이미지를 그냥 드래그해서 붙일 수 있다. 또한 그 것을 같은 폴더에 저장할 것인지 등도 정할 수 있으므로 사용성이 꽤나 최적화 되어있다.모자란 점정말로 쓸 수 있는 프로그램이 되려면 몇 가지를 개선한다. 아직은 만족하고 있으나, 사업 계획서와 같은 방대한 문서를 작성할때 이슈가 되는 것 들이 몇가지 있었다.실행 취소, 다시 실행(Undo, Redo)이 부분이 다소 불안정적이다. 한글 작성과 함께 꼬이는 이슈일 수 있다. 많은 글을 작성하면서 당연히 신뢰하고 있는 실행 취소와 같은 기능들이 방금 전 타이핑이 아닌 그 전에 타이핑한 글을 취소한다던지 하는 이슈가 있었다. 난 글을 작성할 때 단락의 위치를 괘나 바꾸는데 그래서 생기는 문제인지는 모르겟으나 실행 취소가 바로 전 타이핑에 대한 것이 아닌 경우가 존재했다.이는 꽤 치명적인 글로 그 취소를 내가 인지하지 못하는 경우가 있으면 글이 틀어져 버린다.일단 여기까지 작성후 퍼블리싱 테스트 &#x1f408;","categories":[],"tags":[{"name":"typora","slug":"typora","permalink":"http://blog.bglee.me/tags/typora/"},{"name":"markdown","slug":"markdown","permalink":"http://blog.bglee.me/tags/markdown/"},{"name":"editor","slug":"editor","permalink":"http://blog.bglee.me/tags/editor/"}]},{"title":"미디움으로 이사합니다.","slug":"move-to-medium","date":"2018-03-28T15:00:00.000Z","updated":"2018-03-29T06:41:17.921Z","comments":true,"path":"posts/2018/move-to-medium/","link":"","permalink":"http://blog.bglee.me/posts/2018/move-to-medium/","excerpt":"","text":"https://medium.com/@deptno으로 이사합니다.RSS: https://medium.com/feed/@deptno이 곳엔 가끔 업데이트나 더 개인적인 주제들을 담고자 합니다.","categories":[{"name":"service","slug":"service","permalink":"http://blog.bglee.me/categories/service/"}],"tags":[]},{"title":"Python","slug":"python","date":"2017-11-10T15:00:00.000Z","updated":"2018-03-29T06:03:19.631Z","comments":true,"path":"posts/2017/python/","link":"","permalink":"http://blog.bglee.me/posts/2017/python/","excerpt":"","text":"macOS 기반으로 작성되었다.ml(머신러닝) 공부를 하기 위해 파이썬을 환경을 설정했다.installationbrew는 기본적으로 설치되어 있어야 한다. 참조설치 각각에 종속성이 있을 수 있으므로 패키지 설치시마다 터미널을 재시작하면서 하도록 한다.아나콘다라는 파이썬 배포판으로 데이터 사이언스 관련 패키지들을 포함하고 있다. 보통 책들에서 강력히 추천하므로 설치한다. 파이썬 배포판이므로 글을 쓰는 현재 python 3.6.3을 포함하여 설치된다.1brew cask install anaconda프로젝트별 독립된 개발 환경을 만들어주는 virtualenv와 이를 편하게 사용하도록 해주는 virtualenvwrapper를 설치한다.1pip install virtualenv virtualenvwrapper사용하는 쉘의 설정 파일을 열어 다음을 추가한다. 설정 파일을 쉘에 따라 다르다.~/.zshrc or ~/.bashrc1234# python virtualenv settingsexport WORKON_HOME=~/workspace/virtualenvsexport VIRTUALENVWRAPPER_PYTHON=/usr/local/anaconda3/bin/pythonsource /usr/local/anaconda3/bin/virtualenvwrapper.sh~/workspace/virtualenvs 이 부분은 사람마다 다른 경로를 사용하므로 사용하고자 하는 경로를 쓰면된다. 설정파일이 적용되기 전에(터미널 재시작 전) 폴더를 만들어준다.1mkdir -p ~/workspace/virtualenvs터미널을 재시작하면 스크립트가 돌고 아래와 같은 명령어를 사용할 수 있게된다.mkvirtualenv 프로젝트명rmvirtualenv 프로젝트명workon 프로젝트명deactivateml이라는 가상황경을 위한 라이프 사이클은 아래와 같다.12345678910# 가상환경를 생성한다.bglee@since-20171107  mkvirtualenv ml# 가상환경를 종료한다.(ml) bglee@since-20171107  deactivate# 가상환경에 진입한다.bglee@since-20171107  workon ml# 가상환경를 종료한다.(ml) bglee@since-20171107  deactivate# 가상환경를 삭제한다.bglee@since-20171107  rmvirtualenv ml이제 가상환경은 설정이 되었고 프로젝트를 활성화(진입)한 상태로 pip install package_name을 할 경우 가상환경에 패키지가 포함되게 된다.","categories":[{"name":"service","slug":"service","permalink":"http://blog.bglee.me/categories/service/"}],"tags":[{"name":"python","slug":"python","permalink":"http://blog.bglee.me/tags/python/"},{"name":"파이썬","slug":"파이썬","permalink":"http://blog.bglee.me/tags/파이썬/"},{"name":"ml","slug":"ml","permalink":"http://blog.bglee.me/tags/ml/"},{"name":"머신러닝","slug":"머신러닝","permalink":"http://blog.bglee.me/tags/머신러닝/"},{"name":"anaconda","slug":"anaconda","permalink":"http://blog.bglee.me/tags/anaconda/"},{"name":"아나콘다","slug":"아나콘다","permalink":"http://blog.bglee.me/tags/아나콘다/"},{"name":"virtualenv","slug":"virtualenv","permalink":"http://blog.bglee.me/tags/virtualenv/"},{"name":"virtualenvwrapper","slug":"virtualenvwrapper","permalink":"http://blog.bglee.me/tags/virtualenvwrapper/"}]},{"title":"Netlify","slug":"netlify","date":"2017-10-03T15:00:00.000Z","updated":"2018-03-29T06:03:19.627Z","comments":true,"path":"posts/2017/netlify/","link":"","permalink":"http://blog.bglee.me/posts/2017/netlify/","excerpt":"","text":"Netlify 는 스태틱 웹을 위한 CMS다. Git 서비스들을 통해 제공되며 레포지터리에 푸시를 할 경우 이를 자동으로 감지하고 빌드하며 재 배포한다. 여기에 본인이 도메인을 가진게 있다라면 본인의 도메인을 연결하여 서비스 할 수 있다.스태틱웹은 동적으로 URL을 생성하는 것이 아닌 그냥 실제 html파일 자체로 서빙을 한다고 생각하면 단순하다.Netlify 는 추가적으로 Let’s encrypt 를 서비스 안으로 포함시켜서 SSL(https://) 을 지원하며 이를 위해 DNS를 품고 있다. 자동으로 지원되지만 자신만의 도메인이 있어 이를 사용할 때는 Netlify DNS를 사용해야한다.이번 &lt;bglee.me&gt;의 DNS를 Netlify 로 옮기면서 모든 페이지에 SSL을 적용하고 기존 블로그는 https://deptno.github.io로 되돌려 하나의 루트로 접근 경로를 통일했으며 기존 https://blog.bglee.me는 이제 SSL을 적용하고 기존 패스 그대로 https://deptno.github.io로 리다이렉트 시키도록 세팅했다. 이를 세팅 과정은 로컬 환경이 아닌 깃헙 레포지터리를 이용할 정도로 단순했고 Netlify 에서 지원하는 리다이렉트 옵션도 매우 직관적이었다.1배포글을 작성하고 있는 현재 Netlify 에서 지원하고 있는 Git 클라우드 서비스는 아래와 같다.GitubGitlabBitbucket잠깐 부연하자면 비공개 레포지터리를 만들기 위해서 Github은 유로 플랜을 써야하지만 나머지 둘은 기본적으로 비공개 레포지터리를 개인에게 무료로 허용한다.로그인하면 바로 사용을 위한 화면이 시작되며 순서는 아래와 같다.사용하고 있는 레포지터리 서비스를 선택한다.(Git 클라우드 서비스들)배포에 사용될 레포지터리를 선택한다.배포에 사용될 브랜치, 빌드시 명령어, 그리고 빌드 명령어를 통해 생성된 배포될 파일들을 가리키는 디렉토리를 작성한다.그럼 바로 배포가 시작되며 앞으로 레포지터리에 푸시를 할 때마다 자동으로 빌드 =&gt; 배포가 진행된다.커스텀 도메인과 DNS커스텀 도메인을 을 사용하기 위해서는 domain settings에 들어가서 custom domain을 누르고 본인의 도메인을 입력해야한다. 도메인 셋업은 www.YOUR_DOMAIN을 통해야 SSL서비스를 받을 수 있다.예를 들어 필자는 www.bglee.me를 입력하고 HTTPS 에서 주소를 확인한뒤에 Force TLS connections를 활성화 시켜 http접속을 https로 강제 리다이렉트 시켰다.Netflify 에서는 bglee.me가 아닌 www.bglee.me를 등록하라고 권고하고 있으며 www.bglee.me를 등록시에 bglee.me도 자동으로 Netlify에 의해 등록되며 &lt;bglee.me&gt; 접속시 &lt;www.bglee.me&gt;로 강제 리다이렉트된다.추가적인 기능와… 한 기능들을 몇개 지원한다.브랜치를 통한 A/B 테스트 지원브랜치를 추가적으로 등록할 수 있는데(A/B테스트 메뉴) 자동으로 로드밸런싱을 해서 A/B테스트를 하게 해준다.PR시, 스테이지 URLPR이 왔을시 이에대한 Preview URL을 생성할 수 있으며 이를 스테이지로 활용할 수 있다.next이제 스태틱 사이트를 작성하고 배포해보자.","categories":[{"name":"service","slug":"service","permalink":"http://blog.bglee.me/categories/service/"}],"tags":[{"name":"netlify","slug":"netlify","permalink":"http://blog.bglee.me/tags/netlify/"},{"name":"https","slug":"https","permalink":"http://blog.bglee.me/tags/https/"},{"name":"ssl","slug":"ssl","permalink":"http://blog.bglee.me/tags/ssl/"},{"name":"스태틱 웹","slug":"스태틱-웹","permalink":"http://blog.bglee.me/tags/스태틱-웹/"},{"name":"static web","slug":"static-web","permalink":"http://blog.bglee.me/tags/static-web/"}]},{"title":"TypeScript와 Redux connect","slug":"typescript-redux-connect","date":"2017-10-02T15:00:00.000Z","updated":"2018-03-29T06:03:19.633Z","comments":true,"path":"posts/2017/typescript-redux-connect/","link":"","permalink":"http://blog.bglee.me/posts/2017/typescript-redux-connect/","excerpt":"","text":"타입스크립트와 리덕스로 SPA를 구현하는데 있어 기본적인 셋업이 아닌 문법적인 측면에 포커싱된 글로 타입스크립트를 활용하는데 도움이 되었으면한다.필자는 하드 타이핑을 하지 않으며 추가적으로 린트를 쓰지 않는다. 리덕스는 자체적으로 타입스크립트 데피니션 파일(d.ts)을 가지고 있으므로 따로 타입 관련 패키지를 설치하지 않아도 된다.설치12npm install --save-dev typescriptnpm install reduxredux리덕스에 대한 설명을 돕기 위해 루트 스토어가 가지는 스테이트의 타입을 아래와 같이 정의하기로한다.123456789//index.d.tsinterface RootState &#123; bglee: User deptno: User&#125;interface User &#123; name: string email: string&#125;connect(..args)리덕스를 쓰면서 가장 많이 쓰게 되는 함수일텐데 코드를 먼저 보이면 아래와 같다.12345678910111213141516171819import * as React from 'react'import &#123;connect, bindActionCreataors&#125; from 'redux'interface StateProps &#123;&#125;interface DispatchProps &#123;&#125;interface OwnProps &#123;&#125;type Props = StateProps &amp; DispatchProps &amp; OwnPropsinterface State &#123;&#125;const Container = connect&lt;StateProps, DispatchProps, OwnProps&gt;( (state: RootState) =&gt; (&#123;&#125;), dispatach =&gt; bindActionCreators(&#123;&#125;, dispatch))( class Component extends React.Component&lt;Props, State&gt; &#123; render() &#123; return &lt;p&gt;hello world&lt;/p&gt; &#125; &#125;)위 코드는 완전히 동작하는 코드이고 컨테이너를 정의하기 위해 풀어쓴 기본적인 형태다. 참고로 connect 함수는 추가적인 옵션을 기술하기 위해 4개까지 인자를 받을 수 있다.connect를 보면 3개의 타입을 받고 있다. 순서대로 살펴 보겠다.StatePropsconnect의 첫번째 인자는 mapStateToProps로 정의되어 있으며 함수 명과 같이 Store의 state를 Component의 props로 주입하는 함수다. 이 함수의 리턴 타입이라고 생각하면 된다.예를 들어 Store에 bglee라는 프로퍼티를 연결하고자 한다면 mapStateToProps는 아마도 다음과 같이 작성되게 된다.1const mapStaetToProps = (state: RootState) =&gt; state.bglee그러면 Container는 props로 bglee가 가지고 있는 name, email을 받게 된다. 그럼 그에 맞춰서 StateProps를 정의하면 된다.1234interface StateProps &#123; name: string email: string&#125;작성하고 보니 User 타입과 동일하다.1type StateProps = User로 정의해도되고 코드에서 StateProps를 User로 치환해도 된다. 이 경우는 예제를 위해 특수한 케이스기 때문에 이러하지만 여러 state를 props로 연결해야한다라면 곧 확장을 해야하니 StateProps라는 이름의 컨벤션을 유지해서 코드 일관성, 가독성을 확보하자.다시 mapStateToProps 함수를 구현한 코드를 보면 아래와 같이 보일 것이 의심치 않는다.1234const mapStaetToProps = (state: RootState): StateProps =&gt; (&#123; name: state.name, email: state.email&#125;)이해를 돕기 위해 완전히 풀어서 보였다. StateProps가 리턴되고 있다는 것만 인지하고 있으면 되며 위와 같은 코드작성은 connect가 타입을 받는 이유와 상충되므로 줄여서 작성하도록 하자.DispatchProps두번째 인자는 dispatch할 액션들이 Component의 props로 매핑된다. 위와 마찬가지로 두번째 인자의 이름인 mapDispatchToProps의 리턴 타입이다.완벽한 이해를 위해 아래와 같이 액션이 정의해보자.123456const contactBglee = (from: string) =&gt; (&#123; type: 'CONTACT_BGLEE' payload: &#123; from &#125;&#125;)액션은 type을 포함하는 오브젝트를 리턴하는 함수이며 bindActionCreators함수를 통해 dispatch가능한 형태가 된다.그럼 두번째 인자의 구현부를 다시 보자.1dispatch = bindActionCreators(&#123;&#125;, dispatch)이름을 달고 정의한 액션을 바인딩해보자123const mapDispatchToProps = dispatch =&gt; bindActionCreators(&#123; contactBglee&#125;)작성된 mapDispatchToProps함수를 두번째 인자로 전달하게 되며 Container는 contactBglee액션을 디스패칭할 수 있다. Container는 contactBglee props를 가지고 있다는 의미며 이를 컴파일러에게 알려주기위해 두번째 DispatchProps는 아래와 같이 정의된다.123interface Dispatchprops &#123; contactBglee: typeof contactBglee&#125;typeof를 유심히 보자 contactBglee의 액션이 from: string인자를 취하는데 이를 재 다시 정의하는 것이아니라 기존 정의로부터 타입을 가지고 와서 추가해준다. 따라서 우린 중복정의 없이 기존 정의를 typeof 키워드를 통해서 쓸 수 있다.OwnProps마지막 타입은 기존 우리가 컴포넌트를 정의할 때 받는 부모로 부터 받게되는 그 인자를 정의하면 된다. 컴포넌트를 컨테이너로 변경하는 경우라면 기존 컴포넌트의 인자가 OwnProps로 변경된다.개인적으로 수없이 정의하게 되는 이런 타입과 함수들이 매우 반복적이기 때문에 mapStateToProps와 같은 함수를 정의하는 대신 inline으로 삽입하는 것을 선호하며 위에 설명한 것들을 함쳐 결과를 보면 아래와 같다.1234567891011121314151617181920212223242526import * as React from 'react'import &#123;connect, bindActionCreataors&#125; from 'redux'import &#123;contactBglee&#125; from './actions' // 액션이 존재하는 곳interface StateProps extends User &#123;&#125; // type으로 정의도 가능하다interface DispatchProps &#123; contactBglee: typeof contactBglee&#125;interface OwnProps &#123;&#125;type Props = StateProps &amp; DispatchProps &amp; OwnPropsinterface State &#123;&#125;const Container = connect&lt;StateProps, DispatchProps, OwnProps&gt;( (state: RootState) =&gt; (&#123; ...state.bglee &#125;), dispatach =&gt; bindActionCreators(&#123; contactBglee &#125;, dispatch))( class Component extends React.Component&lt;Props, State&gt; &#123; render() &#123; return &lt;p&gt;hello world&lt;/p&gt; &#125; &#125;)next이제 render()함수 안에서 this.props 그리고 .을 찍어보자.","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"ts","slug":"dev/ts","permalink":"http://blog.bglee.me/categories/dev/ts/"}],"tags":[]},{"title":"Next.js","slug":"next-js","date":"2017-05-07T15:00:00.000Z","updated":"2018-03-29T06:03:19.630Z","comments":true,"path":"posts/2017/next-js/","link":"","permalink":"http://blog.bglee.me/posts/2017/next-js/","excerpt":"","text":"Next.js현재 회사의 고객사이트를 next.js와 typescript 기반으로 2017-04-10 일 기준으로 배포되었다. 간단하게 소개를 하고자 한다.next.jsnext.js는 node.js, react기반의 유니버살 렌더링을 지원하는 프레임웍이다. 첫 접속시에는 서버로부터 첫 페이지를 구동하기 위한 청크를 가져가게되며 한번 접속한 페이지에 대해서는 데이터 청크가 있으므로 SPA와 같이 동작하게 된다.라우팅라우팅은 기본설정으로 pages/ 디렉토리가 루트가 된다. 기본 라우팅은 index.html에 매칭되는 index.js가 된다.디렉토리 구조가 그대로 서비스 라우팅에 매칭되기 때문에 특별히 할 일이 없어서 빠른 속도로 개발을 시작할 수 있다.그럼 html에 해당하는 template은 어디서 제어하는가?pages/_document.js_document.js는 index.html의 템플릿에 해당하는 정보를 내려주는 리엑트 컴포넌트로 시그니쳐가 React.Component의 상속이 아닌 next/document 패키지의 Document 컴포넌트를 상속해서 만들게 된다. 자세한건 문서를 참조한다.pages/_error.jsSSR이 지원되기때문에 데이터를 서버에서 미리 패칭하여 내릴 수 있다. 이런 경우를 포함해서 예외처리가 제대로 되지 않은 경우 500에러를 내리게 되는데 그에 대한 에러 status를 받아 그에 맞는 화면을 내릴 수 있다. _document.js와는 달리 React.Component를 상속한다.apinext.js에서는 리액트 컴포넌트를 내릴때 특수한 static 메서드를 정의할 수 있는데 이 함수는 서버와 클라이언트 모두에서 사용되며 서버일 경우와 클라이언트일 경우에 대한 분기를 여기서 정할 수 있다. 이를 통해서 서버인 경우에 대한 처리, 클라이언트에 대한 처리를 추가할 수 있다.getInitialProps()12345678910111213141516171819202122232425262728293031323334export default class Index extends React.Component&lt;null, null&gt; &#123; private store: Store&lt;RSquareStore&gt;; static async getInitialProps(&#123;req&#125;) &#123; const server = !!req; const store = await storeCreator(reducer, null, server); try &#123; await store.dispatch(getCatalogue()); &#125; catch(ex) &#123;&#125; const initialState = store.getState(); return &#123;initialState, server, catalogue: initialState.themes.catalogue&#125;; &#125; constructor(props) &#123; super(props); this.store = storeCreator(reducer, props.initialState, props.server); &#125; render() &#123; return ( &lt;Provider store=&#123;this.store&#125;&gt; &lt;Layout&gt; &lt;Head&gt; &lt;title&gt;&#123;`SEO_TEXT`&#125;&lt;/title&gt; &lt;/Head&gt; &lt;Home catalogue=&#123;this.props.catalogue&#125;/&gt; &lt;/Layout&gt; &lt;/Provider&gt; ); &#125;&#125;단순한 구현은 위와 같다. 구조에는 redux가 쓰였으며 이를 위해 스토어를 생성해서 내리고 있는 걸 볼 수 있다. &lt;Head&gt;컴포넌트도 보이는데 helmet 역할로 헤더쪽으로 자식 태그들을 펌핑해준다. 동적으로 바껴야하는 메타태그들을 여기서 처리하면 된다.pros라우팅이 정형화된 디렉토리 구조로 되어 있기 때문에 직관적이다.API가 적다.유니버설 렌더링의 지원한다.cons표준으로 자리잡았다 싶은 기존의 리액트용 라이브러리들과 함께 사용하려면 커스텀 셋업이 필요하다.###","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"js","slug":"dev/js","permalink":"http://blog.bglee.me/categories/dev/js/"}],"tags":[]},{"title":"Texts 구현","slug":"texts","date":"2017-05-07T15:00:00.000Z","updated":"2018-03-29T06:03:19.633Z","comments":true,"path":"posts/2017/texts/","link":"","permalink":"http://blog.bglee.me/posts/2017/texts/","excerpt":"","text":"구현기획자 디자이너, 퍼블리셔와의 협업시 문구 변경으로 인한 피로를 덜기 위해 ID기반의 문구 관리를 앱동기부동산 계열에서 일을 하다보니 너무많은 term이 존재한다.사소한 문구 변경이 데일리로 일어난다.퍼블리셔 쪽에서도 html에 대한 이력관리를 원한다.문구 변경과 markup의 변경이 구분되지 않는다.react로 퍼블리싱하지 않는 이상 태그를 그대로 사용하지 못하므로 daily diff이슈가 존재한다.여러 곳에서 동일하게 쓰이는 문구 변경이 일어난 경우 diff에 혼란이 있다.개발일단 퍼블리셔 쪽에서 ID를 사용하용하여 퍼블리싱 할 수 있게 끔 하는 것을 최우선으로 했다.독립적으로 사용할 수 있도록 serverless를 통해 DB까지 한번에 deploy한다.backend 엔드포인트만 사용자 별로 바꾸면 되니까 fe는 직접 만들어서 배포했다. Texts운영기획(스트링 관리 주체)https://texts.surge.sh?endpoint=https://[BACKEND_ENDPOINT] 접속스트링 마음껏 만들고 잘 됬으면 deploy한다.퍼블리셔퍼블리셔 쪽에서는 &lt;div data-text-id=&quot;TEXT_ID&quot;/&gt;와 같은 형식으로 퍼블리싱을 할 수 있게한다.퍼블리셔는 눈으로 이를 확인할 수 있어야하므로 이를 치환해주는 태그를 서비스해준다. Texts Translator퍼블리셔가 동적인 동작을 위해 jQuery태그를 심듯이 심어주면 동적으로 확인이 가능해준다.개발개발 버전에서는 퍼블리셔와 같이 태그를 심어서 스트링 관리주체가 변경하는 것을 즉각적으로 확인할 수 있게끔 한다.프로덕션 릴리즈시에 아래 형식으로 저장해서 CI빌드시에 넣으면된다.1$ http post https://[END_POINT]/json &gt; language_ko.jsontodos퍼블리셔쪽에 구문 변경으로 인한 스트레스에서 벗어나고 싶지않냐고 설득한다.기획자분이 스트링을 관리할 수 있도록 제안하고 설득한다.히스토리표준을 이용할 수 있게 끔 Intl을 붙이려고 디자이너쪽에서 태그를 어떻게 사용하게 해야할지 감이 오지 않아 뒤로 미뤘다.장점퍼블에서도 모델을 분리한다.모델, 디자인, 컨트롤의 물리적인 관리주체(부서)가 명확해 진다.단점서비스가 아니라 aws 설치 형태라 결국 나만의…","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"js","slug":"dev/js","permalink":"http://blog.bglee.me/categories/dev/js/"}],"tags":[]},{"title":"yarn","slug":"yarn","date":"2016-12-11T15:00:00.000Z","updated":"2018-03-29T06:03:19.634Z","comments":true,"path":"posts/2016/yarn/","link":"","permalink":"http://blog.bglee.me/posts/2016/yarn/","excerpt":"","text":"yarn은 동시 다운로드를 지원하는 npm이라고 보면된다. 디펜던시 트리를 저장하고 있어서 빠르게 인스톨을 하므로 CI등에서 위력을 발휘한다.기본 지식은 문서를 참고하면 된다.yarn global add [package] 커맨드를 통해 인스톨을 한 경우 npm과 달리 실행이 안되는 문제가 있다.123456789101112131415&gt; yarn global add typescriptyarn global v0.17.8warning No license field[1/4] 🔍 Resolving packages...[2/4] 🚚 Fetching packages...[3/4] 🔗 Linking dependencies...[4/4] 📃 Building fresh packages...success Installed typescript@2.1.4 with binaries: - tsc - tsserverwarning No license field✨ Done in 1.56s.&gt; tsczsh: command not found: tscbash 를 이용하고 있다면 될 수도 있을 것 같은데 필자와 같이 zsh를 사용하고 있다면 아래와 같이 한줄을 추가해자.1&gt; echo \"export PATH=\\$PATH:`yarn global bin`\" &gt;&gt; ~/.zshrc이후 실행12&gt; tsc -vVersion 2.1.4npm을 통해서도 인스톨을 했다라면 패스 문제로 버전 문제가 생길 수 있으니 둘중 하나만 사용하자.2016-12-26 추가brew를 통해 yarn을 설치한 경우 위 방법으로는 yarn global add [package]로 추가한 모듈이 동작을 안한다. npm global, yarn global, brew가 꼬여서 생기는 문제일 것 같은데 일단 해결책은 brew를 통해서 설치했다면 다시 아래를 추가로 입력해주면 된다.1&gt; echo \"export PATH=\"$PATH:$HOME/.config/yarn/global/node_modules/.bin\"","categories":[{"name":"setup","slug":"setup","permalink":"http://blog.bglee.me/categories/setup/"},{"name":"js","slug":"setup/js","permalink":"http://blog.bglee.me/categories/setup/js/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://blog.bglee.me/tags/npm/"},{"name":"yarn","slug":"yarn","permalink":"http://blog.bglee.me/tags/yarn/"}]},{"title":"W3C HTML5 Conference 2016","slug":"w3c-html5-conference-2016","date":"2016-12-07T12:10:13.000Z","updated":"2018-07-16T06:10:14.940Z","comments":true,"path":"posts/2016/w3c-html5-conference-2016/","link":"","permalink":"http://blog.bglee.me/posts/2016/w3c-html5-conference-2016/","excerpt":"","text":"개인 정리키노트 1(박종목)웹의 발전스태틱 웹웹 2.0(ajax) - symbolic boomread, write web(muchine to muchine), 스맨틱 웹(figure, article, header tag), 웹 3.0네이버의 인공지능 사례들페이지랭킹은 오래됬고 머신러닝으로 랭킹 먹인다.지식 쇼핑 40억개 상품, 4000카테고리가 있어서 딥러닝을 통해 자동분류한다.위치 기반 검색 지역의 특성등을 인공지능으로 추출한다.전주 한옥마을에 대한 블로그 데이터의 자연어를 분석해서 전주 한옥마을에 대한 특성들을 분석함(크롤링과는 좀 다름)Context-aware analysis based on charateristics of loacation해시 태그화 등이미지 검색시의 정렬등상품검색의 스타일 서치(유사 상품) topic model을 추출한다.인식기술이 많이 발전함머신러닝을 하면서 인식률이 85% =&gt; 95%로 증대음석 합성도 지원함(사전, 뉴스 읽기, 라인 사전)기계번역(통계기반 번역) =&gt; 머신러닝(뉴런) 투입하면서 번역률이 2배정도됌amica.ai, 12초 whale browser는 파파고 엔진으로 웹페이지 번역 지원됨사용자와의 인터렉션은 음성기반으로 바뀔꺼다.(시리 등등)챗봇(사용자들은 메시징하는데 더 많은 시간을 쓴다(웹은 20%정도)) - 페이스북자율주행(아직은 연관성 별로 없음)스마트 홈(IoT)로봇관련된 웹 표준Voice XML시맨틱 웹(3.0에서 실패했던 것이 지금)이에 대한 안좋은 시각(생각)웹표준이 아닌, 애플, 구글, 페이스북등이 사실상 리딩산업에 변화에 비해 웹 표준은 느리다는게 걸림태생이 다큐먼트 컨셉Web의 Next?IoT키노트 2(김국현)IT 세대론…코볼은 | C, C++에Java(자바는 코볼을 품음) | JS에 막히고 3세대로 가고 있다.특이사항 없음@goodhyun패널토의웹이 다큐먼트인가? 거의 UI로 사용된다. 그러면 모델이 다큐먼트인게 맞는가1조개의 센서, 세금을 블록체인으로 걷는다.서로 다른얘기 함.. 여튼 지금 혁명중Q: 네이버 브라우저 왜 만드셨어요?A: 사용성이 안좋다. 선두업계 주자라 인터넷 환경 자체를 개선하겠다.Q: 삼성도 MS따라서 오픈소스하나?A: 변명함, artik이라는 보드도 오픈소스로 내놓음 ecma준수하는 jscript 만듬(40k정도)Q: 웹이 성숙된 표준을 가지고 잘 따라고 있는가?A: 웹 !== 웹브라우저, 칩에도 js call이 들어간다. 쉐이딩 영역도 js가 먹을꺼같다. iot도 먹고있다. 웹을 구성하는 기술들로 간다.Q: JS로 IoT하는데 이게 웹인가?A:웹이라고 하는듯 의견이 갈림스펙은 잘 따라가지 못하기 때문에 프레임웍에서 많은 일들을 해야하며 리액트를 디펙토로 가던지 등등 맞다고 생각되는 것을 밀어야한다.웹의 기본 철학은 탐험과 연결이다.Q: 4차 산업 혁명 준비 예산은? 내년A: 주용환40억 규모: 엑티브엑스 개선, 웹 표준 확산기업지원은 웹이 새롭게 쓰이는 서비스에 지원하려함 올해 2억 수준이었는데 10억 이상 수준으로 편성하려함, VR등 국내사례가 별로 없음.빅테이터, 인공지능 이쪽이 지원 받을게 많다.Q: 뉴런번역 API 제공 계획 없나A: 모른다 ㅠㅠ트랙 BSecond Screen &amp; WebRTCWebRCT 표준 현재와 미래최진호 - REMOTE MONSTER페이스 챗 카카오톡 슬랙, 아마존 등등에서 다 사용이나 아직 Draft단계이며 5년정도밖에 되지 않는다.전화기 오픈소스라고 생각하면 이해하기 빠르며 표준화를 진행중이다.(구글이)P2P지만 서버(시그널 서버)는 필요하다.토폴로지 구성 및 브로드캐스팅이 가능APIgetUserMediaRTCPeerConnectionRTCDataChannel표준화된 프레임웍이 없다.네트워크 및 안드로이드 파편화에 따라 성능차이가 많이 난다.UDP를 사용그럼에도 불구하고커뮤니티가 강하다. https://www.facebook.com/groups/rtc.koreaWebRTC PaaS도 존재한다.1200+ 서비스, 브라우저들이 지원함, 3.1조억+ 기업 인수, 투자 규모엔지니어 구하기가 힘들어서 인수할 정도로 귀족 개발자17년 1Q Recommandation 예정엣지도 지원, 애플도 지원 예정 (H.264)크롬 55에 RTC관련 업데이트가 대거용량이 크기때문에 IoT에 대응하기에는 쉽지않지만 빌드 잘하면된다..AR, VR에 유용할 것으로 예상된다.Google Duo = WebRTC + QUIC 빠른 서비스.통신, 방송, IoT분야에서 활약할 것으로 기대된다.WebRCT 서비스 개발사례와 시사점이랑혁 - 구루미HLS보다 딜레이가 적다. RTSP, RTMP, HLS 가능일반전화 연결이 가능하다(?)협업 &gt; 교육 &gt; 상담(의료) &gt; 관제 등 순으로 비지니스 니즈가 있었음WinXP, IE 이슈 해결일렉트론세계적으론 20%대이니 기다려라(국내는 70%이상)아니면 앱 만들어서 배포해라기회크롬 기반 브라우저 확산(웨일 브라우저)에코 확장대기업의 신규 서비스교육 및 의료 부문 전환중(정부 3.0)ActiveX 제거Second Screen과 웹 커넥티비티송효진 - LG전자다른 기기로 화면이나 앱을 보내서 실행하는 것커넥티비티네트워크를 통해 떨어진 두 지점을 연결ECMAW3CIETF(L3)IEEE(L2)IETFHTTP/2(One TCP Connection)QUIC(based on UDP)IPv6IPv6 over Bluetooth/NFC(IOT 기반으로 이터넷이아닌디바이스에서 가능)ApplicationW3C Presentation APIW3C Remote Playback APIUnderlying ProtocolSSDP, mDLS기대교육 분야전광판(QR 대체)FlyWeb Project웹페이지가 서버를 구동하고 디바이스가 여기에 접속 가능웹고속화AMP(Accelerated Mobile Pages)는 어떻게 빠른 성능을 내는가?김태훈 - 네이버 http://facebook.com/groups/webfrontend구글 라이브러리다. amp.js 다른거 할필요없이 가이드를 따르면 된다.인스턴스 로딩이 가능하다.커스텀 엘리먼트 기반이다.url + #development=1 를 사용하면 에러 뿜어준다.amp.js는 외부 js를 허용하지 않는다.AMP Cache - 구글이 CDN 으로 다 뿌려준다.HTML &lt;=&gt; AMP-HTML 페어로 구성 또는 AMP-HTML 온리슬랙등에 링크걸면 AMP로딩해준다.amp 컴포넌트를 사용해서 리소스를 로딩하게되면 뷰포트에 보이는 시점에 레이지로딩한다.크로스 브라우징 해결해준다.속도는 엄청 좋다는 말로 부족하다.https만 가능하다(video)커스텀 js를 사용하지 못하는 치명적인 단점이있어서 이벤트 페이지 같은 경우에 적합할 것으로 보임.특징비동기 스크립트만 로딩 허용모든 리소스의 사이즈 지정확장 컴포넌트들이 렌더링 차단 없이 실행한다.써드 파티 자바스크립트 크리티컬 패스에서 제거?(CSS관련)웹폰트 효율적으로 허용GPU 가속 애니메이션으로만 제한됨(레이아웃 변경 CSS는 막힌다)(css triggers 참조)리소스 로딩 순서 제어(뷰포트에 의해)페이지 즉시 로드리플로우 최적화스타일 변경 작업을 배치작업을 통해서 최적화한다(코드 붙여서 작성하면됌)6억+ 페이지가 700k+ 사이트가 작성되었다.커스텀 엘리먼트를 사용해서 라이프 사이클을 제어한다(이를 통해 뷰포트안에 있을때만 로딩등 처리)프로그레시브 웹앱(PWA)송정기 - 삼성전자모바일 웹사이트장점URL, 연결성, 빠른 배포(URL &gt; store)표준 기반 다양한, 폭넓은 기기 지원단점Native 대비 떨어지는 UX성능기능Manifest + Service Worker + Pushhttps://whatwebcando.todayPWA - 홈스크린 인스톨레이션, 오프라인 모드, 푸시 메시지머무는 시간이 3배 증가40% 더 재접속70% 홈스크린을 통해 들어오는 유저가 구매할 확률이 더 높다3X 데이터를 덜 사용한다PWA List 앱 참조PWA를 구성하는 표준 기술Web App Manifest네이티브와 동일한 앱 접근성을 제공한다. 크롬, 오페라, 삼성 브라우저, 사파리메니페스트가 추가됏을때는 브라우저에서 탭했을때 메뉴가 다르게 뜬다.홈화면에 인스톨레이션을 지원하는 로직은 아직 사파리가 지원하지 않는다. 인스톨레이션 팝업은 브라우저별 휴리스틱 알고리즘을 통해 제공된다.http://pwa.rocksPWA indication의 조건https://Service workerWebApp Manifesttheme_color를 통해 상태바 색도 바꿀 수 있다.display를 통해 풀사이즈 앱으로 띄울 수 있다.Splash screen - 크롬이 들고나오고 삼성 인터넷도 탑재 예정, 로딩 전 앱 로딩 화면처럼 만들어준다.Service Worker오프라인 우선, 백그라운드 처리이벤트마다 워커가 종료된다. 웹 워커와는 다르다. 실 브라우저 구현(크로미움 기준) 2-30초는 살아있다.1234567const navigator.serviceWorker;sw.register(scriptURL, &#123;scope: scopeURL&#125;);;;oninstall = e =&gt; &#123; /* pre-cache here */ &#125;;onfetch = e =&gt; &#123; /* respond with magic */ &#125;;onactivate = e =&gt; &#123; /* Deleting cache is on you * &#125;; // 서비스 워커 버전이 변경됐을때registration.update(); // 강제 업데이트SW의 이벤트가 가지고 있는 watUntil 메서드를 통해 SW가 죽는 것을 방지할 수 있다.캐시에 애드하는 형식 캐시에 매칭되지 않으면 거기서 fetch한다.Service Worekr Cookbook 찾아볼 것 https://jakearchibald.comPush API푸시의 효과는 검증됨.필수요소Background Service (Service Worker)Push 등록/해지/이벤트 (Push API)push이벤트를 받아서 캐싱에 저장하고 노티피케이션을 띄움 띄운 후에는 클릭 이벤트를 받아 그에 따른 처리.https://medium.com/samsung-internet-dev삼성 인터넷 베타 프로그램 신청 https://goo.gl/1yFP1LWeb 엔진Naver Webkit - Sling Project 소개 및 오픈소스김준걸 - 네이버 랩스슬링 4년 6개월 작업했고 오늘 깃헙에 오픈했다.애플의 웹킷에서 forkwin/android 지원JS엔진 - JSC vs V8(과할 수록 유리 V8, 실사용에선 JSC, 슬링은 JSC)리소스가 부족해서 안드로이드로 개발 =&gt; 스크립팅 =&gt; C++ 소스 제네레이팅(android pp, github 참조)크로미움 네트워크 성능이 뛰어남GFX Tool for Sling 이라는 디버깅 툴 만들어서 그걸로 선검증 후포팅WebExtensions API가 400개 정도 되서 아직 다 지원은 못함Chrome Dev Summit 2016 참관기김지한 - 네이버 랩스PWA 포커싱AMP to PWA매 단계마다 20%의 사용자가 떨어져나간다.(설치나, 가입 등등 모두)3G 기준으로 5초 이내에 인터렉션이 가능해야한다.홈 화면에 추가된 사이트는 4배 더 많이 방문한다(알리바바, 2016)PRPL pattern - Push, render, Pre-cache, Lazy-load&lt;link rel=&quot;preload&quot;/&gt;크롬 51+, 오페라 41+, 안드로이드 5+https://www.flipkart.com PWA의 정석https://www.housing.com 부동산 체크Crediential APInavigator.credentials 인증을 브라우저에 던진다.Web Payment API브라우저에 결재 던짐Debugging the Web크롬개발자도구Lighthouse 익스텐션(PWA)결론PWA의 핵심 - 오프라인 지원, 로딩 성능 향상Lyft등 선행 사업자들도 이머징 마켓 중심으로 적용 중로그인, 결재 등이 브라우저로 이동(크롬, 안드로이드), 이에 대한 강력한 지원HTML5기반 웹앱 그리고 다가올 HTTP / 2커넥션 제약으로 이미지 등을 로딩할때image spritelocal cache&lt;link rel=&quot;prefetch&quot; href=&quot;image.png&quot;/&gt;domain lookup, x-dns-prefetch-control, preconnectminifyprerenderpreresolvegoogle에서 instant page 검색HTTP2바이너리 기반 프로토콜헤더 압축멀티플렉스 스트림(프로세스, 쓰레드 같은 개념)스트림 프라이어티티(리소스 의존성 지정가능)서버 푸쉬1.1 에선 핑퐁 치던걸 2에선 한방에 내림APMhttps://ampproject.org + PWA포커싱이 HTTP2가 아니라 아쉬움","categories":[{"name":"summary","slug":"summary","permalink":"http://blog.bglee.me/categories/summary/"}],"tags":[{"name":"pwa","slug":"pwa","permalink":"http://blog.bglee.me/tags/pwa/"},{"name":"amp","slug":"amp","permalink":"http://blog.bglee.me/tags/amp/"}]},{"title":"2016년 12월","slug":"2016-12","date":"2016-12-04T10:58:37.000Z","updated":"2018-03-29T06:03:19.620Z","comments":true,"path":"posts/2016/2016-12/","link":"","permalink":"http://blog.bglee.me/posts/2016/2016-12/","excerpt":"","text":"벌써 12월이다. 미션들이 여러개가 떨어져서 이래저래 공부와 삽질을 하면서 11월 한달을 보냈다. 한달에 한번 포스팅할 시간도 없어서 정리를 하고간다.독서클로저 시작하기 - 기본 개념과 7주 훈련 프로그램빠른 모바일 앱 개발을 위한 React Native디스커버리 Go예전에는 정독을 목표로 책을 펴고 서문부터 읽어나갔었는데 출퇴근 시간을 아껴서 공부하다보니 실무에 쓰일 수 있는 부분을 먼저 읽기위해 목차를 읽고 고급 내용을 다루는 뒷 부분을 나중에 읽게 되었다.11월 중순 부로 서버까지 커버해야하는 상황이 오면서 회사에서 쓰이는 언어인 클로저(이전에도 한번 읽긴 했었다.)와 Go를 공부해야하는 상황인데 기존에 인계 받은 것 중에는 루비 온 레일즈도 존재한다.블로그서브 도메인을 구현했다. 이제까지 블로그가 집에서 굴리는 작은 서버를 통해 서비스되고 있었는데 이를 나스로 옮겨 잘 사용하고 있었는데 조카들이 와서 전원을 뽑아 놓는 바람에 이틀 정도 서비스가 중단되는 것을 계기로 깃헙 페이지를 통해 서비스를 제공하면서 도메인도 http://blog.bglee.me로 옮겼다.Next공부에 치이는 상황에서 주어진 시간을 최대한 활용하고 추후의 빠른 개발 및 데브옵스를 위해서 기존 API 서버의 GraphQL 프록시를 도전하기도 했고 앱에 대한 니즈 또한 존재해 리액트 네이티브를 공부했다. 시간이 얼마 없기 때문에 GraphQL은 드랍했고 메인 프로젝트의 일정을 맞추기 위해 주니어들과 함께 다시 FrontEnd 코드를 작성중에 있다.웹 서빙을 위해 EC2, ECS, S3 static hosting 여러가지를 해왔는데 각각의 장단점이 있고 Serverless 스택 또한 러닝커브가 있지만 한번 구현이 완료되면 안정성과 비용 절감이 이루어지는 만큼 이 부분이 다음 타겟이 될 것 같다. 첫 시도는 주어진 시간의 한계로 친구에게 맡긴 상황인데 이 부분이 잘 해결되었으면 한다.ㅏ","categories":[{"name":"summary","slug":"summary","permalink":"http://blog.bglee.me/categories/summary/"}],"tags":[]},{"title":"AWS EC2 Container Service(ECS)를 통한 배포","slug":"aws-ec2-container","date":"2016-11-05T06:00:00.000Z","updated":"2018-03-29T06:03:19.622Z","comments":true,"path":"posts/2016/aws-ec2-container/","link":"","permalink":"http://blog.bglee.me/posts/2016/aws-ec2-container/","excerpt":"","text":"ecs 는 현재 서울 리전에서는 지원되고 있지 않다. 글을 쓰다가 개인 업무가 있어서 끊어 쓰다보니 매끄럽지가 않은데 질문사항이나 잘못된 점이 있으면 피드백 주세요.개요aws console 을 통해 EC2 Container Service(ecs) 에 진입하면 3개의 메뉴가 보인다.ClusterTask DefinitionsRepositoriesCluster하드웨어 클러스터를 의미한다. EC2의 모임이라고 생각하면 편하다.Task Definitions이 곳에서 Docker 파일을 통해 task 를 정의한다. 정의한 task를 cluster에 할당하여 동작시킨다고 생각하면된다. task 에서는 메모리를 얼마나 사용할 것인가? 등의 docker 설정을 포함한다.Repositoryaws 에서 사용할 수 있는 docker hub 라고 이해하면 빠르다. 이 곳에 빌드된 docker image 를 올린다.실제 구성저장소 구성 및 업로드docker image build먼저 어플리케이션을 구현하고 Dockerfile을 통해 이미지로 빌드한다(빌드 과정은 이 포스트의 영역을 넘어간다).docker 저장소 생성빌드 된 이미지를 ecs repository 에 업로드하기 위해서 ecs 서비스의 repository 에 진입하여 Create repository 버튼으로 저장소를 생성한다.docker image upload친절하게 ecs에서 repository 를 선택하면 View Push Commands 라는 버튼을 통해 업로드 방법을 볼 수 있다. login, build, tag, push(upload) 순으로 명령어가 적혀있는데 저장소 url, region을 자신에 맞게 수정하고 올리면된다.task definitionstask 생성Task Definitions 메뉴에서 Create a Task Definition 버튼을 눌러 생성한다. Container Definitions 에서 Add container 버튼을 통해 컨테이너를 등록해야하는데, image 에서는 프로토콜(http://)을 제외한 이미지 경로를 넣어준다.메모리의 경우는 task 가 실행될 실제 컨테이너의 메모리 안에서 설정하면된다. 실제 사용하는 메모리보다 적게 잡을 경우 속도저하, 응답없음 등을 경험할 수 있다. 실제로 PDF를 생성하는 서버를 구현했다가 랜더링 할 메모리가 모자라 응답없음을 경험했었다.추가적으로 포트 매핑, CPU unit 등을 설정해준다.cluster 에 배포cluster 생성service 생성클러스터를 생성하고 나서 클러스터에 제공할 서비스를 생성한다. 여기서는 위에서 정의한 task 와 이를 서비스할 cluster 를 지정하고 몇개의 task를 돌릴 것인지 등을 셋업한다. 추가적으로 ELB, auto scaling등도 셋업을 한다.ELB 최근에 Application Load Balandcer 가 추가 되면서 기본설값이 되어 있다. 기존에 쓰이던 ELB는 Classic Load Balancer 니 참고 바란다.여기 까지는 그냥 따라오면 되는데 중요한 문제가 있다. cluster 에 등록된 컨테이너 인스턴스가 없다. 이제 이를 세팅해야한다. cluster에 ec2 instance를 등록하기 위해서는 ecs agent가 설치된 이미지가 로드되야한다. 이건 유저가 스스로 설치할 수도 있지만 기본적으로 아마존에서 제공하는 이미지가 있다.테스트를 위해 ec2 instance 를 생성한다. AMI는 Amazon ECS-Optimized Amazon Linux AMI 를 이용한다.auto scaling group, launch configuration 을 통해 서비스를 하는게 정석이다.여기서 user data 를 설정해서 인스턴스가 ecs에 접속해서 클러스터에 등록을 할 수 있도록 설정해 줘야한다.12#!/bin/bashecho ECS_CLUSTER=CLUSTER_NAME &gt;&gt; /etc/ecs/ecs.configuser 데이터의 내용은 위와 같다.여기서 CLUSTER_NAME 부분을 통해 인스턴스가 로딩되면서 ecs agent가 실행되게되고 여기서 ecs 에 접속하여 cluster에 등록되게 된다.update revisiondocker image가 업데이트 되어 재 배포가 필요한 경우에는 task의 new revision을 선택하고 container를 눌러서 한번 업데이트를 누른다(현재 컨테이너가 같은 docker이름을 참조하더라도 재 참조를 하도록) 리비전이 생성되면 생성된 task를 서비스에 업데이트하게 되면 현재 구동되고 있는 task가 active로 업데이트된 task가 primary로 등록되며 시간이 조금 지나면 active가 내려가고 primary가 active되면서 서비스가 이어지게 된다.trouble shotting###* cat /etc/ecs/ecs.config1Could not register module=&quot;api client&quot; err=&quot;ClientException: Cluster not found./etc/ecs/ecs.config 에 cluster 이름이 정확히 올라가 있는지 2번 확인한다.그래도 안되면 ecs agent api call이 public ip를 요구하므로 public ip가 있어야한다.(또는 프록시 등의 다른 방법) ec2를 확인한다.","categories":[],"tags":[{"name":"ecs","slug":"ecs","permalink":"http://blog.bglee.me/tags/ecs/"},{"name":"ecs_cluster","slug":"ecs-cluster","permalink":"http://blog.bglee.me/tags/ecs-cluster/"},{"name":"ecs.config","slug":"ecs-config","permalink":"http://blog.bglee.me/tags/ecs-config/"},{"name":"aws","slug":"aws","permalink":"http://blog.bglee.me/tags/aws/"},{"name":"ec2","slug":"ec2","permalink":"http://blog.bglee.me/tags/ec2/"},{"name":"ec2 container","slug":"ec2-container","permalink":"http://blog.bglee.me/tags/ec2-container/"}]},{"title":"deview-2016","slug":"deview-2016","date":"2016-10-23T15:00:00.000Z","updated":"2018-03-29T06:03:19.624Z","comments":true,"path":"posts/2016/deview-2016/","link":"","permalink":"http://blog.bglee.me/posts/2016/deview-2016/","excerpt":"","text":"Deview 2016CTOkeynote회사에서 프론트엔드 개발차 지원해준 기회기 때문에 FE로 스케줄을 잡았는데 키노트를 들으니.. 로봇과 음성인식 세션이 궁금했지만 계획대로 진행하기로했다.네이버 랩스는 무인 주행, 음성 인식(자연어), 로봇에 집중하고 있는 것으로 보인다. 무인 주행 자체에 집중하기 보다는 시각데이터를 파싱하는 목적이 큰 것으로 보였다.M1(?) 이라는 네이버 랩스 로봇 영상이 보여졌는데 돌아다니면서 영상을 찍는데(머리가 카메라로 무장) 단순이 동영상을 찍는게 아니라 걸 돌아다니면 녹화했던 영상 데이터를 다시 보여줄 때는 걸려있던 액자들의 내용을 바꿔서 보여줬다. 3D 맵 데이터로 파싱해서 데이터화 하고 있는 것으로 보였다.D2Naver Open Source2016년 4개를 공개함 https://github.com/naver.compinpoint star: 2300나눔 고딕 폰트가 금일 업데이트 되었다.지도 API는 일일 20만 콜이 가능하다.D2 Startup Factory스타트업 지원papago한국, 일본, 영어, 중국어 지원Whale네이버의 Chromium 기반 브라우저다. 12월 런칭 예정이다 [공식 홈페이지]https://whale.google.com네이버 브라우저 스플릿창 지원글자 선택만으로 검색스마트 팝업(구석에 나옴)이미지 번역악성코드 제어파파고 기술이 들어가있음12월 발표BLUE생활 환경 지능(Ambient Intelligence) - 사용자가 요구하지 않아도 상황을 인식하고 추천하는 것understand - 이해하는 것anticipatory - 답/정보/action을 예상 추천natural UX 음성, gesture등AMICAAMI Connected All영상이 소개되었는데 아이템은 팔찌로 보이고 차 내에서 또 자기전에 말을 하는데 음성인식관련으로 siri와 매우 유사했다.https://amica.ai자연어 처리는 음성에만 국한된 것이 아닌 채팅에서도 사용이 가능하다.는 것을 기억해야할 듯AMICA는 11/7 까지 클로즈 베타 신청 받음(막상 들어가보니 11/6일)Samsung ARTIK 으로(Intel Edison류의 보드인 것으로 보임) 포팅되어있어 사용이 가능하다.자율주행미국(?)의 기준인 NHTSA level 3 수준이다.NAVER LABS M1Indoor mapping robot공간 인식 및 정보화, 3D 실내지도이미지 인식기술은 인공지능 기술과 합성되면 사람의 눈과 같은 역할을 하게될 것으로 보여졌다.(카메라니 당연히 눈이지만 시각정보를 인간과 같이 파싱하는 느낌)Session#01(Web Payment API의 현재와 미래)2015-10 에 표준화 작업이 시작됨Motivation68%는 카트에 담고 결재하지 않음, 데스크탑 보다 모바일에서 그보다 나가는 비율이 66% 더 됨폼이 너무 복잡하다계정생성 귀찮음모바일 디자인이 구림로딩 속도Web Payment with Basic Cards크롬 53(4?)에서부터 지원한다.구성Payment Request API,Payment Method IdentifiersBasic Card Payment복잡한 form으로 처리 되는 것을 one button 으로 처리한다.브라우저가 가지고 있다. 판매자가 수용하는 payment request를 날리면 카드 리스트만 리스트업 됨benefituser쇼핑몰에 관계없이 같은 ux제공처음 이용 쇼핑몰에서도 저장된 신용카드를 이용가능merchant결재 ux개발안해도됌보안이슈 및 서버 운용비용 절감123456789var methodData = [&#123; supportedMethods: ['visa', 'master'],&#125;, &#123; supportedMethods: ['sampay'], data: &#123; merchantID: '12345',...&#125;]var pr = new PaymentRequest(methodData, details, options);shippingOptions: 배송정보paymentOptions: 어떤 정보를 입력받고 받지 않을지 결정프로미스 기반언급된 이벤트shipping address change eventshipping options change event지원하지 않는 지역이나 옵션이 올 경우에 대한 처리를 이벤트를 받아 처리할 수 있다.1e.updateWith(//이벤트 업데이트결재를 판매자측 서비스에서 처리하는데 개발 부하가 걸린다앞으로 미래는 payment app을 사용한 결재가 있다.Web Payment with Payment AppsSamsungPay, AliPay 등을 통해신용카드 뿐만 아니라 결재 앱을 카드처럼 지원한다.페이먼트 앱웹 기반(현재 포커스 되어있음 w3c)네이티브 기반(완전히 정의되지 않음) =&gt; 네이티브를 트리거하는 방식으로 진행 될 예정(지금이랑 같지 않은가?)service worker브라우저가 죽어도 살아있다.브라우저에 설치되게 되며 필요한경우(푸시 알람) 이벤트를 수신받은 브라우저에 의해 활성화된다.지정된 origin 및 scope에서만 동작하며, Secure Context에서 실행됨을 보장.payment app &lt;&gt; service worker 는 1:1 관계다.1navigator.serviceWorker.register('/tree_pay.js').then(Session#02(GraphQL)기존rest필드제한 한계필터 문제문서 문제동기화 문제json:apiGraphQLquerymutationobject type을 가지고 schema를 정의object* type(required): name * args: 인자 * resolve: return function rest: postman / graphql: GraphiQL(chrome extension)RelayReact와 GraphQL을 엮는다.NodeResource에 대한 단일 interfaceConnection(페이지네이션 특화)Node를 여러개 가져온다React Relay123456React.createContainer(COMPONENT_NAME, &#123; fragments: &#123; editor(props의 이름: () =&gt; Relay.QL` fragment on User &#123; pictureURL $&#123;EditorInfo.getFragmentMutation Configquery(node, connections),변경(mutation)참고 http://learngraphql.com검색해 볼 것nosyncdblukkaawesome graphqlQ&amp;A 시간에 질의 응답을 볼때 Relay와 Redux는 함께 사용하기 껄끄러운(베스트 프렉티스가 없는) 상황으로 보여지며 기존 Redux 사용시의 전략인 외각 오브젝트에서 데이터 로직을 처리하고 나머지를 퓨어 컴포넌트로 가져가는 방식이 아닌 서버쪽 데이터를 활용하는 대부분의 컴포넌트가 Relay로 바인딩 되게 된다.Redux, Relay 모두 Flux 아키텍쳐의 영향을 받았으므로 개인적으로는 Store가 로컬에 있느냐 리포트에 있냐를 차이로 보고 있지만 컴포넌트가 데이터와 강하게 커플링되는 것에 대한 거부감이 있는 것이 사실이다. 실제 적용을 해보면서 답을 찾아야할 부분으로 보인다.Session#03(Electron)검색시에는 github eletron으로 검색해야 한다.slack과 microsoft가 샘플이 됨(Document에도 존재하지 않는 것들이 쓰이니 볼 것)electron은 소스가 다 보인다. 로직을 백엔드로 빼서 구현했다고 말하고 있다.로직을 백엔드로 빼면서 Command 패턴을 사용했는데 로직이 백엔드로간 이유는 보안상의 이유라고 한다.(여기서의 백엔드는 local에서 node server를 돌린다는 이야기다.Devtron 이라는 크롬 익스텐션이 존재하는 이를 개발 환경에서 이용할 수 있다.node 바이너리 솔루션enclosejs: 플랫폼에 맞춘 바이너리화eletron-builder개인적으로 인상적인 세션은 아니었고 개발 방법론, 패턴등을 설명했음에도 30분내에 발표가 마무리되었다.Session#04(한 달 만에 개발한 하이브리드 앱, 50만 사용자 서비스가 되기까지)해먹남녀하이브리드가 넘어야할 장애물view 전환 효과300ms의 지연이 존재(웹뷰) - single tab, double tab을 잡기 위해 존재hammer.js, fastclick.js가 있음transition3d translate css 이용pushcordova 등백수시절 6개월동안 7개의 앱을 만듬(평균 2주)해먹남녀는 IonicFramework을 이용해서 제작했다. 1달만에 웹뷰를 이용한 하이브리드앱을 제작했으나 2달의 안정화 작업을 거쳤다.1주차comonent부터 ui를 만듬문제는 라우팅으로는 위계 제어가 힘들다.2주차어려운 문제들을 해결하기 시작sync플러그인 업데이트 종속성다중업로드보안정책(애플)3주차성능데이터 프리패치터치 컨트롤 통제스크롤시 터치를 받지 않는 등으로 속도 향상이미지 리사이징css blur처리가 속도가 느려서 40px짜리를 up scaling해서 속도를 향상 시킴4주차png 처리 투명VOC 사용자 피드백 대응https://microsoft.github.io/code-push클라우드에서 버전이 바뀌면 파일을 보내줌 급할때만 씀cordova핵시config.xml 프로젝트 설정 파일버전관리, hook script 테스크 자동화, info, plist 자동 작성세션 발표자의 회고하이브리드 앱과 네이티브 앱 사이에는 넘을 수 없는 성능(트랜지션 등을 말하는 듯) 차이가 존재하나 하이브리드 앱이 보여주는 수준 자체가 준수하기 때문에 문제가 없다.하이브리드 앱이 네이티브를 대체한다기 보다는 빠른 Time To Market을 맞추기 적합하며 이를 활용한다는 전략적 차원으로 발표자는 설명했다.하지만 React Native가 있다면 어떨가…Session#05(5년간의 네이버 웹엔진 개발/삽질기 그리고…)Naver Labs의 신규 브라우저 Whale의 개발에 대한 스토리다. 사실 이 세션은 고민이 많았다. 선택할 수 있는 세션이 4개 였는데 다음과 같았다.Clean Front-End DevelopmentReact로 개발자 2명이 플랫폼 4개를 서비스하는 이야기우리 팀에서도 코드리뷰를 할 수 있을까?5년간의 네이버 웹엔진 개발/삽질 그리고…원래는 첫번째 세션을 들을까 준비했는데 Single Page Application만 5년 이상을 진행했고(심지어 임베디드 웹 브라우저에서도…) 사실 이 정도의 기간이 SPA 역사기 때문에 나이가 어린 세션 발표자거나(실망 시킨 경우가 많았다) 뻔해 보이거나 답 없는 주제(React vs Angular)와 같은 주제를 피하고 다수의 개발자들이 시간과 노력을 들여 진행한 프로젝트 이야기가 듣고 싶어 이 세션을 선택했고 결과 적으로 성공적이었다.브라우저 세션 답게 블락 다이어그램으로 스택을 소개하고 공감가는 삽질기를 들을 수 있었다. Q&amp;A 시간을 포함해서 45분인데 그중에 무려 30분을 Webkit 기반으로 진행한 프로젝트 연혁을 말하고 있었는데. 결론적으로는 Webkit을 버리고 Chromium 기반으로 만들었다고…국내에 브라우저를 낼 수 있는 기업이 얼마나 있겠는가 기대를 걸어본다. 브라우저 같은 뿌리 기술은 가지고 있으면 시너지를 낼 것도 많고 파급력을 가지는 대신 그 만큼 출시 이후에 끌고가는 문제도 있는 아무쪼록 잘 되었으면 한다.Whale일단 feature가 실제 사용 패턴과 관련 된 것이 맘에 들었다 대단히 실질적으로 사용패턴을 분석을 한 것으로 보였다.Over Tabber를 예로 들었는데(탭을 엄청나게 띄워 놓는 사람) 이유인 즉슨 이렇다는 거다.쇼핑몰에서 고르는데 인덱스 페이지 하나를 두고 상세 페이지를 들어갔다가 나왔다 하기 귀찮으니 여러개를 띄워둔다.사내에서 보라고 링크 공유가 왔는데 아예 안보는 것은 매너가 아니니 일단 띄워놓고 하염없이 둔다.구글에서 검색을 한뒤에 원하는 결과를 찾는데 이 때 도움이 될 것 같은 것은 일단 띄워둔다.실제로 나도 봐도 그렇기 때문에 깊이 공감을 했다. 그래서 Whale은 스플릿 뷰를 지원하고 쇼핑몰등에서 유용히 사용할 수 있도록 했다.읽기 모드를 미려하게 지원하고블락하면 궁금하고 블락하지 않자니 너무 떠대는 탭들을 스마트 탭뷰를 만들어서 정리해서 볼 수 있도록 구현했다.크롬 익스텐션이 풀리 호환되며 자체 지원을 위한 것도 준비되어있다.음성 검색(파파고?) 이 들어가있다.퀵 서치기능이 들어가있어서 단순 드래그만으로 단어나 인물등을 검색할 수 있는데 단순 검색이 아닌 검색 기반의 회사인 만큼 컨텍스트 검색을 통해 연관성이 높은 결과 값을 받을 수 있다.일단 기능이 마음에 든다. 고민의 흔적도 공감할 수 있어서 개인적으로는 아 맞게 고민했구나? (내가 쓸 수 있게...) 이런 느낌을 받았다.12월 런치로 보인다. https://whale.naver.comdeview 2016에 대한 개인적인 감상회사 업무도 업무고 상당히 가기 귀찮았는데 잘 갔다왔다는 생각이 든다. 무료 세미나에 가면 제품 홍보 성격이 강하다거나 어린 세션 발표자(어리다고 뭐라 하는 것이 아니라.. 확률상)의 경우 준비 미숙으로 50분 세션을 10분만에 끝내버리는 경우도 많았는데 그 보다는 훨씬 나았고 주제 자체가 진보된 것이 많았다. 무료 했었는데 좀 의지를 태울 수 있었다.","categories":[{"name":"summary","slug":"summary","permalink":"http://blog.bglee.me/categories/summary/"}],"tags":[{"name":"deview2016","slug":"deview2016","permalink":"http://blog.bglee.me/tags/deview2016/"},{"name":"deview","slug":"deview","permalink":"http://blog.bglee.me/tags/deview/"}]},{"title":"AWS API Gateway - Lambda - Travis-CI prototype 구현","slug":"aws-gateway-lambda-ci","date":"2016-09-25T15:00:00.000Z","updated":"2018-03-29T06:03:19.622Z","comments":true,"path":"posts/2016/aws-gateway-lambda-ci/","link":"","permalink":"http://blog.bglee.me/posts/2016/aws-gateway-lambda-ci/","excerpt":"","text":"aws serverless architecture 의 핵심에 api gateway 와 lambda 가 있다. 두 서비스는 모드 서울 리전에서 사용이 가능하다. 이를 이용하여 프로토타입을 작성해 보자.architecturenode로 서버를 구성하는 것을 예로 들자면 아래와 같다.node applicationexpress-routerlogicawsapi gatewaylambdaaws에서 제공하는 아키텍쳐 예시를 보면 이해가 쉽다.https://api.example.com 부분을 통해 api gateway에 접근하면 라우팅을 통해 필요한 lambda함수를 콜하게 된다. 그리고 db 등에 데이터를 연산을 하고 다시 사용자에게 응답을 리턴한다.이 포스트는 실무에 적용이 가능하도록 아래와 같은 내용을 담고있다.lambda 함수 생성api gateway - lambda 함수 연결(parameter, header 설정)development, production 모드를 분리하기 위한 stage 활용travis ci를 통한 배포 자동화실제 구현 순서와는 상관없이 설명하기 편하게 상향식 접근 방법으로 작성한다.lambda 함수 구현코드 구현 방식lambda는 다음 3가지 방식으로 코드를 구현 할 수 있다.inline editingupload zip fileupload from s3이 포스트는 배포 자동화까지가 목표이므로 2번째 안으로 진행한다.구현 언어lambda는 java, python 등 몇가지 언어를 지원하는데 이 포스트는 nodejs 4.3 버전을 기준으로 설명한다. nodejs 4.3은 es2015(a.k.a es6) 를 부분적으로 지원하는데 훌륭하진 않으며 다행이 Promise, Set 정도는 지원을 하고 있다.이외에 코드 작성은 방식은 자유지만 컴파일 또한 비용이며 polyfill등을 이용하게 되는 경우 용량이 늘어나므로 추천하진 않는다.lambda 함수 생성간단하면서도 lambda와 api gateway가 연결되면서 parameter들이 어떻게 전달되는지를 볼 수 있도록 코드를 작성한다. 배포하기 전 빠른 진행을 위해 aws에서 제공하는 inline editor를 사용해 바로 소스를 작성하도록 하자.aws console 에서lambda를 선택해서 lambda 페이지에 진입한 후 왼쪽 사이드 바에서 functions를 누르고 create a Lambda function을 눌러 lambda 함수를 생성하도록 하자.Select blueprint 화면이 나오면서 template 들이 보여지는데 skip 버튼을 눌러 다음 스텝으로 간다.configure triggers 화면이 나오는데 우리는 api call을 통한 실행을 할 것이므로 api gateway를 선택하고 next를 누른다.configuration function 에서는 함수에 대한 설정을 한다. 아래와 같이 설정한다.configvalueNameloopbackArgumentDescriptionRuntimeNode.js 4.3code entry typeEdit code inline)123456exports.handler = (event, context, callback) =&gt; &#123; callback(null, &#123; event: event, context: context &#125;);&#125;;export할 함수 이름을 정하고(여기선 handler) lambda의 signiture대로 3개의 인자를 받는다. 인자를 간략히 설명하면 다음과 같다.argumentdescriptioneventevent call에 대한 정보로 parameter, header등이 이 인자로 매핑된다.contextlambda 함수 자체에 대한 정보callback리턴함수라고 생각하면된다, 첫 번째 인자는 Error 객체, 첫 번째 인자가 null 경우 성공으로 간주되고 2번째 인자가 응답값으로 사용된다.이 코드는 단순히 람다 함수의 인자를 그대로 응답하는 handler함수를 반환하고 있다.이 외는 기본 설정을 이용하며 role을 정해줘야하는데 이전에 람다를 위한 role을 만들지 않았다면 생성 후 선택하고 next를 함수를 생성한다.api gateway - lambda 함수 연결(parameter, header 설정)api gateway에서는 라우팅 테이블을 만들때 swagger를 지원한다. 기 구현된 서버가 swagger를 통해 문서화가 되어 있다라면 serverless architecture를 바로 적용할 수 있을 것으로 보인다.특히 swagger에 api gateway extensions가 존재하는데 이 부분을 swagger에 함께 작성하게 되면 파라메터나 응답값에 대한 정의를 문서 작성 단계에서 끝낼 수 있다.이제 api gateway를 설정할 차례다.API 생성aws console 을 통해 api gateway 서비스에 접속한 후 APIs 메뉴에서 Create API를 누른다.New API를 선택하고 API name에 test 라고 작성한다.Actions를 눌러 Create Method를 선택하고 post를 선택한후 check 버튼을 눌러 생성한다.이러면 생성한 POST method에 대해 setup하는 화면이 나오고 이미지와 같이 설정을 하여 위에서 작성한 lambda 함수를 연결한다.물론 함수명과 리전은 작업중인 상황에 맞게 넣어야한다.API 설정Method Request설정할 것은 없지만 header와 query string이 들어오는 것을 확인하기 위해 이미지와 같이 추가해 둔다.Integration Request여기선 Method Request에서 설정한 parameter 들을 받기 위한 설정인데 기본 템플릿을 적용하여 아래 이미지와 같이 설정한다.API Deploy사용을 위해 Resources 옆 Actions 를 선택하고 Deploy API를 선택한다.이미지와 같이 [New Stage] 로 prod를 입력 후 deploy 버튼을 누르면 Stages 화면으로 진입하면서 endpoint가 될 url이 Invoke URL 이라는 이름으로 보인다.이제 이 url을 통해 api call 이 가능하며 당장 postman이나 curl등을 통해 확인이 가능하다.1차적으로 api gateway와 lambda함수를 연결해서 실행을 확인해 볼 수 있는 상태가 되었다.development, production 모드를 분리하기 위한 stage 활용작성한 코드를 실행해보면 아래와 같은 형태의 json이 응답으로 전달됨을 확인 할 수 있다.1234567891011121314151617181920212223242526&#123; \"event\": &#123; \"body-json\": &#123; ... &#125;, \"params\": &#123; \"path\": &#123;&#125;, \"querystring\": &#123; \"deptno-param\": \"deptno test\" &#125;, \"header\": &#123; \"Authorization\": \"deptno test\" &#125; &#125;, \"stage-variables\": &#123;&#125;, \"context\": &#123;, \"http-method\": \"POST\", \"stage\": \"prod\", ... &#125; &#125;, \"context\": &#123; \"memoryLimitInMB\": \"128\", ... &#125;&#125;Integration Request에서 설정한 기본 템플릿을 통해 전달된 event 오브젝트와 context 객체의 내용이 구현한 함수의 기능대로 동작한다면 위와 같은 결과 값을 받을 수 있으며, 코드에 보여지는 부분들은 자주 참조 되는 영역만을 코드에 표시했다.event 객체의 구조는 앞으로 사용할 lambda 함수에서 event 객체를 사용하는 reference가 된다.보면 event 에도 context가 존재하는데 여기에 stage property가 있고 우리가 deploy했던 stage를 참조할 수 있는데 이를 통해 (프로덕션 코드와 개발코드가 분리되는데 맞지만) lambda 함수에서 개발 버전 또는 배포 버전의 일에 대해 분기를 할 수 있게 된다.travis ci를 통한 배포 자동화code로 대신한다.1234567891011deploy:- provider: lambda function_name: loopbackArgument role: arn:aws:iam::... handler_name: handler region: ap-northeast-2 access_key_id: ... secret_access_key: secure: ... runtime: nodejs4.3 timeout: 30조금 부연하자면role은 lambda함수를 생성할 때 줬던 role(lambda 함수 실행을 위한) 이 들어가야된다.추가적으로 메모리 사용량 설정등도 가능하다.s3를 통해 업로드하는 방식과 달리 폴더를 압축해서 zip파일을 업로드하게 되는데 이때 용량제한이 걸린다. 압축한 파일을 용량이 50MB를 넘어가면 deploy에 실패하게 되니 주의하자.이 때는 s3에 upload 하고 추가로 스크립팅을 통해 deploy 되야하므로 번거로워진다.next실무 적용 및 효율 적인 업무를 위한 추가 적인 작업들은 아래와 같다.todocustom domain을 통한 배포ssl 적용api gatewaycors 적용swagger를 통한 문서화 및 배포slack을 통한 알림 처리","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"aws","slug":"dev/aws","permalink":"http://blog.bglee.me/categories/dev/aws/"}],"tags":[{"name":"aws","slug":"aws","permalink":"http://blog.bglee.me/tags/aws/"},{"name":"ci","slug":"ci","permalink":"http://blog.bglee.me/tags/ci/"},{"name":"api gateway","slug":"api-gateway","permalink":"http://blog.bglee.me/tags/api-gateway/"},{"name":"lambda","slug":"lambda","permalink":"http://blog.bglee.me/tags/lambda/"},{"name":"travis","slug":"travis","permalink":"http://blog.bglee.me/tags/travis/"},{"name":"lambda 배포","slug":"lambda-배포","permalink":"http://blog.bglee.me/tags/lambda-배포/"}]},{"title":"aws code deploy - ci","slug":"aws-code-deploy","date":"2016-08-14T15:00:00.000Z","updated":"2018-03-29T06:03:19.621Z","comments":true,"path":"posts/2016/aws-code-deploy/","link":"","permalink":"http://blog.bglee.me/posts/2016/aws-code-deploy/","excerpt":"","text":"TODO권한 이슈에 따른 이슈 (IAM role)트러블 슈팅github - ci - slack 링크 연결aws를 잘 모르는 상태에서 aws code deploy와 travis ci, slack을 통해 배포하기 위해 삽질한 기록.입사한지 4개월이 조금 넘어가는데 프론트엔드를 리딩을 하다보니 배포에 대한 니즈를 느끼게 되었고 그 삽질한 과정이다. 첫번째 프로젝트는 ci까지는 연결하고 배포는 쉘 스크립트를 이용해 scp로 운영하는 서버에 배포했다. 현재는 두번째 프로젝트를 조용히(?) 진행하고 있는데 n대의 서버에 배포하는 프로젝트를 곧 진행하게 될 것 같아 이 기회에 진행했다.회사는 현재 aws를 통해 서비스를 제공하고 있고, github enterprise를 통해 코드를 관리하고 있으며 travis-ci를 도입하는 단계에 있다. aws code deploy 는 배포 코드를 여러대의 aws 서버에 순차적으로 또는 한번에 배포를 할 수 있게 하는 시스템이라 생각하면 된다.코드 작성 부터 배포 까지의 한 사이클은 다음과 같다.githubcode 작성 =&gt; commit =&gt; push =&gt; pull request =&gt; mergecipull =&gt; test =&gt; deplycode deploy배포파일 download =&gt; 각 서버에 워하는 대로 배포github =&gt; ci에 대한 것은 github - travis ci - slack 포스트를 참조한다.code deploy 설정배포는 여러가지 방법이 있는데 aws code deploy 는 aws에서 여러대의 서버에 배포를 할때 쓰인다. aws를 잘 모르는 상태에서 시간이 꽤나 걸렸는데 권한 설정에 대한 이해가 발목을 잡았던 것 같다.우리는 지금 코드가 푸시되면 ci를 돌리고 있고 그 결과를 slack으로 받고 있다. 이제 ci가 성공했을 때 deploy를 해야한다. code deploy가 의미를 가지려면 여러대의 서버를 사용해야하고 auto scaling등의 기능을 사용해야하겠지만 여기선 배제한다.알아둬야할 사항은 다음과 같다.aws console 에서 우리가 접근 할 서비스는 아래와 같다.EC2CodeDeployIdentity &amp; Acceess Management(IAM)S3(s3를 통해 배포된다면)ec2 instance 자체에 code deploy를 위한 role 을 설정해줘야하며 이는 instance 시작 후에 변경이 불가능(?) 하다(이미 돌아가고 있는 인스턴스에는 적용할 수 없다).codedeploy-agent 가 각 인스턴스 마다 설치 되어있어야 한다.code deploy는 배포 데이터를 s3 또는 github으로 부터 번들링 된 데이터를 가져와서 실행하게 된다.번들링 된 데이터에는 code deploy가 무엇을 배포해야할지 알 수 있게 하는 설정파일이 root 에 포함되어야 한다. 파일 이름은 appspec.yml 이다.appspec.yml참고 문서 를 보면 단순하고 또 정리가 잘 되어 있으므로 참고하기가 편하다(읽기 귀찮으면 example 로 직행).단순하게 실 사용하는 파일 내용은 다음과 같다.12345version: 0.0os: linuxfiles: - source: / destination: /var/www/renderer/appspec.yml 에서 files 섹션을 보면 source와 destination이 있는데 source 는 번들링 파일의 구조를 기준으로 root를 설정한다. 쉽게 말하면 appspec.yml 이 있는 위치가 root(/) 가 된다.destination 은 각 서버에 복사될 위치를 나타내며 서버안에서의 위치를 생각하면 된다.code deploy는 각각의 서버에서 직접 번들링된 파일을 내려받아 실행되는 구조로 보인다. 이 때문에 인스턴스 생성 때문에 code deploy 에 대한 role 을 가지고 있어야 한다. 번들링 된 배포 파일의 위치가 s3 라면 이에 대한 권한 설정은 덤이다.대략적인 한 사이클에 대한 설명은 끝(?)났으니 실제로 따라해 보도록 한다. 글은 니즈의 순서대로 작성하고 올바른 순서는 표시를 하도록 하겠다.iam role 설정ec2 isntancedeployment groupcodedeploy-agent 설치배포서버 destination의 권한 확인IAM 설정aws console =&gt; IAM =&gt; roles 에서 Create New Role 을 선택해서 code deploy 대한 설정을 해야한다. 생성 후에 Trust Relationships =&gt; Edit Trust Relationship 에서 다음과 같이 설정한다123456789101112131415&#123; \"Version\": \"2012-10-17\", \"Statement\": [ &#123; \"Effect\": \"Allow\", \"Principal\": &#123; \"Service\": [ \"ec2.amazonaws.com\", \"codedeploy.[:region].amazonaws.com\" ] &#125;, \"Action\": \"sts:AssumeRole\" &#125; ]&#125;:region은 ec2가 존재하는 region을 설정하면된다.//TODO: role[2] EC2 설정IAM 설정[1] 에서 생성한 role을 선택해서 instance를 생성 하도록 한다.codedeploy-agent 설치문서화가 잘 되어 있어 그대로 따라하면 된다. 문서[3] AWS CodeDeploycodedeploy 설정에 진입하고 Create New Application 버튼을 눌러 배포할 application 에 대한 설정을 한다.Application Name배포할 어플리케이션의 이름이다.Deployment Group Name같은 설정을 통한 배포로 엮일 그룹 이름을 지정한다.Add Instances인스턴스를 생성하면서 만든 태그를 통해 배포의 타겟이 될 인스턴스 설정을 한다.Deployment Configurationn개의 서버에 한번에 deploy 할 것인지 하나씩 순차적으로 할 것인지에 대한 정책이다. 한대이니까 설정오류가 나지 않도록 CodeDeployDefault.AllAtOnce를 설정한다(배포시에 서빙가능한 서버가 없어도 된다).Service Role//TODO: codedeploy.[:region name].amazonaws.com 에 대한 설정이 되어 있는 role을 필요로 한다.[1] 에서 생성한 deployment group 에 대한 role을 선택한다.CI_ 설정CI가 slack에 알리는 것 외에 배포를 트리거 할 수 있도록 .travis.yml 에 codedeploy 관련 설정을 추가하고 번들링해서 업로드할 경로를 함께 설정한다.123456789101112131415161718192021222324before_deploy:[: 여기서 build를 한다]before_deploy:- mkdir -p [:업로드할 번들링 된 파일이 존재하는 디렉토리]- cp appspec.yml [:번들링 할 루트가 되는 디렉토리]- cd [:번들링 할 루트가 되는 디렉토리] zip -r ../[:업로드할 번들링 된 파일이 존재하는 디렉토리]/[:file key(file name)] .- cd ..deploy:- provider: s3 access_key_id: [:your access key] secret_access_key: [:your secret access key] local_dir: [:업로드할 번들링 된 파일이 존재하는 디렉토리] skip_cleanup: true bucket: [:bucket name] on: branch: master- provider: codedeploy access_key_id: [: your access key] secret_access_key: [:your secret access key] region: [:code deploy application이 존재하는 region] bucket: [:bucket name] key: [:file key(file name)] application: [:code deploy에 설정된 application] deployment_group: [:code deploy에 설정된 deployment group][:번들링 할 루트가 되는 디렉토리]컴파일 된 소스코드만 배포하면 되니 빌드된 바이너리나 코드가 있는 곳을 지정.이제 ci가 deploy 전 단계까지 성공한 다음에는 s3에 번들링된 파일을 업로드하게 되고 code deploy 를 트리거하게 된다. 잘 되었는지 확인하기 위해서 aws console의 aws codedeploy로 진입하여 대상 application을 선택하면 배포 상태를 확인 할 수 있다. 실패한 경우에는 로그와 함께 어떤 상태에서 실패했는지를 확인 할 수 있다. download 에서 실패하면다면 s3에 대한 접근 권한 문제일 가능성이 크다.","categories":[{"name":"setup","slug":"setup","permalink":"http://blog.bglee.me/categories/setup/"},{"name":"ci","slug":"setup/ci","permalink":"http://blog.bglee.me/categories/setup/ci/"}],"tags":[{"name":"aws","slug":"aws","permalink":"http://blog.bglee.me/tags/aws/"},{"name":"ci","slug":"ci","permalink":"http://blog.bglee.me/tags/ci/"},{"name":"travis ci","slug":"travis-ci","permalink":"http://blog.bglee.me/tags/travis-ci/"},{"name":"circle ci","slug":"circle-ci","permalink":"http://blog.bglee.me/tags/circle-ci/"},{"name":"slack","slug":"slack","permalink":"http://blog.bglee.me/tags/slack/"},{"name":"code deploy","slug":"code-deploy","permalink":"http://blog.bglee.me/tags/code-deploy/"}]},{"title":"github - travis ci - slack","slug":"github-travis-ci","date":"2016-08-14T15:00:00.000Z","updated":"2018-03-29T06:03:19.625Z","comments":true,"path":"posts/2016/github-travis-ci/","link":"","permalink":"http://blog.bglee.me/posts/2016/github-travis-ci/","excerpt":"","text":"코드를 커밋하고 ci가 검증하고 이에 대한 결과를 슬랙으로 받고자 한다.circle ci, travis ci 등 ci cloud service가 많은데 open source 를 지원해주는 travis-ci를 기준으로 해서 작성한다. circle ci도 개인 레포지터리 하나에 대해선 지원을 해준다.travis-ci, github 연결순서대로 진행을 하면 github과 ci를 연결해야한다. 일단 github에서 travis-ci를 사용하기 위해선 travis-ci.org에 계정을 만들고 github계정과 싱크를 한다. 그러면 개인 레포지터리가 보이게 되고 여기서 활성화를 하면 된다.활성화를 하면 다음과 같이 github =&gt; repo =&gt; Settings =&gt; Webhooks &amp; services 에 Travis CI 가 들어 온 것을 확인 할 수 있다.소스코드에서는 travis에서 읽어갈 설정 파일을 만든다. travis-ci는 cli를 제공하므로 이를 설치하도록 한다. ruby 종속성이 있으므로 없으면 이를 먼저 설치한다.1gem install travis이제 코드가 있는 디렉토리로 가서 .travis.yml 파일을 생성한다.1travis init이때 github에서 clone된 폴더로 작업을 하고 있었다면 자동으로 레포 정보를 가져오고 언어는 현재 사용하는 언어를 해주면 알아서 생성해준다.npm을 사용한 프로젝트라면 ci가 한번 돌 때마다 npm install에서 소요되는 시간이 상당하므로 캐쉬 설정을 해준다. install:에서 npm install을 한 경우에만 캐싱되는 것으로 보인다(또는 다른 곳에서 npm install을 하지 않은 경우)123cache: directories: - node_modulesslack 연결slack에 계정이 없다면 가입을 해서 생성을 하고 travis-ci를 설정하도록 한다 여기서 install을 눌러 설치를 하고 Post to Channel에서 원하는 채널이나 본인(Privately to @deptno (you))에게 알려주도록 설정한다. token 은 노출되면 안되므로 Encrypting your credentials에 써있는 코드를 복사해서 위에서 생성한 .travis.yml 이 있는 디렉토리에서 실행한다. 그러면 .travis.yml에 slack에 알림 설정이 된다.이제 코드를 푸시해서 master 에 들어오게 되면 알림이 뜨게된다.배포가 남았는데 배포는 서버 환경에 의해 좌우되므로 나눠서 기약없는 추후에 다루기로 한다.","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"ci","slug":"dev/ci","permalink":"http://blog.bglee.me/categories/dev/ci/"}],"tags":[{"name":"github","slug":"github","permalink":"http://blog.bglee.me/tags/github/"},{"name":"ci","slug":"ci","permalink":"http://blog.bglee.me/tags/ci/"},{"name":"travis ci","slug":"travis-ci","permalink":"http://blog.bglee.me/tags/travis-ci/"},{"name":"circle ci","slug":"circle-ci","permalink":"http://blog.bglee.me/tags/circle-ci/"},{"name":"slack","slug":"slack","permalink":"http://blog.bglee.me/tags/slack/"},{"name":"devops","slug":"devops","permalink":"http://blog.bglee.me/tags/devops/"},{"name":"notification","slug":"notification","permalink":"http://blog.bglee.me/tags/notification/"}]},{"title":"Neovim","slug":"nvim","date":"2016-08-02T15:00:00.000Z","updated":"2018-03-29T06:03:19.630Z","comments":true,"path":"posts/2016/nvim/","link":"","permalink":"http://blog.bglee.me/posts/2016/nvim/","excerpt":"","text":"12345brew install neovim/neovim/neovimcurl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vimcd ~ &amp;&amp; git clone https://github.com/deptno/.config.gittouch ~/.local.vim만약 .config 디렉터리가 있다면 실패하게된다 이때는 레포에 직접 접속해서 .config/nvim/init.vim을 들고와서 넣어준다.특정 폰트를 사용해야만 깨짐이 없으므로 패치된 폰트를 아래서 하나 받아 설치하고 iTerm2의 Non-ASCII Font를 설치한 폰트로 설정.https://github.com/ryanoasis/nerd-fonts 너무 많아서 개인적으로는 그 중에 들어본 폰트를 설치했다.123brew unlink vimcp -f /usr/local/bin/nvim /usr/local/bin/vicp -f /usr/local/bin/nvim /usr/local/bin/vimpath문제로 되지 않을 경우 .zshrc의 PATH를 수정하면된다trouble shootingE902: “eslint” is not an executablejs 파일 수정시 eslint 가 실행되야 하는데 없어서 생기는 문제다.1npm -g install eslintrequires Vim compiled with Python (2.6+ or 3.3+) supportYouCompleteMe와 같은 플러그인은 파이썬을 필요로한다.12brew install python3pip3 install --upgrade neovim[https://neovim.io/doc/user/provider.html]","categories":[{"name":"setup","slug":"setup","permalink":"http://blog.bglee.me/categories/setup/"}],"tags":[{"name":"neovim","slug":"neovim","permalink":"http://blog.bglee.me/tags/neovim/"},{"name":"vim","slug":"vim","permalink":"http://blog.bglee.me/tags/vim/"},{"name":"nvim","slug":"nvim","permalink":"http://blog.bglee.me/tags/nvim/"}]},{"title":"vim node plugin","slug":"vim-node-plugin","date":"2016-08-02T15:00:00.000Z","updated":"2018-03-29T06:03:19.633Z","comments":true,"path":"posts/2016/vim-node-plugin/","link":"","permalink":"http://blog.bglee.me/posts/2016/vim-node-plugin/","excerpt":"","text":"VIM 플러그인을 node로 작성하는 방법에 대해 간단히 리포트한다. 기본적으로 지원하는 플러그인은 vimscript, python정도로 보이는데 작은 기능을 추가하려고하는데 언어까지 배우기는 뭐해서 방법을 찾아봤다. 플러그인의 기능을까지라고 할 수 있을진 모르겠지만 node를 통해 간단한 작업은 할 수 있다.OSX를 기준으로 작성되었고 neovim을 사용하고 있다. 홈 디렉토리 안에 .vimrc파일이 설정일텐데 neovim에서는 .config/nvim/init.vim파일이 그 역할을 대신한다. 여튼 설정 파일을 열고 다음과 같이 추가해준다.코드가 우아하진 않고 공유차원이 그러려니…12345678910111213function CallNode(...) execute '%! node -e \"require(\\\"$HOME/.config/node-connector\\\")[\\\"' . a:1 . '\\\"][\\\"' . a:2 . '\\\"]()\"'endfunctionfunction CallNodeWithEcho(...) echom system('node -e \"require(\\\"$HOME/.config/node-connector\\\")[\\\"' . a:1 . '\\\"][\\\"' . a:2 . '\\\"](\\\"' . a:3 . '\\\")\"')endfunctionnmap ,fj :&lt;C-U&gt;call CallNode(\"format\", \"json\")&lt;CR&gt;nmap ,fx :&lt;C-U&gt;call CallNode(\"format\", \"xml\")&lt;CR&gt;nmap ,trk :&lt;C-U&gt;call CallNodeWithEcho(\"translate\", \"en\", getline(\".\"))&lt;CR&gt;nmap ,tre :&lt;C-U&gt;call CallNodeWithEcho(\"translate\", \"ko\", getline(\".\"))&lt;CR&gt;nmap ,trj :&lt;C-U&gt;call CallNodeWithEcho(\"translate\", \"ja\", getline(\".\"))&lt;CR&gt;CallNode 와 CallNodeWithEcho 함수가 있는데 후자는 결과 값을 VIM의 status bar에 표시해주는 역할을 한다.아래 다섯개의 함수를 정의했는데 역할은 순서대로 다음과 같다.formating jsonformating xml영어로 번역한국어로 번역일본어로 번역함수의 정의를 보면 알겠지만 단순히 node 스크립트를 로딩해서 실행하는 것이다.$HOME/.config/node-connector node script를 로드하므로 이 파일을 작성해줘야한다.node-connector.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879var pd = require('pretty-data').pd;module.exports = &#123; format: &#123; json: function() &#123; let i = process.stdin, d = ''; i.resume(); i.setEncoding('utf8'); i.on('data', function(data) &#123; d += data; &#125;); i.on('end', function() &#123; try &#123; console.log(JSON.stringify(JSON.parse(d), null, 4)); &#125; catch(ex) &#123; console.log(d); &#125; &#125;); &#125;, xml: function() &#123; let i = process.stdin, d = ''; i.resume(); i.setEncoding('utf8'); i.on('data', function(data) &#123; d += data; &#125;); i.on('end', function() &#123; try &#123; console.log(pd.xml(d)); &#125; catch(ex) &#123; console.log(d); &#125; &#125;); &#125; &#125;, translate: &#123; en: function(text) &#123; this.tr('en', text); &#125;, ja: function(text) &#123; this.tr('ja', text); &#125;, ko: function(text) &#123; this.tr('ko', text); &#125;, tr: function(source, text) &#123; var https = require('https'); var client_id = ''; //TODO: use yours var client_secret = ''; //TODO: use yours var host = 'openapi.naver.com'; var port = 443; var uri = '/v1/language/translate'; var data = require('querystring').stringify(&#123; source: source, target: source !== 'ko' ? 'ko' : 'en', text: text &#125;); var options = &#123; host: host, port: port, path: uri, method: 'POST', headers: &#123; 'X-Naver-Client-Id':client_id, 'X-Naver-Client-Secret': client_secret, 'Content-Type': 'application/x-www-form-urlencoded', 'Content-Length': Buffer.byteLength(data) &#125; &#125;; var req = https.request(options, function(res) &#123; res.setEncoding('utf8'); res.on('data', function (chunk) &#123; console.log(JSON.parse(chunk).message.result.translatedText); &#125;); &#125;); req.write(data); req.end(); &#125; &#125;&#125;;번역 api를 서비스로 네이버 개발자용을 쓰고 있어서 이 부분은 각자 발급해서 본인 것을 쓰면 된다.이제 문장이 있는 줄에서 영어로 번역을 원한다면 ,trk를 누르면 된다. json파일을 포맷팅하고 싶다면 ,fj 이런식이다. 오류가 발생하면 그대로 원본글 그대로를 보여주게 해놓았다.더 참조가 필요하다면 필자의 셋업을 참조하도록한다. 보통 난 노트북을 새로 셋업할때 git을 깔고 처음으로 설정을 클론뜨도록 해두었다. vim은 터미널 환경의 반이니까.https://github.com/deptno/.config","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"js","slug":"dev/js","permalink":"http://blog.bglee.me/categories/dev/js/"}],"tags":[{"name":"neovim","slug":"neovim","permalink":"http://blog.bglee.me/tags/neovim/"},{"name":"vim","slug":"vim","permalink":"http://blog.bglee.me/tags/vim/"},{"name":"vim plugin node","slug":"vim-plugin-node","permalink":"http://blog.bglee.me/tags/vim-plugin-node/"},{"name":"vim plugin javascript","slug":"vim-plugin-javascript","permalink":"http://blog.bglee.me/tags/vim-plugin-javascript/"}]},{"title":"맥북 설정","slug":"osx","date":"2016-07-27T15:00:00.000Z","updated":"2018-03-29T06:03:19.631Z","comments":true,"path":"posts/2016/osx/","link":"","permalink":"http://blog.bglee.me/posts/2016/osx/","excerpt":"","text":"맥북 때문에 겁먹은 동지들을 위해 씀.이 글의 대상은 일반인과 (프론트엔드)개발자를 모두 포함한다.맥을 받으면 App Store에 가서 OS 부터 업데이트를 시작한다.그 동안 만약에 키보드랑 마우스를 받았는데 Apple 이 안찍혀있으면 어차피 방해되므로 몰래 버리도록 한다.시스템 환경설정에 들어간다. 키보드 부터 설정해야한다.키보드 설정키보드 설정은 시스템 환경설정을 통해 진입하면 된다.^ 이건 ctrl \\- 이런식으로 생긴건 alt 꽃무니같은 건 command 키다.캡쳐하기 귀찮아서 키보드로 쳤다…키보드 모든 F1, F2 등의 키를 표준 기능 키로 사용 설정단축키 입력 소스 입력 메뉴에서 다음 소스 선택 *만** 설정단축키 Spotlight Spotlight 검색 보기 ^스페이스 로 설정이거면 우리는 키보드를 사용할 수 있게 된다.다음은 터치패드다.터치 패드 설정터치 패드 설정은 시스템 환경설정을 통해 진입하면 된다.체크 박스아래에 세 손가락으로 탭하기등도 설정메뉴이므로 동일 하게 설정한다.그럼 클릭이 아닌 탭으로 클릭동작을 수행할 수 있고 두 손가락으로 우클릭이 가능해진다.네 손가락으로 스와이프를 하면 바탕화면간 이동이 가능해진다. 설정 메뉴 자체가 튜토리얼이니 유심히 보도록 한다. 중요하다.손쉬운 사용손쉬운 사용도 시스템 환경설정을 통해 진입한다.마우스와 트랙패드 트랙패드 옵션... 관성사용 체크 세 손가락으로 드래그하기 체크이제는 손가락 3개로 드래그가 가능해져서 마우스가 필요 없어진다.프로그램 설치일만 하면 우울하니까 카카오톡 설치한다.여기서 부턴 개발자를 위한 코스다.요즘은 보통 쓰는 Slack 설치한다.개발자니까 터미널은 있어야한다. iTerm을 설치한다.FE 개발자니까 Chrome, WebStorm 설치한다.에디터 하나는 필요하니까 리듬에 맞춰 하나 선택한다.neovim - 설정 포스트vs codeatom개발 환경 셋업이제 터미널도 생겼고 개발 프로그램들도 설치했으니 필요한 환경들을 셋업한다.Gitgit은 터미널에서 git이라고 치면 라이센스 어쩌고 나오게 된다 그걸 설치하면된다.터미널 환경 설정ohmyzsh - 설정 포스트 을 설치하면 터미널에서 git status를 별다른 명령어 없이 바로 설정할 수 있다.패키지 매니저 설치debian의 apt-get이 있다면 여긴 brew가 있다.링크를 타고 가서 설치 스크립트를 복사해서 터미널에 붙이면된다.brew search [package name]brew install [package name]개인적으로는 neovim을 에디터로 쓰므로 그에 따른 플러그인 환경을 셋업하다보면 대충 다음정도는 바로 깔아줘야한다. history에서 발췌한 몇가지는 아래와 같다.1234brew install nodebrew install git-flow-avhbrew install treebrew install python3이제 node 설치됐으니 npm을 통해 필요로 하는 셋업을 해주면된다.생활 유틸리티Shiftit - open source로 키보드로 창 이동을 하게 해준다. Windows 유저였다면 Window + 방향키 느낌이라고 생각하면된다.Numbers - 애플 버전 스프레드 시트다. 회사 생활하려면 엑셀은 열얼봐야한다.vlc - open source movie player. 가끔 개발을 위해 미디어 포맷을 확인한다거나(?) 생각없이 버그 잡으면서 영상 틀어놀때 필요하다.yoink - 드래그로 파일 이동시에 워크스페이스(바탕화면 하나)를 넘어가는 경우에 발생하는 짜증을 감소시켜준다. 유료다.이제 코드를 짜면 된다.","categories":[{"name":"setup","slug":"setup","permalink":"http://blog.bglee.me/categories/setup/"}],"tags":[{"name":"맥북 셋업","slug":"맥북-셋업","permalink":"http://blog.bglee.me/tags/맥북-셋업/"},{"name":"맥북 개발 환경 설정","slug":"맥북-개발-환경-설정","permalink":"http://blog.bglee.me/tags/맥북-개발-환경-설정/"},{"name":"osx 개발 환경","slug":"osx-개발-환경","permalink":"http://blog.bglee.me/tags/osx-개발-환경/"},{"name":"맥북 설정","slug":"맥북-설정","permalink":"http://blog.bglee.me/tags/맥북-설정/"}]},{"title":"React 구현 전략","slug":"react-strategy","date":"2016-07-21T15:00:00.000Z","updated":"2018-03-29T06:03:19.631Z","comments":true,"path":"posts/2016/react-strategy/","link":"","permalink":"http://blog.bglee.me/posts/2016/react-strategy/","excerpt":"","text":"임베디드 브라우저에서 사용되는 앱을 Web 기술을 통해서 구현했던 터라 일반적인 Web 서비스의 구현이 처음이기도 해서 시행착오가 꽤나 있었다(인증, 배포, 서버 통신).처음으로 주어진 사내 서비스에 대한 구현을 잘 알지도 못하는 React로 구현하면서 느낀 점, 그리고 다음 구현에 대한 개인적인 글이다.TypeScript를 적용해야겠다.서버와의 통신이 많은데 interface는 컴파일레벨에서 많은 도움을 준다. 아쉬운 점은 React에서 중점적으로 쓰이는 Rest/Spread 지원이 아직 되지 않는 점인데 이 부분에 대한 부분은 pure js로 라이브러리화 하여 사용하는 면이 귀찮지만 그래도 득이 있을 것으로 생각된다. 실무에서는 데이터 통신 부분에서만 TypeScript를 적용하여 반쪽짜리 사용을 하고 있는데 이를 통해서도 득이 있었다.Container와 Component에 대한 개념을 탑재하자Redux를 적용하면서 Container와 Component에 대한 개념적인 부분이 약했다. code상으로는 redux의 connect를 통해 wrapping된 component가 Container인데 UI에서 제공하는 페이지당 하나의 Container를 둬서 통신에 대한 모듈로서의 역할을 명확히 하고 나머지 UI에 대한 부분은 Pure Component로 작성하는 것이 중요하다. 이에 대한 처리가 미흡하면 여기 저기선 connect를 하게 되어 data flow가 망가지고 컴포넌트의 순수성이 망가져서 test code의 작성을 불가 하게 한다.Immutable에 대한 적용은 뒤로 미뤄보자react, redux, immutable이 마치 세트처럼 다뤄지고 있지만 각각의 역할이 있고 도입 동기가 있어야했다. immutable은 사용성에서 pure javascript와는 이질적인 부분이 존재하고 객체가 pure인지 immutable객체인지에 대한 판단을 코드레벨에서 요구하게 된다. 사용성에 대한 부분을 개선한 seamless immutable 같은 경우에는 class의 instance를 유지하지 못하는 단점이 있다. react-addons-update가 제공하는 방식 또한 우아하다고 느껴지진 않지만 일단 최소한의 Container에서 사용하게 된다라고 가정한다면 바이러스처럼 퍼저나가는 immutable을 나중에 수습하는 비용을 뒤로 미룰 수 있다.UI component가 raw data를 직접 참조하지 않도록 한다.UI component가 참조하는 데이터 객체는 raw data를 품은 UI data class를 만들어서 사용한다. 이는 데이터 구조의 변경등이 있을 경우 수정 영역을 한정 할 수 있는 장점이 있고 이에 대한 저장을 store를 통한다면 강점이 있을 것 같다. 실무에서는 seamless immutable object의 instance를 유지하지 못하는 문제로 새로운 레이어를 만들어서 참조를 유지하도록 했다.StoreStore에 서버로 부터 받은 데이터 형태를 그대로 저장하고 있었는데 normalizr등을 통해 Object형태로 key값을 통해 바로 참조할 수 있는 형태가 여러 API를 통해 data의 수정등에 유연하게 대처할 수 있지 않나 한다.","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"js","slug":"dev/js","permalink":"http://blog.bglee.me/categories/dev/js/"}],"tags":[{"name":"react","slug":"react","permalink":"http://blog.bglee.me/tags/react/"}]},{"title":"React.js 프로 리액트","slug":"book-pro-react","date":"2016-07-21T15:00:00.000Z","updated":"2018-03-29T06:03:19.623Z","comments":true,"path":"posts/2016/book-pro-react/","link":"","permalink":"http://blog.bglee.me/posts/2016/book-pro-react/","excerpt":"","text":"React.js를 이용한 모던 프런트엔드 구축읽으면서 중요하다고 생각하는 것 몇 가지에 대한 정리Props conventiononChange등과 같이 camelCase가 사용되며 DOM API의 기준으로 element에 class등을 넣기 위해서는 className 프로퍼티가 대신 사용된다.Controlled Component와 Un Controlled Component둘을 나누는 차이는 가볍게 코드 상에서 props.value의 존재 유무라고 생각하면 된다.value가 존재하면 이에 대한 제어를 위해 onChange와 같은 이벤트를 받아 state를 관리하게 된다. 이 말은 Pure Component가 아니라는 말과 의미가 통하는 부분이 있다.Controlled ComponentControlled Component는 user action(click, typing 등)에 의해서 변하는 상태 값을 Component가 핸들링한다.Un Controlled Component상태값을 유지하지 않기 때문에 특정 시점에 Un Controlled Component 로 부터 데이터를 가져오는 작업이 필요하다. value prop이 사용되지 않기 때문에 기본 값 등의 셋업을 위해서는 defaultValue가 사용된다.Virtual DOMVirtual DOM을 통해 렌더링을 다시할 부분을 계산하게 되는데 이때 List형식의 DOM에 대해 insert, remove, move 등을 인지 할 수 없으므로 key 프로퍼티가 사용된다. 실무에서 적용할 때는 시간이 없어(?) warning을 지우기 위해 의미없는 index값을 대입했었으나 이 부분이 의미 있기 쓰이려면 List의 각 row가 가지고 있는 데이터의 매칭이 이루어져야 하므로 data의 id값 등을 넣어야한다.Shallow CopyReact에서 컴포넌트의 렌더링에 대해 비교할 때 레퍼런스를 비교하게 되는 것으로 예상(?)하고 있는데 이에 대한 처리를 정확히 해서 렌더링을 줄여 퍼포먼스 향상을 위해 Shallow Copy를 이해할 필요가 있다. 이에 대한 처리를 위해 facebook에서 만든 Immutable.js이 있고 순수 자바스크립트처럼 사용이 가능한 seamless-immutable 등의 구현체가 있으나 각각이 가지는 단점이 존재하여 단순한 큰 규모의 어플리케이션이 아니라면 얕은 복사에 대한 이해를 바탕으로 해결 할 수 있는 부분이 있을 것으로 보인다.Object, Array등 레퍼런스등의 객체를 직접 수정하는 것이 아닌 새로운 객체를 대입하는 케이스가 flux 아키텍쳐에서는 자주 일어나는데 이를 위해 Object.assign, Array의 map, concat등의 메서드를 자주 사용하게 된다. 새로운 레퍼런스를 반환하지만 Array나 Object안에서 다른 Array나 Object를 포함하고 있다면 이에 대한 레퍼런스는 유지되게 된다. 이에 대한 이해가 있으면 될 것 같다.관련 라이브러리react-addons-updateTestReact에서는 test framework으로 jest 를 권장하고 있다.관련 라이브러리react-addons-test-utilsETC이 외에도 Router(react router)와 flux(redux가 아닌) 자체, 서버 사이드 렌더링, 퍼포먼스 튜닝등의 내용을 담고 있다.","categories":[{"name":"summary","slug":"summary","permalink":"http://blog.bglee.me/categories/summary/"}],"tags":[{"name":"pro react","slug":"pro-react","permalink":"http://blog.bglee.me/tags/pro-react/"},{"name":"프로 리액트","slug":"프로-리액트","permalink":"http://blog.bglee.me/tags/프로-리액트/"}]},{"title":"webpack babel 설정","slug":"webpack-babel","date":"2016-07-20T15:00:00.000Z","updated":"2018-03-29T06:03:19.634Z","comments":true,"path":"posts/2016/webpack-babel/","link":"","permalink":"http://blog.bglee.me/posts/2016/webpack-babel/","excerpt":"","text":"webpack을 통해 번들링Webpack은 파일을 하나로 묶어주는 번들러고 Babel은 ES2015/2016/2017 =&gt; ES5로 내려주는 트랜스파일러다. 둘을 세트로 셋업하는 경우가 흔하고 사용 방법이 두가지가 존재하고 많은 예제들이 너무 여러가지를 포함하고 있어서 기본을 셋업할 수 있도록 정리하려 한다.1webpack ./entry.js bundle.jsWebpack을 위와 같이 실행하면 entry로 부터 참조는 모든 의존성을 묶어 bundle.js 파일 하나로 묶어낸다. 실제로는 config 파일을 생성해서 쓰게 되다.webpack.config.js123456789module.exports = &#123; module: &#123; loaders: [&#123; test: /\\.jsx*$/, exclude: /node_modules/, loader: 'babel' &#125;] &#125;&#125;;이 파일에서 로더를 설정하여 js, jsx파일을 만나게 되면 babel-loader를 통해서 번들링되며 이 과정에서 babel은 babel 설정을 로드한다. 여러가지 설정 방법 중에 .babelrc를 생성하는 방법을 선호하며 json을 다음과 같이 작성한다..babelrc123&#123; \"presets\": [\"es2015\", \"stage-0\", \"react\"]&#125;사용하는 프리셋들은 babel 플러그인들의 집합인데 각각 간단히 설명하면 다음과 같다.* es2015: es2015(ES6) 문법을 지원한다. * stage-0: es2016(ES7) 이상의 실험적인 문법을 지원한다. * react: jsx를 지원한다. 이렇게 설정을 해 놓으면 entry.js 부터 ES2015 혹은 그 이상(stage-0 때문)의 문법으로 작성이 가능하고 바벨을 통해 ES5로 bundle.js파일이 생성되게 된다.클라이언트에서 로드하게 되는 static file은 위와 같은 방식으로 만들면 된다.runtime에 적용node로 작성을 한다고 가정해보자. 클라이언트에서 생성된 파일을 로드하는 것과는 달리 실행을 시켜야한다. 보통 이런식이 된다.1node indexnode는 버전에 따라 다르지만 현재를 기준으로 es2015 문법이 완전히 지원되지 않는다. 이전에 작업한 파일을 가지고 시작한다고 가정하면 하나의 파일만 작성하면된다.index.js123456require('babel-register')(&#123; \"plugins\": [[ \"babel-plugin-webpack-loaders\", &#123; \"config\": \"./webpack.config.js\" &#125; ]]&#125;);require('main.js');babel-register로드하면서 플러그인으로 babel-plugin-webpack-loaders를 설정하면서 webpack-config.js를 로드한다 이후 파일(main.js) 부터는 es2015 문법을 지원하게 된다.babel-nodebabel-node는 node의 wrapper라고 생각하면된다. .babelrc만 작성되어있으면 바로 es2015등의 문법 사용이 가능하다. 사용을 위해선 설치를 해야한다.12npm install --save-dev babel-cli./node_modules/.bin/babel-node main성능상의 이슈가 있으며 프로덕션 모드에서는 사용하지 않는다.trouble shootingproblem 2016-08-22123456789101112$ npm start&gt; open http://localhost:3000//Users/bglee/tmp/paperboy-client/node_modules/rimraf/node_modules/glob/glob.js:106 for (var j = 0; j &lt; set[0].length; j++) &#123; ^TypeError: Cannot read property 'length' of undefined at Function.glob.hasMagic (/Users/bglee/tmp/paperboy-client/node_modules/rimraf/node_modules/glob/glob.js:106:29) at rimraf (/Users/bglee/tmp/paperboy-client/node_modules/rimraf/rimraf.js:61:36) at ExecBuffer.cleanup (/Users/bglee/tmp/paperboy-client/node_modules/exec-buffer/index.js:124:2) at ExecBuffer.&lt;anonymous&gt; (/Users/bglee/tmp/paperboy-client/node_modules/exec-buffer/index.js:103:10) at FSReqWrap.readFileAfterClose [as oncomplete] (fs.js:439:3)solution1npm i rimraf@2.2.8ramraf와 glob관 버전 호환성 문제로 보인다 rimraf를 강제로 버전을 고정시켜준다.","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"js","slug":"dev/js","permalink":"http://blog.bglee.me/categories/dev/js/"}],"tags":[{"name":"babel","slug":"babel","permalink":"http://blog.bglee.me/tags/babel/"},{"name":"webpack","slug":"webpack","permalink":"http://blog.bglee.me/tags/webpack/"}]},{"title":"Promise || Async/Await","slug":"async:await","date":"2016-07-10T15:00:00.000Z","updated":"2018-03-29T06:03:19.621Z","comments":true,"path":"posts/2016/async:await/","link":"","permalink":"http://blog.bglee.me/posts/2016/async:await/","excerpt":"","text":"callback방식1234567891011function asyncFunction(callback) &#123; setTimeout(function() &#123; if (callback) callback(1); &#125;, 1000);&#125;function caller() &#123; asyncFunction(function(returnVal) &#123; console.log('after callback()'); &#125;);&#125;promise1234567891011121314function asyncFunction() &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(1); &#125;, 1000); &#125;);&#125;function caller() &#123; asyncFunction() .then(function resolved(resolveVal) &#123; console.log('after callback()'); &#125;) .catch(function rejected() &#123; &#125;);&#125;Async/Await / ES712345678async function caller() &#123; try &#123; const resolveVal = await asyncFunction(); console.log('after callback()'); &#125; catch (rejected) &#123; console.log('after reject(throw)'); &#125;&#125;;Async/Await은 Await을 사용하기 위해 함수를 async로 선언해야 한다. TypeScript는 1.7버전 이상이 있으면 사용 가능하다.마지막으로 async 함수는 Promise를 리턴한다.1234567891011121314151617async function returnPromise(wantToThrow) &#123; if (wantToThrow) &#123; throw false; &#125; return true;&#125;async function awaiter() &#123; const mustBeTrue = await returnPromise(); console.log(mustBeTrue) // true try &#123; await returnPromise(true); &#125; catch(ex) &#123; console.log(ex); // false &#125;&#125;","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"js","slug":"dev/js","permalink":"http://blog.bglee.me/categories/dev/js/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://blog.bglee.me/tags/es6/"},{"name":"es7","slug":"es7","permalink":"http://blog.bglee.me/tags/es7/"},{"name":"es2015","slug":"es2015","permalink":"http://blog.bglee.me/tags/es2015/"},{"name":"async await","slug":"async-await","permalink":"http://blog.bglee.me/tags/async-await/"},{"name":"async/await","slug":"async-await","permalink":"http://blog.bglee.me/tags/async-await/"},{"name":"promise","slug":"promise","permalink":"http://blog.bglee.me/tags/promise/"}]},{"title":"book-the-software-crafatsman","slug":"book-the-software-crafatsman","date":"2016-05-15T15:00:00.000Z","updated":"2018-03-29T06:03:19.623Z","comments":true,"path":"posts/2016/book-the-software-crafatsman/","link":"","permalink":"http://blog.bglee.me/posts/2016/book-the-software-crafatsman/","excerpt":"","text":"ISBN: 979011086659-48-9 93560목차* 1부: 이념과 태도 * 21세기의 소프트웨어 개발 * 애자일 * 소프트웨어 장인정신 * 소프트웨어 장인의 태도 * 영웅, 선의 그리고 프로페셔널리즘 * 동작하는 소프트웨어 * 기술적 실행 관례 * 길고긴 여정 * 2부: 완전한 전환 * 인재 채용 * 소프투웨어 장인 면접하기 * 잘못된 면접 방식 * 낮은 사기의 대가 * 배움의 문화 * 기술적 변화의 실행 * 실용주의 장인정신 * 소프트웨어 장인으로서의 커리어 이 책은 소프트웨어 장인정신이라 칭하는 개발자가 가져야할 태도에 관한 책이다. 공감가는 부분이 꽤 있었고 도움이 되는 부분도 있었다.소프트웨어 장인(이하 장인)은 엘리트나 슈퍼 개발자를 칭하지 않는다. 장인정신을 가진 개발자를 말한다. 주니어개발자도 장인이 될 수 있다. 장인 정신의 핵심은 열정이다. 열정이 있기 때문에 장인은 일을 일로만 바라보지 않는다. 즐거워야하고 그 즐거움을 나누고 싶기에 이를 전파한다. 이 열정은 다른 개발자도 장인이 되고자 하는 의지를 불태워 장인 파이를 키우고 종국적으론 소프트웨어 산업 전반의 역량을 향상시켜 사회에 기여하게 된다.장인들은 열정이 있기 때문에 스스로 공부하고 이를 전파하고자 하는데 이에 대해 사회적인 가로막힘이 현실적으로 존재한다. 경직된 조직 문화, 연봉, 근무 시간, 환경 여러가지 요소가 있을 수 있는데 이에 대한 타개 방법을 프로페셔널리즘에 입각해서 풀고 있다. 개발자가 위에서 시키는 일만 하는 사람이 아니기 위해선 비즈니스를 이해해야하며 스스로 결정하고 책임을 지는 태도로 임해야한다. 침체에 빠진 조직을 구하기도 하며 구할 수 없을때는 떠나기도 해야한다. 저자는 5년이상 일한 기업이 없다고 적고 있다. 우리는 프로페셔널이기 때문에 단지 사람이나 이 기업이 마음에 든다고해서 영원히 있을 수 없고 자신의 커리와 회사의 이해가 맞을 때 우리는 함께 할 수 있다.말도 안되는 인원과 일정이 주어지는 프로젝트에서 우리는 안된다고 의사를 전할 수 있어야하며(단순히 우리의 매니저가 아닌 마케팅 담당자 등에) 이를 영웅이 되고자하는 마음으로 푸는 프로페셔널하지 못한 결정을 하면안된다. 이건 개인을 위해서도 회사를 위해서도 옳지 못한 행위라는 것을 인지해야한다.채용과 면접에 관해서도 나오는데 이 부분이 재밌다. 공감이 되어 기억에 남는 부분들을 적어본다.채용과 관련해서는 장인을 찾기 위한 방법이 기재되어 있다. 장인에게 중요한건 단순 연봉이 아니기 때문에 이들을 찾기 위해서는 채용 공고부터 다시 써야한다. 일반적인 채용공고로는 장인을 꼬실 수도, 과한 오버스펙 공고로는 장인 풀 자체를 줄여 뽑을 수 없게 된다. 장인을 찾기 위한 몇가지 방법을 제시했는데장인을 찾기 위한 그물망* Github 계정 * 블로그 * 오픈 소스 활동 * 기술 커뮤니티나 사용자 그룹 활동 내역 * 펫 프로젝트 내용 * 트위터 계정 * 좋아하는 기술서적 목록 * 참석했거나 발표했던 콘퍼런스 위와 같다. 개인적으로 성향등을 고려하였을 때 우선순위를 두자면* Github 계정 * 블로그 * 기술 커뮤니티나 사용자 그룹 활동 내역 위 정도가 맞을 것 같다. 코드나 오픈 소스 활동등이 그대로 오픈되는 Github 계정은 말할 것도 없고 블로그 또한 자신의 지식을 공유하겠다는 큰 의지표현이라 볼 수 있다(물론 블로그 글을 통해 장인정신이 있는지를 잘 봐야한다). 펫 프로젝트는 개인 프로젝트를 말하는 것으로 보이고 오픈 소스 활동 또한 Github 계정을 통해 모두 노출된다. 기술 커뮤니티에서의 활동 내역은 장인을 찾는데 도움이 될 것 같다. 하지만 트위터의 리트윗충(개인 블로그니 막말한다)이나 페이스북 커뮤니티에는 매우 낮은 수준의 글에도 따봉충이 따르는 경우가 있기 때문에 주의를 요한다. 회사에 다니면 컨퍼러스 참여에 한계가 올텐데 이 부분에 대한 우리나라 회사의 문화(일반화의 오류 일지도?)를 생각했을 때는 컨퍼런스충을 잘 걸러야 장인을 찾을 수 있을 것으로 보인다.면접 질문* 수수께기 문제를 내어 면접자를 바보로 만들어선안된다. * 버스안에 골프공이 몇개 들어가냐같은 잘문으로 뭘 판단하려는 건지 전혀 모르겠다. * 코딩 * 손으로 코딩문제를 풀게한다. * 글씨체를 테스트 하는 것인가? 굳이 왜 나쁜 환경에서 문제를 내는 것인가. * 인터넷을 못하게 한다. * 왜? * 알고리즘 문제를 낸다. 공부해도 잊혀진다. 내 기억력을 테스트 하려는 것인가? 알고리즘은 답이 나와있는 문제다. 인터넷에 공유되어 있다. 이런 문제에 대한 답은. 직군에 따라서는 알고리즘 문제가 나오는 것도 이해한다. 소프트웨어 장인정신은 애자일, 린, XP등과 맥락을 함께 하는 점이 꽤 된다 소프트웨어 장인정신은 실행관례로써 XP를 지지한다. XP를 지지하는 만큼 책 전반에 걸쳐 TDD에 대한 언급이 상당히 많으며 페어프로그래밍을 하라고 하고 있다.사실 경험적으로도 레거시 코드를 가지고 요구사항과 일정이 빡빡한 프로젝트를 만나게 되면 TDD의 중요성을 느끼게 된다. 프론트엔드 테스트 자동화가 쉽지 않은데 테스트 코드 위주로 코드를 짜지 않으면 추후 리펙토링 때 히스토리 운운하며 사이드 이펙트 날 까봐 아무 것도 건드리지 못하고 예외처리의 예외처리를 해서 코드량이 익스포넨셜하게 증가하는 매직이 일어나게 된다.많은면에서 생각이 비슷해서 놀랬다. 회사와 장인은 서로 계약관계로 서로를 평가하고 서로 이해관계가 맞아야한다. 이외에도 기술적으로 장인이 되기 위한 글도 있고 해서 지금 앞이 보이지 않거나 뭔가 막혀 있다고 생각하면 생각을 열어 줄 수 있는 기회를 얻을 수 있을 지도 모르겠다.","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"ts","slug":"dev/ts","permalink":"http://blog.bglee.me/categories/dev/ts/"}],"tags":[{"name":"소프트웨어 장인","slug":"소프트웨어-장인","permalink":"http://blog.bglee.me/tags/소프트웨어-장인/"},{"name":"프로페셔널리즘","slug":"프로페셔널리즘","permalink":"http://blog.bglee.me/tags/프로페셔널리즘/"},{"name":"실용주의","slug":"실용주의","permalink":"http://blog.bglee.me/tags/실용주의/"},{"name":"자부심","slug":"자부심","permalink":"http://blog.bglee.me/tags/자부심/"},{"name":"애자일","slug":"애자일","permalink":"http://blog.bglee.me/tags/애자일/"},{"name":"xp","slug":"xp","permalink":"http://blog.bglee.me/tags/xp/"}]},{"title":"Git","slug":"git","date":"2016-04-11T15:00:00.000Z","updated":"2018-03-29T06:03:19.625Z","comments":true,"path":"posts/2016/git/","link":"","permalink":"http://blog.bglee.me/posts/2016/git/","excerpt":"","text":"Submodule1234567$ git init$ git add *$ git submodule add [git repo#1] [target path]$ git submodule add [git repo#2] [target path]$ git commit -m \"add submodules\"$ git remote add origin [git repo#0]$ git push -u저장소를 생성하고 서브 모듈로 두개 저장소를 가져온후 이를 리모트에 푸시한다.1234$ git clone [git repo#0] [path]$ cd [path]$ git submodule init$ git submodule update이제 다른 경로에서 아까 푸시한 리모트 경로를 클론하고 서브 모듈까지 모두 내려받는다.123456789101112$ tree├── /│ ├── /submodule-01│ │ ├── sub01.file01│ │ └── sub01.file02│ │ ├── sub01.file03│ │ └── sub01.file04│ └── /submodule-02│ ├── sub02.file01│ └── sub02.file02├── root.file01└── root.file02[git repo#0]을 기준으로 하면 커밋된 파일은 root.file01 root.file02 submodule-01 submodule-02가 된다. submodule들의 폴더만을 가지며 하위 폴더는 submodule 내 각자의 저장소에서 처리된다. 폴더가 커밋되는 이유로는 리비전 정보를 가지기 때문인 것으로 보인다.","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"git","slug":"dev/git","permalink":"http://blog.bglee.me/categories/dev/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://blog.bglee.me/tags/git/"},{"name":"submodule","slug":"submodule","permalink":"http://blog.bglee.me/tags/submodule/"}]},{"title":"JavaScript","slug":"javascript","date":"2016-04-11T15:00:00.000Z","updated":"2018-03-29T06:03:19.626Z","comments":true,"path":"posts/2016/javascript/","link":"","permalink":"http://blog.bglee.me/posts/2016/javascript/","excerpt":"","text":"jshint123function exam() &#123;&#125;new (Function.prototype.bind.apply(exam, [null].concat([1,2])));^ Missing ‘()’ invoking a constructor.jshint를 실행할 때 supernew 을 함께 준다.","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"js","slug":"dev/js","permalink":"http://blog.bglee.me/categories/dev/js/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.bglee.me/tags/javascript/"},{"name":"js","slug":"js","permalink":"http://blog.bglee.me/tags/js/"},{"name":"jshint","slug":"jshint","permalink":"http://blog.bglee.me/tags/jshint/"}]},{"title":"slackbot","slug":"slackbot","date":"2016-04-11T15:00:00.000Z","updated":"2018-03-29T06:03:19.632Z","comments":true,"path":"posts/2016/slackbot/","link":"","permalink":"http://blog.bglee.me/posts/2016/slackbot/","excerpt":"","text":"hubot과 연동해서 slack에서 귀찮은 일들을 대신해줄 봉봇(bongbot)을 만들기로 했다.12345npm install -g yo generator-hubotmkdir slackbotcd slackbotyo bongbotvi bin/hubot1234export HUBOT_SLACK_TOKEN=[TOKEN]# export HUBOT_SLACK_TEAM=[TEAM]# export HUBOT_SLACK_BOTNAME=[BOTNAME]# export HUBOT_LOG_LEVEL=[LOG_LEVEL]HUBOT_SLACK_TOKEN은 https://slack.com/apps/에서 생성할 수 있다.12npm install./bin/hubot --adapter slack그리고…봉봇1234git clone https://github.com/deptno/bongbot.gitcd bongbotnpm install./bin/hubotrefs:https://github.com/github/hubot/blob/master/docs/index.md","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"js","slug":"dev/js","permalink":"http://blog.bglee.me/categories/dev/js/"}],"tags":[{"name":"slack","slug":"slack","permalink":"http://blog.bglee.me/tags/slack/"},{"name":"slackbot","slug":"slackbot","permalink":"http://blog.bglee.me/tags/slackbot/"}]},{"title":"OhMyZsh","slug":"ohmyzsh","date":"2016-04-11T15:00:00.000Z","updated":"2018-03-29T06:03:19.631Z","comments":true,"path":"posts/2016/ohmyzsh/","link":"","permalink":"http://blog.bglee.me/posts/2016/ohmyzsh/","excerpt":"","text":"설치12sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"vi ~/.zshrc테마를 수정한다.ZSH_THEME=&quot;agnoster&quot; # (this is one of the fancy ones)테마가 특수한 문자 코드를 사용하기 때문에 패치된 폰트가 필요하다. VIM 설정에서도 추가적인 폰트를 필요하므로 그 쪽을 참고한다.안이쁘면 코딩 능력 발현이 안되므로 iTerm2의 설정에 들어가서 색상팔레트를 설정한다. 필자는 Tango Dark로 설정한다.refs:https://github.com/robbyrussell/oh-my-zsh","categories":[{"name":"setup","slug":"setup","permalink":"http://blog.bglee.me/categories/setup/"}],"tags":[{"name":"ohmyzsh","slug":"ohmyzsh","permalink":"http://blog.bglee.me/tags/ohmyzsh/"},{"name":"zsh","slug":"zsh","permalink":"http://blog.bglee.me/tags/zsh/"}]},{"title":"requirejs","slug":"requirejs","date":"2016-04-11T15:00:00.000Z","updated":"2018-03-29T06:03:19.632Z","comments":true,"path":"posts/2016/requirejs/","link":"","permalink":"http://blog.bglee.me/posts/2016/requirejs/","excerpt":"","text":"build.js123456789(&#123; baseUrl: \".\", paths: &#123; jquery: \"1\", jhary: \"2\" &#125;, include: ['1','2'], out: \"main-built.js\"&#125;)1r.js -o build.js optimize=nonemain-built.js12345678define('1',[], function() &#123; return 1;&#125;);define('2',[], function() &#123; return 2;&#125;);","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"js","slug":"dev/js","permalink":"http://blog.bglee.me/categories/dev/js/"}],"tags":[{"name":"r.js","slug":"r-js","permalink":"http://blog.bglee.me/tags/r-js/"},{"name":"requirejs","slug":"requirejs","permalink":"http://blog.bglee.me/tags/requirejs/"}]},{"title":"TypeScript","slug":"typescript","date":"2016-04-11T15:00:00.000Z","updated":"2018-03-29T06:03:19.633Z","comments":true,"path":"posts/2016/typescript/","link":"","permalink":"http://blog.bglee.me/posts/2016/typescript/","excerpt":"","text":"requirejs.config paths관련 하여 alias된 모듈 로드TypeScript로 작업을 작업을 한다라면 여러 문제들이 부딪히게 될 텐데 대 부분 문제들의 시작은 아마 JavaScript를 TypeScript로 포팅하면서 시작 될 것이다. 그에 대한 정리다.requirejs.config paths관련 하여 alias된 모듈 로드이미 프로젝트가 RequireJS를 사용하여 의존성 관리를 하고 있다면 의존성에 관한 경로 문제를 겪을 수 있다. 문제의 원인은 TypeScript는 컴파일을 하는 언어고 런타이밍에 세팅되는 requirejs.config 함수의 설정을 모르기 때문이다. 코드를 보자1234567// config.jsrequirejs.config(&#123; paths: &#123; \"jquery\": \"lib/jquery\" &#125;&#125;);&#125;)paths를 통해 “jquery” 위치를 정의한다.12345import * as $ from \"jquery\";$(function() &#123; console.log(\"document ready\");&#125;);ts파일을 작성한다.1tsc main.ts --m amdmain.ts(1,20): error TS2307: Cannot find module ‘jquery’.모듈을 찾을 수 없다는 에러메시지가 발생하지만 main.js파일은 의도한 대로 생성된다.123456define([\"require\", \"exports\", \"jquery\"], function (require, exports, $) &#123; \"use strict\"; $(function () &#123; console.log(\"document ready\"); &#125;);&#125;);의도한 대로 파일이 생성됐다. 문제는 컴파일 에러가 나는 부분인데 config.js 파일의 내용을 주입시킬 수 있는 방법이 없다.TypeScript 1.8에서 도입된 AMD-dependency 구문을 통해 해결 할 수 있게 됐다. 일단 구문을 모자1/// &lt;amd-dependency path=\"lib/jquery\" /&gt;위 주석(?)을 파일 윗줄에 삽입함으로서 의존성을 삽입가능한데 일단 import 구문을 통했을 때와 차이를 알아야한다. 다시 컴파일을 하면 일단 $에 대한 오류가 당연히 발생하게 된다.main.ts(3,1): error TS2304: Cannot find name ‘$’.123456define([\"require\", \"exports\", \"lib/jquery\"], function (require, exports) &#123; \"use strict\"; $(function () &#123; console.log(\"document ready\"); &#125;);&#125;);에러와 함께 컴파일된 js파일이다. 모듈은 로딩 되었는데 참조가 불가능하다. 이에 대한 문제를 해결 할 수 이도록 name 프로퍼티가 1.8에 들어가게 되었다.12/// &lt;amd-dependency path=\"lib/jquery\" name=\"$\"/&gt;declare var $;name에 $를 지정해주고 실제 코드에서 사용할 수 있도록 declare var $; 구문을 주석 아래쪽에 삽입하여 TS2304 에러코드를 해결한다.123456define([\"require\", \"exports\", \"lib/jquery\"], function (require, exports, $) &#123; \"use strict\"; $(function () &#123; console.log(\"document ready\"); &#125;);&#125;);의존성과 컴파일 에러 모드 해결되었다.search-response.ts(2,15): error TS2307: Cannot find module &#39;lodash&#39;.1import _ from 'lodash';es6 방식의 export가 지원 되지 않아 생기는 에러로 보인다.1import * as _ from &apos;lodash&apos;위와 같이 해결한다.","categories":[{"name":"dev","slug":"dev","permalink":"http://blog.bglee.me/categories/dev/"},{"name":"ts","slug":"dev/ts","permalink":"http://blog.bglee.me/categories/dev/ts/"}],"tags":[{"name":"requirejs","slug":"requirejs","permalink":"http://blog.bglee.me/tags/requirejs/"},{"name":"typescript","slug":"typescript","permalink":"http://blog.bglee.me/tags/typescript/"},{"name":"amd","slug":"amd","permalink":"http://blog.bglee.me/tags/amd/"},{"name":"amd-dependency","slug":"amd-dependency","permalink":"http://blog.bglee.me/tags/amd-dependency/"}]},{"title":"프로 AngularJS","slug":"book_pro_angularjs","date":"2016-01-31T15:00:00.000Z","updated":"2018-03-29T06:03:19.624Z","comments":true,"path":"posts/2016/book_pro_angularjs/","link":"","permalink":"http://blog.bglee.me/posts/2016/book_pro_angularjs/","excerpt":"","text":"이 문서는 AngluarJS를 빠르게 읽히기 위해 예제코드를 눈으로만 읽으며 정리한 개인 노트다.환경 셋업서버Chapter 7: 스포츠 상점: 내비게이션 및 결제directivefilterProviderChatper 8: 스포츠 상점: 주문 및 관리자 기능directive폼 유효성AngularJS 활용Chapter 9: AngularJS 앱 해부팩터리 함수와 작업자 함수컴포넌트 별 작업자 함수 인자서비스값 정의모듈의 의존성config, run 메서드Module.config 메서드Module.run 메서드상수 정의Chapter 10: 바인딩 및 템플릿 디렉티브 활용디렉티브 적용 방법데이터 바인딩 디렉티브템플릿 디렉티브Chapter 11: 엘리먼트 및 이벤트 디렉티브 활용엘리먼트 디렉티브이벤트 디렉티브내장변수불리언 어트리뷰트 디렉티브기타 어트리뷰트Chapter 12: 폼 활용Chapter 13: 컨트롤러 및 스코프 활용스코프리스 컨트롤러명시적 스코프 업데이트Chapter 14: 필터 활용단일 값 내장 필터컬렉션 필터링항목 정렬필터 체인커스텀 필터 구현Chapter 15: 커스텀 디렉티브 구현표현식 평가데이터 변화 처리jqLite 활용jqLite -&gt; jQueryChapter 16: 고급 디렉티브 구현디렉티브 스코프 관리Chapter 17: 고급 디렉티브 기능트랜스클루전 활용컴파일 함수 활용디렉티브 내 컨트롤러 활용기타 디렉티브 추가Chapter 18: 모듈 및 서비스 활용서비스 생성AngularJS 내장 서비스Chapter 19: 전역 객체, 에러, 표현식을 위한 서비스DOM API 전역 객체 접근HTML5 URL 활용위험한 데이터 처리AngularJS 표현식 및 디렉티브 활용Chapter 20: Ajax 서비스 및 프로미스Ajax 요청 설정Ajax 기본값 설정Ajax 인터셉터 활용프로미스의 활용Chapter 21: REST 서비스$http 서비스의 활용Ajax 요청 숨기기데이터 객체 수정새 객체 생성$resource 서비스 행동 설정resource 활용에 적합한 컴포넌트 구현비동기적 데이터 함정 피하기Chapter 22: 뷰를 위한 서비스ngRoute라우트 및 라우트 파라미터 접근라우트 설정Chapter 23: 애니메이션 및 터치를 위한 서비스ngAnimation모듈 설치애니메이션의 정의 및 적용병렬적 애니메이션의 위험성터치 이벤트 지원Chapter 24: 프로비전 및 주입을 위한 서비스AngularJS 컴포넌트 등록주입 관리Chapter 25: 단위 테스트source code환경 셋업서버deployd를 사용한다.12$ dpd create sportsStore$ dpd -p 5500 sportsstore\\app.dpd dashboradChapter 7: 스포츠 상점: 내비게이션 및 결제directiveng-showng-hideng-include[src]ng-viewfilterorderByuniqueProviderrouteProvider: ngRouteng-view에 들어가게되는 라우팅 테이블을 관리프로바이더 명명법은 서비스명 + ProviderChatper 8: 스포츠 상점: 주문 및 관리자 기능directiveng-modelform[novalidate]: 브라우저의 검증 기능을 사용하지 않는다.input[required]: 값이 있어야한다button[ng-disabled]ng-class=”{‘classname’: item === true }”ng-repaet$index폼 유효성1234&lt;form name='myForm'&gt; &lt;input ng-model='object.model' require /&gt;myForm.$invalidobject.model.$error2016-01-16 추가AngularJS 활용Chapter 9: AngularJS 앱 해부팩터리 함수와 작업자 함수컴포넌트를 설정하고 싶을 때 팩터리 함수를 호출하고, 컴포넌트를 적용하는 시점에 작업자 함수가 호출된다.123app.directive(\"directiveName\", function 팩터리함수() &#123; return function 작업자함수(scope, element, attrs) &#123;&#125;;&#125;);컴포넌트 별 작업자 함수 인자123456// directivereturn function(scope, element, attrs) &#123;&#125;;// filterreturn function(input) &#123; return 'modified input data';&#125;;정의된 필터도 팩터리 함수에서 $filter 를 인젝션하여 사용할 수 있다.서비스서비스는 싱글턴 이다.서비스를 정의 하는 방법에는 세 가지 메서드가 존재한다.servicefactoryprovider값 정의상수 정의를 위해 constant가 사용되는데 아직은 차이를 모른다. 오버 스펙느낌인듯…Module.value(‘valueName’, ‘value’) 를 통해 정의된다.모듈의 의존성1angular.module('testApp', ['testApp.filter', 'testApp.directive']);위와 같이 testApp 모듈을 정의 하고 의존성으로 ‘testApp.filter’, ‘testApp.directive’ 모듈을 선언하게 되면 ‘testApp.filter’, ‘testApp.directive’ 모듈간 상호 참조가 가능하게 되는 것으로 보인다.(서로간의 정의에서 의존성 주입이 가능하다는 말)모듈의 의존성을 선언하게 되면config, run 메서드Module.config 메서드현재 모듈이 로드 될 대 호출된다.Module.run 메서드모든 모듈이 로드될 때 해출된다.말이 애매한데 run은 모든 의존성이 해결된 뒤에 호출되는 것으로 보인다. 타 모듈에 대한 의존성 주입이 해결된 후에 호출되며 config는 그 이전에 호출되는 차이가 있는 것으로 보인다.상수 정의1Module.constant('name', 'value');값 정의와는 달리 Module.config에서 주입이 가능하다.Chapter 10: 바인딩 및 템플릿 디렉티브 활용디렉티브 적용 방법1234//어트리뷰트&lt;span ng-bind=\"todos.length\"&gt;&lt;/span&gt;//클래스&lt;span class=\"ng-bind: todos.length\"&gt;&lt;/span&gt;데이터 바인딩 디렉티브ng-bindng-bind-htmlng-bind-templateng-modelng-non-bindable템플릿 디렉티브ng-clockng-includeng-repeatng-repeat-startng-repeat-endng-switchng-repeat{{ item in array }}, {{ (key, value) in object }} 등의 방식으로 쓰일 수 있으며 내장변수는 아래와 같다.$index$first$middlelast$even$oddng-repeat-start엘리먼트 하나를 기준으로 반복하는 것이 아니라 여러 형제 엘리먼트(Sibling)가 있어 이를 함께 반복해야 하는 경우라면 사용한다.ng-repeat-end 를 만날때까지 반복된다.ng-include외부 파일을 로드 할 수 있게 한다. 몇 가지 어트리뷰트를 설정해서 사용한다.srconloadautoscrollng-switch컨텐츠를 상황에 따라 전환할 때 사용한다.on어트리뷰트를 통해 변수를 설정하고(object타입만 가능 할 수 있다.)1234&lt;ng-switch on='object.data'&gt;&lt;div ng-switch-when='value1'&gt;&lt;/div&gt;&lt;div ng-switch-when='value2'&gt;&lt;/div&gt;&lt;div ng-switch-default&gt;&lt;/div&gt;를 통해 변수값이 when과 맞으면 그 뷰를 보여주도록 설정한다.ng-clock앵귤라가 처리하는 동안 인라인 템플릿이 그대로 노출되는 시간이 아주 짧게 존재하는데 이 시간동안 css를 통해 보이지 않도록 처리해주는 어트리뷰트형 디렉티브다.2016-01-20 추가Chapter 11: 엘리먼트 및 이벤트 디렉티브 활용엘리먼트 디렉티브ng-ifng-classng-class-evenng-class-oddng-hideng-showng-styleng-ifng-hide와는 다르게 실제로 DOM에서 엘리먼트를 제거한다.ng-repeat과 함께 사용할 수 없다이벤트 디렉티브ng-blurng-changeng-clickng-copyng-cutng-pasteng-dblclickng-focusng-keydownng-keyupng-mousedownng-mouseenterng-mouseleaveng-mousemoveng-mouseoverng-mouseupng-submit내장변수$event불리언 어트리뷰트 디렉티브ng-checkedng-disabledng-openng-readonlyng-selected기타 어트리뷰트ng-hrefng-srcng-srcset2016-01-21 추가Chapter 12: 폼 활용form tagfrom 태그는 유효성 검증을 필요로 요구된다.어트리뷰트novalidateng-submit유효성 검증 변수$pristine$dirty$valid$invalid$error유효성 검증 변수는 form 엘리먼트에 지정한 name 어트리뷰트의 값을 통해 접근이 가능하다상호작용 태그에 클래스가 자동으로 적용된다.클래스 명ng-pristineng-dirtyng-validng-invalidng-invalid-email 과 같은 클래스 언급이 있는데 이 부분도 확인해봐야한다.inputtype에 매핑되는 어트리뷰트 값checkboxemailnumberradiotexturlAngularJS에서 제공되는 어트리뷰트 디렉티브(input, textarea)ng-modelng-changeng-minlengthng-maxlengthng-patternng-requiredinput 엘리먼트의 타입이 email, number, url일 경우 내부적으로 ng-pattern이 적용되므로 이 둘은 함께 사용하지 말아야한다.type이 checkbox 인 경우 사용가능한 어트리뷰터 디렉티브ng-modelng-changeng-true-valueng-false-valueng-true-value와 ng-false-value는 체크 박스의 선택에 따라 ng-model에 들어갈 값을 결정한다.selectng-optionsng-options=”‘item.action for item in items’” 와 같은 형태로 사용되며 item.action 부분이 라벨이 된다.ng-options=”‘item.id as item.action for item in items’” 와 같은 형태로 사용하면 item.id 부분이 라벨이 된다.ng-options=”‘item.action group by item.place for item in items’” 와 같은 형태로 사용하면 item.place로 그룹 정렬이 된다.as 와 group by 는 병행이 가능하다.Chapter 13: 컨트롤러 및 스코프 활용ng-controller디렉티브를 통해 지정되며123Module.controller('controllerName', function($scope) &#123; $scope.fx = function() &#123; alert(); &#125;;&#125;);와 같이 사용된다. $scope 아래로 달리는 함수는 뷰(DOM)에서 디렉티브를 통해 호출이 가능하다. ng-controller 디렉티브에이 의해서 컨트롤의 팩터리함수가 호출되고 인스턴스화된다.컨트롤러에서 사용되는 내장 서비스$rootScropt$scope$scope구현상 $scope는 서비스는 아니며 $rootScope에서 제공하는 하나의 객체다$rootScope내장 서비스로 $scope 들과 연결되어 있어 $scope 간에 통신을 가능하게 한다.이벤트 메서드$broadcast(name, args)$emit(name, args)$on(name, handler)$broadcast는 아래로 $emit은 위로 이벤트를 전달하며 $on은 받는 역할을 한다.controller는 돔 구조와 동일하게 부무, 자식 관계가 정립되며 이 순수에 의해 그대로 상속되며 오버라이딩이 가능하다.스코프리스 컨트롤러123Module.controller('scopelessCtrl', function() &#123; this.fx = function() &#123; alert(); &#125;;&#125;);1&lt;div ng-controller=\"scopelessCtrl as ctrl\"&gt;명시적 스코프 업데이트$apply(expression)$watch(expression, handler)$watCollection(object, handler)AngularJS 외부에서의 업데이트를 통해 스코프가 업데이트 되지 않을 경우 명시적으로 업데이트 할 수 있다.1angluar.element('#selector').scope().$apply('variableInScope()');Chapter 14: 필터 활용필터는 데이터가 뷰에 표시되기전에 거치게 된며 파이프를 사용해 다중으로 적용 가능하다.단일 값 내장 필터currencydatejsonnumberuppercaselowercasecurrency123456789&#123;% raw %&#125;&#123;&#123; value | currency &#125;&#125;&#123;&#123; value | currency:\"£\" | number:0 &#125;&#125;&#123;&#123; value | date:\"dd MMM yy\" &#125;&#125;&#123;&#123; value | date:\"shortDate\" &#125;&#125;&#123;&#123; value | uppercase &#125;&#125;&#123;&#123; value | lowercase &#125;&#125;&#123;&#123; object | json &#125;&#125;&#123;% endraw %&#125;컬렉션 필터링limitTo음수를 지정할수도 잇는데 이 경우에는 뒤부터 정렬된다.1&lt;div ng-repeat=\"p in products | limitTo:'5'\"&gt;filterfilter가 필터명이다. 오프젝트에서 키 밸류가 일치하는 값으로 필터링한다.123$scope.filterFunction = function(item) &#123; return item.category === 'Fish';&#125;12&lt;div ng-repeat=\"p in products | filter: &#123; key: 'value' &#125;\"&gt;&lt;div ng-repeat=\"p in products | filter: filterFunction\"&gt;항목 정렬orderBy123$scope.myCustomSorter = function(item) &#123; return item.expiry &lt; 5 ? 0 : item.price;&#125;1234&lt;div ng-repeat=\"p in products | orderBy:'price' &#125;\"&gt;&lt;div ng-repeat=\"p in products | orderBy:'-price' &#125;\"&gt;&lt;div ng-repeat=\"p in products | orderBy:myCustomSorter &#125;\"&gt;&lt;div ng-repeat=\"p in products | orderBy:[myCustomSorter, '-price'] &#125;\"&gt;정렬값이 같을 경우 배열을 이용해 두번째 소트옵션을 활용해 정렬할 수 있다.필터 체인파이프를 이용해 순차적, 연속적으로 필터를 적용한다.1&lt;div ng-repeat=\"p in products | orderBy:[myCustomSorter, '-price'] | limitTo: 5 &#125;\"&gt;커스텀 필터 구현첫번째 인자는 이름 두번째 인자는 팩터리함수로 작업자 함수를 리턴한다.12345Module.filter('filterName', function() &#123; return function(input, argument) &#123; return 'output'; &#125;;&#125;);필터를 정의하면서 기존의 필터를 가져와 사용이 가능하다.123456Module.filter('filterName2', function($filter) &#123; return function(input, argument) &#123; var firstFilter = $filter('filterName')(input, argument); return $filter(\"limitTo\")(firstFilter, 2); &#125;;&#125;);2016-01-22 추가Chapter 15: 커스텀 디렉티브 구현Module.directive를 통해서 선언 가능하며 카멜 케이스로 선언하고 DOM에서 사용할 때는 - 로 구분하고 소문자로 쓰게 된다.디렉티브의 링크 함수중 element인자는 jqLite 객체다.12345Module.directive('directiveName', function() &#123; return function(scope, element, attrs) &#123; var value = attrs['directiveName']; // 'test' &#125;;&#125;)12&lt;div directive-name='test'&gt;&lt;/div&gt;&lt;div data-directive-name='test'&gt;&lt;/div&gt;표현식 평가디렉티브의 사용 유저가 필터등을 사용할때는 디렉티브내에서 표현식을 평가해야한다.1&lt;div directive-name='price | currency'&gt;&lt;/div&gt;12345Module.directive('directiveName', function() &#123; return function(scope, element, attrs) &#123; var expression = scope.$eval(attrs['directiveName']); &#125;;&#125;)데이터 변화 처리링크 함수 내에서 와처류의 함수를 통해 변화를 업데이트하도록 한다.jqLite 활용jQuery와 유사하니 대부분 패스하고 이벤트 처리등 몇가지 메서드만 정리한다.on(events, handler)off(events, handler)triggerHandler(event)data(key, value)data(key)removeData(key)jqLite를 통한 AngularJS 기능 접근controller()controller(name)injector()isolatedScope()scope()inheritedData(key)jqLite -&gt; jQueryjqLite로 불편하면 angularjs 파일 로딩 전 jQuery를 로딩하면 대체됨.2016-01-23 추가Chapter 16: 고급 디렉티브 구현커스텀 디렉티브를 커스터마이징하기 위해 팩터리 함수(링크 함수)를 반환하는 대신 정의 객체를 반환해야한다. 링크 함수를 반환할 경우는 어튜리뷰트 방식의 적용만 가능한 디렉티브가 된다.정의 객체 속성comiplecontrollerlinkreplacerequirerestrictscopetemplatetemplateUrltranscluderestrict123return &#123; restrict: \"EACM\"&#125;E: 엘리먼트 형태의 적용A: 어트리뷰트 형태의 적용C: 클래스 형태의 적용M: 주석 형태의 적용1234&lt;unordered-list list-source=\"products\" list-property=\"price | currency\" /&gt;&lt;div unordered-list=\"products\" list-property=\"price | currency\" /&gt;&lt;div class=\"unordered-list: products, price | currency\" /&gt;&lt;!-* directive: unordered-list products --&gt;CM은 거의 사용되지 않는다. M의 경우 링크 함수에서 nodeName이 ‘#comment’인 것을 찾아 부모 엘리먼트에 생성하고자 하는 엘리먼트를 붙이는 방식으로 진행된다.template링크에서 엘리먼트를 생성하지 않고 template 프로퍼티에 엘리먼트의 innerHTML 에 대입하는 것과 마찬가지로 HTML코드를 대입할 수 있고 함수를 지정할 수도 있다.1234567891011&#123;% raw %&#125;return &#123; template: \"&lt;ul&gt;&lt;li ng-repeat='item in data'&gt;&#123;&#123;item.price&#125;&#125;&lt;/ul&gt;\"&#125;// orreturn &#123; template: function() &#123; return angular.element(document.querySelector(\"#listTemplate\")).html(); &#125;&#125;&#123;% endraw %&#125;templateUrl123456789return &#123; templateUrl: \"itemTemplate.html\"&#125;// orreturn &#123; templateUrl: function(elem, attrs) &#123; return attrs[\"template\"] == \"table\" ? \"a.html\" : \"b.html\"; &#125;&#125;일전에 책을 15, 16, 17장(커스텀 디렉티브 관련)만 읽고 https://github.com/deptno/autocomplete_hangul 를 연습삼아 만들어봤는데 templateUrl을 사용하게 되면 배포시에는 경로가 index.html(메인 파일)을 기준으로 정렬되면서 링크가 깨지고 만다. 빌드 툴 등을 이용해서 template 로 최종 배포시에는 넣는 것이 맞아보인다.replace123return &#123; replace: true&#125;생성되는 html은 아래와 같이 달라진다.123456// replace undefined&lt;div user-directive&gt; &lt;table&gt;&lt;/table&gt;&lt;/div&gt;// replace true&lt;table user-directive&gt;&lt;/table&gt;ng-repeat등과 유용하게 쓸 수 있다고 책은 기술하고있다.디렉티브 스코프 관리기본적으로 상위 컨트롤러의 스코프를 상속한다.디렉티브 스코프 생성123return &#123; scope: true&#125;123&lt;div ng-controller='userCtrl'&gt; &lt;div user-directive&gt;&lt;/div&gt;&lt;/div&gt;위와 같은 경우의 스코프는 디렉티브 스코프 &lt; 컨트롤러 스코프 &lt; 루트 스코프 순이 된다.고립 스코프 생성1234567return &#123; scope: &#123; local: \"@onewaybinding\", local2: \"=twowaybinding\", localFn: \"&amp;userFunction\" &#125;&#125;12345&#123;% raw %&#125;&lt;div user-directive onewaybinding=\"&#123;&#123;data.name&#125;&#125;\" twowaybinding=\"data.other\" userFunction=\"functionNameInScope(userArgument)\"&gt; &#123;&#123; localFn(&#123; userArgument: local &#125;) &#125;&#125;&lt;/div&gt;&#123;% endraw %&#125;@ 단방향, = 양방향, &amp; 함수바인딩을 제공하는데 &amp;가 살짝 애매하다 실제 사용할때는 레퍼런스를 찾아봐야할 듯하다.Chapter 17: 고급 디렉티브 기능트랜스클루전 활용트랜스클루전이라는 용어는 참조를 통해 문서 영역의 일부를 다른 문서에 삽입하는 것이라고 되어있다.책을 읽어보면 대단히 특이한 기능으로 보이는데 디렉티브를 선언한 엘리먼트가 디렉티브로 교체되고 디렉티브 내의 ng-transclude 디렉티브가 디렉티브를 선언했던 디렉티브로 교체된다.123456789101112131415&#123;% raw %&#125;&lt;script type=\"text/ng-template\" id=\"template\"&gt; &lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;This is the panel&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\" ng-transclude&gt;&lt;/div&gt; &lt;/div&gt;&lt;/script&gt;...&lt;body ng-controller=\"upperCtrl\"&gt;&lt;div user-directive&gt; &#123;&#123;forScopeTest&#125;&#125;&lt;/div&gt;&#123;% endraw %&#125;디렉티브에서 template를 통해 참조할 돔트리를 작성하고 transclude를 확인할 user-directive 를 선언해다.1234567891011121314Module.directive('userDirective', function() &#123; return &#123; template: function() &#123; return document.querySelector(\"#template\").html(); &#125;, link: function(scope) &#123; scope.forScopeTest = 'directive'; &#125;, scope: true, restrict: \"E\", transclude: true, //transclude: element &#125;&#125;)js파일에서는 디렉티브를 정의한다.123456789101112&#123;% raw %&#125;...&lt;body ng-controller='upperCtrl'&gt;&lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;This is the panel&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &#123;&#123;forScopeTest&#125;&#125; &lt;/div&gt;&lt;/div&gt;&#123;% endraw %&#125;책을 읽고 이해한 바로는 위와 같은 형태의 기능을 트렌스클루젼이라 한다. forScopeTest라는 인라인 바잉딩 표현식이 있는데 디렉티브 선언시에 scope를 true로하여 디렉티브 스코프를 생성한 경우에도 forScopeTest 데이터는 upperCtrl에서 가져오게 된다. false로 한 경우에는 forScopeTest 표현식에서 ‘directive’가 들어가 있는 것을 확인할 수 있다.정리하면 transclude가 true인 디렉티브 를 선언한 엘리먼트의 컨트롤러 스코프 데이터만을 사용한다는 것이다. 이것은 transclude를 사용하지 않았을 경우와 동일하며 디렉티브 스코프를 false로 한경우 디렉티브의 링크 함수는 컨트롤러의 스코프를 가져오게되므로 표현식에 영향을 미칠 수 있게 된다.transclude를 true로 하면 엘리먼트의 컨텐츠만 감싸게 되는데 이를 element 로 하게되면 엘리먼트 자체를 감싸게 된다.컴파일 함수 활용책을쓴 저자는 개인적으로 컴파일 함수를 사용하는 것을 선호하지 않는다고 밝히고 있다. 컴파일 함수를 정의하게 되면 링크함수의 정의는 무시되고 컴파일 함수가 리턴하는 함수가 링크 함수로 대체된다.123456789101112Module.directive('userDirective', function() &#123; return &#123; compile: function(element, attrs, transcludeFn) &#123; return function($scope, $element, $attrs) &#123; var parent = $element.parent(); transcludeFn($scope.$new(), function(clone) &#123; parent.append(clone); &#125;); &#125; &#125; &#125;&#125;)compile에는 3번째 함수로 transclude에 사용되는 함수가 오게되는데 책의 내용만으로는 이해가 어렵다. 책에서는 디렉티브 선언에 template가 빠져있다. 첫번째인자는 스코프, 두번째 인자는 트랜스클루젼이 적용된 돔이 오게 될 것 같은데 정보가 온전치 않다.디렉티브 내 컨트롤러 활용12345678910111213141516171819Module .directive('userDirective', function() &#123; return &#123; transclude: true, controller: function($scope, $element, $attrs) &#123; this.updateTotal = function() &#123; $scope.total = 1; &#125;; &#125; &#125; &#125;) .directive('userDirective2', function() &#123; return &#123; require: \"^userDirective\", link: function(scope, element, attrs, ctrl) &#123; ctrl.updateTotal(); &#125; &#125; &#125;)디렉티브에 컨트롤러를 정의할 수 있다. require 속성에서 디렉티브 의존성을 선언하게 되며 의존성 앞에 접두어를 사용할 수 있다.접두어가 없는 경우 두 디렉티브가 같은 엘리먼트에 적용된다고 가정한다.^: 디렉티브가 적용된 엘리먼트의 부모 일레먼트에서 다른 디렉티브를 찾는다.?: 디렉티브를 찾을 수 없더라도 에러를 보고하지 않는다(사용에 주의를 요한다).link함수에서의 ctrl 인자는 의존성 인자가 아니므로 다른 이름을 사용해도 상관없다.컨트롤러 함수에서 넘겨받는 $scope 인자는 컨트롤러를 정의하는 디렉티브의 스코프인데 이 부분은 실제 적용을 하면서 확인을 해봐야할 듯 하다.기타 디렉티브 추가requrie 속성을 통해 종속성을 선언할때 기존 내부 디렉티브를 지정할 수도 있다.ngModel기본 메서드 및 속성$render(): 데이터 바인딩 값이 변할때 UI를 업데이트하기 위해 호출된다.$setViewValue(value): 데이터 바인딩 값을 업데이트한다.$viewValue: 디렉티브를 통해 표시할 포매팅 된 값.$modelValue: 스코프로 부터 포매팅되지 않은 값.$formatters: $modelValue를 $viewValue로 포매팅하는 포매터 함수 배열.ngModel 컨트롤러 에서 제공하는 유효성 검증 메서드 및 속성$setPristine(): 컨트롤러의 유효성 검증 상태를 초기로 되돌려 유효성 검증 수행이 되지 않게 한다.$isEmpty(): 컨트롤에 값이 없을때 이를 알리기 위해 디렉티브에서 설정할 수 있다.$parsers: 모델 값의 유효성을 검증하는데 사용할 함수 배열$error: 유효성 검증 에러에 대응되는 속성을 지닌 객체를 반환한다.$pristine: 사용자가 컨트롤을 수정하지 않은 경우 true$dirty: 사용자가 컨트롤을 수정한 경우 true$valid: 모델이 유효한 경우 true$invalid: 모델이 유효하지 않은 경우 true12345678910111213141516Module.directive(\"triButton\", function() &#123; return &#123; replace: true, require: \"ngModel\", template: \"tags in here\", link: function(scope, element, attrs, ctrl) &#123; var validateParser = function(value) &#123; var valid = (value == \"Yes\" || value == \"no\"); ctrl.$setValidity(\"confidence\", valid); return valid ? value : undefined; &#125; ctrl.$parsers.push(validateParser); &#125; &#125;&#125;)123&lt;form name=\"myForm\" novalidate&gt; &lt;div&gt;&lt;tri-button name=\"decision\" ng-model=\"dataValue\"/&gt;&lt;/div&gt;&lt;/form&gt;전반적으로 내용이 어렵고 실제로 해보기전에는 파악이 어렵다. 모듈을 생산할 때는 필수적인 내용이니 만큼 실제 코딩을 할 때는 한번 더 정독이 필요하다.2016-01-24 추가Chapter 18: 모듈 및 서비스 활용서비스는 횡단 관심사(cross-cutting concerns)를 구현하는데 쓰인다라는 SW공학책에서나 쓰일 것 같은 이해도 한번에 안가면서 모호해 보이는 언어를 사용하는데 결국 모델이나 뷰에 비종속적인 어느 곳에서나 쓰일 수 있는 프로세스의 집합체(작게는 함수)를 말하는 것으로 보인다.서비스 생성서비스를 생성하는 방법에는 세 가지가 존재한다. 방법에 상관없이 리턴된 서비스 객체는 싱글턴으로 하나의 인스턴스가 유지된다.factoryserviceproviderfactory팩터리 함수를 통해 싱글턴 객체를 리턴하는 구조로 팩터리 함수는 최초한번 실행후 리턴된 객체를 사용한다.12345678Module.factory('serviceName', function() &#123; var privateVariable = 10; return &#123; api01: function() &#123; return privateVariable; &#125; &#125;&#125;)service책에서는 new 키워드가 일반적으로 쓰이지 않는다고 설명하고 있지만 타입스크립트 와 같은 상위 셋의 언어를 사용하거나 ES6의 추세를 봤을 땐 언어 자체가 클래스 기반으로 움직이고 있기 때문에 상속이 가능한 구조로서 활용도가 매우 높을 것으로 생각하고 있다.팩터리 함수위치에 있는 함수를 new 키워드로 생성하여 사용하게 된다.123456Module.service('serviceName', function() &#123; var privateVariable = 10; this.api01 = function() &#123; return privateVariable; &#125;&#125;)provider프로바이더는 조금 특이한데 리턴된 객체의 $get 속성을 팩터리함수로 이용하여 객체를 반환한다. 이 반환하는 객체가 factory방식인지 service방식인지는 조금 더 공부를 해봐야 알겠으나 책의 예제 상으로는 factory방식으로 보이며 이런 경우라면 prototype 상속을 통한 구조화를 할 수 없으므로 활용폭이 제한되거나 팩터리 함수에서 객체를 생성해서 리턴하는 방식을 통해 가능할 것으로 생각된다. 그럼에도 불구하고 Module.config 메서드를 통해 설정을 지원하므로 유용해 보인다.1234567891011121314151617181920212223242526Module.provider('serviceName', function() &#123; var debug = false; return &#123; setDebugMode: function(set) &#123; if (set) &#123; debug = true; &#125; else &#123; debug = false; &#125; &#125; $get: function() &#123; var privateVariable = 10; return &#123; api01: function() &#123; if (debug) &#123; console.log(privateVariable); &#125; return privateVariable; &#125; &#125; &#125; &#125;&#125;).config(function(serviceNameProvider) &#123; serviceNameProvider.setDebugMode(true);&#125;);AngularJS 내장 서비스$anchorScroll$animate$compile$controller$document$exceptionHandler$filter$http$injector$interpolate$interval$location$log$parser$provide$q$resource$rootElement$rootScope$routeProvider$routeParams$sanitize$sce$swipe$timeout$window2016-01-26 추가Chapter 19: 전역 객체, 에러, 표현식을 위한 서비스DOM API 전역 객체 접근$window$document$interval$timeout$location$log$anchorScroll$window, $document단순 브라우저 전역객체인 window, document의 jqLite 래핑객체다.$interval, $timeoutwindow.setInterval, window.setTimeout을 접근하게 해주는 API로 AngularJS와의 연동을 위해 추가 기능이 정의되어 있다.$interval, $timeout 서비스와 함께 사용하는 인자fn: 실행을 지연할 함수delay: 지연 값 mscount: $interval에서 반복 횟수를 정의 0은 무한반복을 의미하며 기본값이다.invokeApply: true가 기본값이며 fn이 scope.$apply메서드 내에서 실행하게 된다.$locationwindow.location의 래퍼로. 현재 URL에 접근 가능하게 해주며 인덱스 URL(시작 URL)이 픽스되고 뒤의 # 이후를 제어할 수 있다.http://domain.com/index.html#**user/can/control?this=yes#youcan**URL은 경로, 검색어, 해시라는 3개의 구성 요소로 이루어져있다.경로: http://domain.com/index.html#**user/can/control**?this=yes#youcan검색어: http://domain.com/index.html#user/can/control?**this=yes**#youcan해시: http://domain.com/index.html#user/can/control?this=yes#**youcan**$location 서비스에서 제공하는 메서드는 아래와 같다.absUrl(): 전체 URL을 반환한다.hash(target?): 해시를 가져오거나 설정한다hoset(): 호스트네임 컴포넌트를 반환한다.path(target?): 경로 컴포넌트를 가져오거나 설정한다.port(): 포트번호를 반환한다.protocol(): URL의 프로토컬 컴포넌트를 반환한다.replace(): URL이 바뀔 때 새브라우저 히스토리가 생기는 대신 가장 최신 희스토리 항목을 대체한다.search(term?, params?): 검색어를 가져오거나 설정한다.url(target?): 경로, 쿼리 문자열, 해시를 한꺼번에 가져오거나 설정한다.$location 서비스에서 정의하는 이벤트$locationChangeStart: URL이 변경되기 전에 호출된다. Event객체에서 preventDefault 메서드를 호출하면 URL 변경을 막을 수 있다.$locationChangeSuccess123456789101112Module.controller(\"defaultCtrl\", function($scope, $location) &#123; $scope.$on(\"$locationChangeSuccess\", function(event, newUrl) &#123; $scope.url = newUrl; &#125;); $location.path(\"\"); $location.hash(\"\"); $location.search(\"\"); $location.path(\"/cities/london\"); $location.hash(\"north\"); $location.search(\"select\", \"hotels\"); $location.url(\"/cities/london?select=hotels#north\");&#125;);HTML5 URL 활용저자는 위 API들이 브라우저가 새 HTML문서를 로드하지 않게끔 #문자 이후의 URL 컴포넌트 영영을 매번 복제해야하는 것을 우아하지 않다고 지적한다. 이를 위해 HTML5 히스토리 API가 있으며 더 우아한 방식으로 문서를 재로드하지 않고 URL을 변경할 수 있게 해준다고 기술하고 있다. 주요 브라우저의 최신 버전에서 는 모두 이 같은 히스토리 API를 지원하며, AngularJS에서 이 기능을 활용하려면 $location 서비스의 프로바이더인 $locationProvider를 통해 지원 기능을 활성화하면 된다.HTML5 모드를 활성 화 하고 위 코드를 다시 실행시켰을때 URL이 더 깔끔하게 변한다고 기술하고 있으나 책이 잘못된 것인지 차이를 알 수 없게 기술되어 있어 실제로 테스트가 필요하다.12345Module.config(function($locationProvider) &#123; if (window.history &amp;&amp; history.pushState) &#123; $locationProvider.html5Mode(true); &#125;&#125;);위 코드에서 $window 서비스를 주입하지 않는 이유는 config 함수로는 상수 값이나 프로바이더만이 주입될 수 있기 때문이다.$anchorScroll이 서비스는 $location.hash 메서드에서 반환한 값과 id가 일치하는 엘리먼트가 보이게끔 브라우저 창의 스크롤을 조정해준다. 사용 방법이 독특한데 $anchorScroll 서비스는 서비스 객체를 참조할 필요가 없으며 단지 의존성만을 선언하면 된다. 서비스 객체가 생성되면(의존성 선언을 통해) $location.hash 값의 모니터링을 시작하고, 값이 변할 때 자동으로 스크롤을 조정한다.12345Module.controller(\"defaultCtrl\", function($scope, $location, $anchorScroll) &#123; $scope.scrollToTop = function() &#123; $location.hash('top'); &#125;;&#125;);12345...&lt;body&gt; &lt;p id='top'&gt;This is the top&lt;/p&gt; &lt;button ng-click='scrollToTop()'&gt;Go&lt;/button&gt;&lt;/body&gt;클릭을 하면서 호출된 함수에서 $location.hash 함수를 호출하게되고 자동으로 스크롤이 일어나게 된다. 자동 스크롤이 일어나지 않게 하려면 프로바이더를 통해 선언을 하면된다.12345678910111213Module .config(function($anchorScrollProvider) &#123; $anchorScrollProvider.disableAutoScrolling(); &#125;) .controller(\"defaultCtrl\", function($scope, $location, $anchorScroll) &#123; $scope.scrollToTop = function() &#123; var wantToScroll = true; $location.hash('top'); if (wantToScroll) &#123; $anchorScroll(); &#125; &#125;);&#125;);$log$log는 console객체의 래퍼로 debug, error, info, log, warn 메서드를 정의하고 있다. $log는 기본적으로 debug 메서드가 활성화되지 않으며 컨피그를 통해 활성화 시켜야한다.$exceptionHandler실행 도중 일어난 에러를 처리한다. 기본 구현체에서는 $log 서비스에 정의 된 error 메서드를 호출하며 이 메서드는 console.error 를 호출하게 된다.$exceptionHandler는 기본적으로 처리되지 않은 예외만을 대상으로한다. 라고 되어있는데 예제가 별로 쓸모 없는 것 같다. 강제로 익섹션을 내는 용도의 예제가 실려있다. 좀 보기 편하게 $exceptionHandler 서비스를 재정의 할 수 도 있으나 주의를 요한다. 정도로만 알고 있으면 될 것으로 보인다.위험한 데이터 처리해커들이 폼을 통해 악의적인 코드를 주입하는 이를 막기 위한 서비스들이 있다. AngularJS에서는 위험한 문자열이 ng-model, 인라인 바인딩등에서 표현되지 못하도록 자동 이스케이프한다. 위험한 문자열은 태그등을 생각하면된다.$sanitize$sanitize는 AngularJS에서 ngSanitize 모듈을 추가로 받아 로드하여 사용할 수 있으며 모듈 선언에서 ngSanitize를 주입 해야한다. $sanitize 서비스는 HTML 문자열에서 위험한 문자열을 이스케이프된 대체 문자열로 대체하게된다. 아까 자동으로 적용이 된다고 했는데 아래와 같은 차이점이 있다.ng-bind-html 디렉티브등을 이용해서 html을 태그상태로 표현하려고 할때 이스케이핑을 하지 않고 HTML 태그 상태로 보여주되 보여주는 과정에서 script 및 css 엘리먼트, 인라인 자바스크립트 핸들러 및 스타일 어트리뷰트등 문제를 일으킬 만한 요소를 모두 제거한다. ngSanitize 모듈을 인젝션하게되면 ng-bind-html 디렉티브를 사용할때 자동으로 적용되게 된다. 이를 책에서는 위생화 로 표현하고있다.ng-bind-html이 아닌 다른 곳에 표현될 때 이런 위생화가 표현하다고 한다면 컨트롤러에서 $sanitize(targetData) 메서드를 명시적으로 호출할 수 있다.$sce$sce는 명시적으로 데이터를 신뢰할 때 사용하나 저자는 사용할 일이 거의 없을 뿐더러 위험하니 사용하지 않기를 권하고 있다. 이는 HTML태그를 사용할 수 있게 허용한다.123456789angular .module('itIsModule', ['ngSanitize']) .controller(\"defaultCtrl\", function($scope, $sce) &#123; $scope.htmlData = \"&lt;p&gt;This is &lt;b onmouseover=alert('Attack!')&gt;dangerous&lt;/b&gt; data&lt;/p&gt;\"; $scope.$watch(\"htmlData\", function(newValue) &#123; $scope.trustedData = $sce.trustAsHtml(newValue); &#125;); &#125;);&#125;);12&lt;p&gt;&lt;input class=\"form-control\" ng-model=\"htmlData\"/&gt;&lt;/p&gt;&lt;p ng-bind-html=\"trustedData\"&gt;&lt;/p&gt;위 태그의 인라인 이벤트 코드는 명시적으로 신뢰를 선언했으므로 실행된다.2016-01-27 추가AngularJS 표현식 및 디렉티브 활용$parseAngularJS 표현식을 인자로받아 스코프 객체를 사용해 표현식을 평가하는데 사용할 수 있는 함수 로 변환한다.1234567891011121314151617181920Module .controller(\"defaultCtrl\", function($scope) &#123; $scope.price = \"100.23\"; &#125;) .directive(\"evalExpression\", function($parse) &#123; return function(scope, element, attrs) &#123; scope.$watch(attrs[\"evalExpression\"], function(newValue) &#123; try &#123; var expressionFn = $parse(newValue); var result = expressionFn(scope); if (result == undefined) &#123; result = \"No result\"; &#125; &#125; catch(ex) &#123; result = \"Cannot evaluate expression\"; &#125; element.text(result); &#125;); &#125; &#125;);12&lt;p&gt;&lt;input class=\"form-control\" ng-model=\"expr\" /&gt;&lt;/p&gt;&lt;div&gt;Result: &lt;span eval-expression=\"expr\"&gt;&lt;/span&gt;&lt;/div&gt;스코프를 인자로 받는 함수를 받는 것만 눈여겨 보면 활용도가 있을 것으로 보인다. price | currency 라고 input 태그에 입력하게 되면 표현식이 평가되어 span태그에 결과가 나타나게된다. 표현식이 유효하지 않은 경우를 대비해 try-catch 문은 필수적이다.로컬 데이터를 제공할 수 있는데123456var expressionFn = $parse(\"total | currency\");...var localData = &#123; total: Number(newValue) + (number(newValue) * (number(scope.tax) / 100))&#125;;element.text(expressionFn(scope, localData));스코프에 존재하지 않는 total 속성에 대한 참조를 localData에 대입하여 사용했다.$interpolate$interpolate 서비스는 단순히 표현식 자체가 아닌 표현식이 들어 있는 문자열과 연동이 가능해 $parse 보다 더 유연하다.1234&#123;% raw %&#125;$parse(\"total | currency\");$interpolate(\"The total is &#123;&#123;total | currency&#125;&#125;\");&#123;% endraw %&#125;이런식의 차이다. 인라인 바인딩을 처리하며 **{{** 같은 문자열을 보간문자라 하는데 이 문자가 다른 프레임워크와의 사용으로 바꿔야할 필요성이 있다면 $interpolateProvider를 통해 해결할 수 있다. * startSymbol(symbol): {{를 대체한다. * endSymbol(symbol): }}를 대체한다.이 설정은 HTML 마크업을 포함해 AngularJS 영향 영역 전체에 영향을 미치니 주의해야한다.$compile바인딩 및 표현식이 들어있는 HTML 스트링을 처리해 스코프로부터 콘텐처를 생성할 수 있는 함수를 제공하며 디렉티브를 지원한다는 차별점이 있다.123456789101112Module .controller(\"defaultCtrl\", function($scope) &#123; $scope.cities = [\"London\", \"Paris\", \"Seoul\"]; &#125;) .directive(\"evalExpression\", function($compile) &#123; return function(scope, element, attrs) &#123; var content = \"&lt;ul&gt;&lt;li ng-repeat='city in cities'&gt;&#123;&#123;city&#125;&#125;&lt;/li&gt;&lt;/ul&gt;\"; var listElem = angular.element(content); var compileFn = $compile(listElem); compileFn(scope); element.append(listElem); &#125;);Chapter 20: Ajax 서비스 및 프로미스$httpget(url, config?)post(url, data, config)delete(url, config)put(url, data, config)head(url, config)jsonp(url, config)W3C에 따르면 get은 안전한 post는 안전하지 않은 상호작용으로 정의되어 있으며 get은 읽기 전용 정보 조회, post는 앱의 상태 변경 작업에 사용해야 한다.2016-01-30 추가ajax 통신에 따른 리던값으로는 프로미스 객체를 받게 된다. 프로미스 객체가 정의하는 메서드는 아래와 가다.success(fn)error(fn)then(fn, fn)기존에 개인적으로 쓰던 프로미스 라이브러에서는 error가 아닌 catch 라는 메서드가 존재했으나 스펙상 어떤 것이 맞는 것인지는 모르겠다. 응답이 JSON형식일 경우 파싱된 상태로 콜백 함수에 전달된다.then 메서드에서는 단순히 success와 error콜백을 함께 등록하는 것 뿐만이 아니라 추가적인 상세 정보에 접근 할 수 잇는 인자가 넘어오는데 정의하고 있는 속성은 아래와 같다.error는 편의상 추가된 것이라고 이 장의 뒷 부분에서 언급하고 있다.datastatusheaderconfigJSON의 경우 AngularJS에서 내부적으로 직렬화 하여 요청을 하고 들어온 데이터를 파싱하여 객체상태로 넘겨주는 등의 역할을 해주지면 나머지는 그대로 들어오게 된다.Ajax 요청 설정$http의 메서드들은 config 인자를 옵션으로 지원하여 다양한 설정이 가능하다. config인자의 속성은 아래와 같다.dataheadermethodparamstimeouttransformRequesttransformResponseurlwithCredentialsxsrfHeaderNamexsrfCookieNametransformRequest, transformResponse사용자에게 프로미스로 인자로 값이 전달되기 전의 프로미스 콜백함수라고 보면 될 듯 하다. 책에서는 중요한 듯 설명하고 있으나 응답 데이터가 XML일 경우 이를 파싱하여 필요한 정보만 사용자에게 건내는 등의 사전 작업 함수를 등록하는 일 정도다. 뒤에 프로바이더에서 한번 더 설명하므로 여기선 생략한다$httpProviderAjax 기본값 설정defaults.headers.commondefaults.headers.postdefaults.headers.putdefaults.transformResponsedefaults.transformRequestinterceptorswithCredentials기본 헤더, post 메서드, put 메서드 사용시의 헤더 정의가 있고 transfromRe* 함수는 배열로써 존재하는데 이 곳에서 JSON데이터를 기본으로 파싱하여 자바스크립트 오브젝트를 넘겨주는 것으로 예상된다. 응답시에 리턴되는 프로미스 콜백의 이전 체인 함수라고 생각하고 등록하면서 된다. 배열이니 push를 통해 넣는다.defaults 객체는 $http.defaults를 통해서 접근이 가능하며 기본 값이기 때문에 전역적으로 영향을 준다.Ajax 인터셉터 활용interceptors변형 함수(transformRe*)를 정교한 로직으로 대체할 수 있는 기능으로 사용된다.1234567891011121314.config(function($httpProvider) &#123; $httpProvider.interceptors.push(function() &#123; return &#123; request: function(config) &#123; config.url = \"fix_url.json\" return config; &#125;, response: function(response) &#123; console.log(\"count: \" + response.data.length); return response; &#125; &#125; &#125;);&#125;);이런식이다 요청을 하게 되면 최종적으로 config 함수에서 url을 바꿔버리니 요청이 “fix_url.json”으로만 가게 될 것이 응답 시에는 로그를 찍을 것이다. 팩터리 함로 특정 속성을 포함하는 객체를 리턴하는 것을 눈여겨보고 이 함수가 변형 함수 이 전에 호출되는지 이 후에 호출되는지를 확인할 필요가 있다. 책에서는 변형함수 이후에 호출 되는 뉘앙스를 풍긴다. 리턴하는 객체에 정의할 수 있는 속성은 아래와 같다.requestrequestErrorresponseresponseError에러는 프로미스의 error 메서드 콜백으로 들어갈 함수를 등록한다고 보면 될 듯 하다.프로미스의 활용##promise에 대한 내용을 공부하고 싶다면 한빛미디어에서 무료로 제공하고 있는 책(JavaScript Promise)이 있으니 이를 참고하면 도움이 될 듯 하다.프로미스는 스펙이며 여러 구현체가 존재하고 AngularJS에서는 $q 서비스를 통해 프로미스를 제공한다.$qall(promises[]): 프로미스 배열의 모든 프로미스가 리졸브되거나 하나의 에러가 발생할 경우 리졸브된 프로미스가 반환된다.defer(): 지연 객체를 생성한다.reject(reason): 거부된 프로미스를 반환한다.when(value): 항상 리졸브되는 프로미스를 사용해 값을 감싼다(이해불능)defer()지연객체를 반환하는데 지연 객체에서 정의하는 멤버는 아래오 ㅏ같다.resolve(result)reject(reason)notify(result)promisenotify는 처음보는데 지연활동으로 부터 중간 결과를 제공한다고 되어 있다.프로미스가 정의하는 메서드는 아래오 ㅏ같다.then(success, error, notify)catch(error)finally(fn)프로미스의 콜백 함수에는 지연 객체가 인자로 들어오게된다. then은 프로미스 객체를 리턴하므로 체인이 가능하다.Chapter 21: REST 서비스REST(Representational State Transfer)는 API 스타일이다.$http 서비스의 활용$http 서비스를 이용해서 RESTful을 처리하는 장들을 보여주고 로컬 데이터와 서버 데이터간의 동기화를 해야하기 때문에 신경을 많이 써야하며 AngularJS가 추구하는 방식과 대치된다고 말하고 있다.Ajax 요청 숨기기ngResource모듈을 설치해야한다. AngularJS 홈페이지에서 받을 수 있다.$resource12var baseUrl = 'http://localhost:5500/products/';var 접근객체 = $resource(basUrl + ':id', &#123; id: \"@id\"&#125;);접근 객체가 지원하는 메서드는 아래와 같다.query()get(id)delete(params, product)remove(params, product)save(product)query()GET. baseUrl 부분을 호출한다. 리턴값은 컬레션이며 비어있다. 쿼리 완료에 따라 내용이 업데이트된다. 컬렉션에 $promise 속성이 존재한다.http://localhost:5500/productsget(id)GET.http://localhost:5500/products/iddelete, remove(param, product)DELETE.http://localhost:5500/products/idsave(product)POST.http://localhost:5500/products/id데이터 객체 수정query 메서드는 Resource 객체를 사용해 컬렉션을 채운다(컬렉션 개별 요소가 Resource 객체라는 듯). Resource 객체는 서버에서 반환한 데이터에 지정된 송석을 모두 정의하며, 컬렉션 배열을 사용하지 않고도 데이터를 조작할 수 있는 메서드를 정의한다.Resource 객체$get(): 서버로부터 객체를 가져와 갱신하며, 커밋하지 않은 로컬 변경 사항은 모두 제거된다.$delete(): 서버에서 객체를 삭제한다.$remove(): 서버에서 객체를 삭제한다.$save(): 객체를 서버에 저장한다.모두 리턴값으로 프로미스 객체를 리턴한다. 주의할 점은 $delete, $remove의 경우 삭제요청을 보내지면 컬렉션 배열에서 스스로 제거될 수 는 없다는 점을 알아야한다.새 객체 생성사실 코드로 이해가 안가는 부분인데 $scope.productsResource는 $resource 서비스를 통해 반환받은 접근 객체인데 예제 코드는 일단 아래와 같다.1234567function(product) &#123; new $scope.productsResource(product) .$save() .then(function(newProduct) &#123; $scope.products.push(newProduct); &#125;);&#125;new $scope.productsResource(product) 이 부분이 new에 해당하는 코드인것 같은데 책에서는 접근객체의 메서드 정의에 바로 호출이 가능하다라는 부분이 없는데 일단은 new 키워드와 데이터를 통해 새 Resource 객체 생성이 가능하다고 봐야할 것 같다.$resource 서비스 행동 설정RESTful은 API 스타일이므로 서버에 따라 정의가 다를 수 있다. 그래서 CRUD에 맞춰 요청 방식을 직접 지정할 수 있다.123$scope.productsResource = $resource(baseUrl + \":id\", &#123; id: \"@id\" &#125;, &#123; create: &#123; method: \"POST\", save: &#123; method: \"PUT\"&#125; &#125;&#125;)Resource 객체의 메서드들($로 시작)을 액션이라 칭하는데 지금 $resource의 3번째 인자를 통해 액션을 정의하고 있다.method: HTTP 방식 결정params: $resource 서비스 함수의 첫번째 인자로 전달되는 영역 변수 값 지정url: 이 액션의 기본 URL을 오버라이드.isArray: true일 경우 JSON데이터 배열이 응답으로 온다고 지정한다. 기본값은 false고 요청응답이 단일 객체라고 지정한다.추가로transformRequesttransformResponsecachetimeoutwithCredentialsresponseTypeinterceptor속성을 사용해 액션에서 생성하는 Ajax요청을 설정할 수 있다.1234567function(product) &#123; new $scope.productsResource(product) .$create() .then(function(newProduct) &#123; $scope.products.push(newProduct); &#125;);&#125;커스텀 액션인 $create()를 호출하고 있다.resource 활용에 적합한 컴포넌트 구현$resource 서비스에서 제공하는 데이터와 연동할 수 있는 컴포넌트를 작성할 대는 RESTful 지원 기능의 on/off 설정 옵션부터 서버에서 업데이트하는데 필요한 메서드 및 HTTP 방식등을 지정할 수 있게끔 구현해야한다.비동기적 데이터 함정 피하기한글의 탈을쓴 외계어로 작성된 듯 하다. 이해가 가지 않으나 스코프 와처와 이벤트 핸들러를 사용해 자동으로 클라이언트 뷰와 서버와 동기화 되는 코드를 짜려고할때 조심해야한다고 말하고 있는 듯 하다.2016-01-31 추가Chapter 22: 뷰를 위한 서비스ngRouteAngularJS 홈페이지에서 추가로 route파일을 다운로드 받아야한다. ng-view 디렉티브가 이 곳에 정의되어 있는 것으로 보인다.123456789101112131415161718.config(function($routeProvider, $locationProvider) &#123; $locationProvider.html5Mode(true); $routeProvider.when(\"/list\", &#123; templateUrl: \"/tableView.html\" &#125;); $routeProvider.when(\"/conservative/:id\", &#123; templateUrl: \"/tableView.html\" &#125;); $routeProvider.when(\"/eager/:id/:data*\", &#123; templateUrl: \"/tableView.html\" &#125;); $routeProvider.otherwise(\"/list\", &#123; templateUrl: \"/tableView.html\" &#125;);&#125;)controller(function($location) &#123; $location.path(\"/list\");&#125;);when에서 정의된 URL은 $location.path(URL)을 통해 이동가능하며 코드가 아닌 브라우저에 실제 주소를 입력할 경우에는 요청으로 간주되어 라우터는 동작하지 않는다. ng-view 디렉티브가 선언된 곳에 templateUrl에서 지정한 위치의 파일이 로드되게 된다.라우트 및 라우트 파라미터 접근12345678910111213.controller(\"ctrl\", function($scope, $http, $resource, $location, $route, $routeParam, baseUrl) &#123; $scope.$on(\"$routeChangeSuccess\", function() &#123; if ($location.path().indexOf(\"/edit/\") == 0) &#123; var id = $routeParams[\"id\"]; for (var i = 0; i &lt; $scope.products.length; i++) &#123; if ($scope.products[i].id == id) &#123; $scope.currentProduct = $scope.products[i]; break; &#125; &#125; &#125; &#125;)&#125;)라우팅 주소가 /edit/ 으로 시작하는 경우 id 파라미터에 접근하고 있다.$route메서드 및 속성currentreload()routes이벤트$routeChangeStart$routeChangeSuccess$routeUpdate$routeChangeError라우트 설정$routeProvider위의 예제에서는 단순히 templateUrl만 정의했는데 추가적인 설정이 가능하다.controller: 컨트롤러 설정controllerAstemplatetemplateUrlresolve: 의존성redirectToreloadOnSearchcaseInsensitiveMatchresolve컨트롤러에 주입할 의존성을 지정할 수 있다. 의존성으로 서비스를 지정할 수도 있지만, resolve속성은 뷰를 초기화하는 데 필요한 작업을 수행하는 데 더 도움이 되며 resolve 속성의 의존성으로 프로미스 객체를 반환할 경우, 라우트에서 의존성이 리졸브되기 전까지 컨트롤러에 인스턴스화하지 않기 때문이다. 말이 어렵게 되어있어 이해 불능이니 한번 더 살펴봐야할 듯하다.123456789101112131415161718192021.factory(\"productsResource\", function($resource, baseUrl) &#123; return $resource(basUrl + \":id\", &#123; id: \"@id\" &#125;, &#123; create: &#123; method: \"POST\" &#125;, save: &#123; method: \"PUT\" &#125; &#125;);&#125;).config(function($routeProvider) &#123; $routeProvider.otherwise(&#123; templateUrl: \"/tableView.html\", controller: \"tableCtrl\", resolve: &#123; data: function(productsResource) &#123; return productsResource.query(); &#125; &#125; &#125;);&#125;).controller(\"tableCtrl\", function($scope, data) &#123; $scope.data = data;&#125;);resolve 속성에 data 를 정의하고 productsResource 를 주입하고 프로미스를 리턴한다. 프로미스가 리졸브 될 때까지 인스턴스화가 미뤄져서 tableView.html가 늦게 보일 것이라고 말하고 있다. 컨트롤러에서는 정의한 data 속성을 주입하고 있다. 라우트와 연계해 컨트롤러를 사용할 때는 컨트롤러/스코프 상속 규칙이 적용됨을 책은 강조하고 있다.Chapter 23: 애니메이션 및 터치를 위한 서비스ngAnimation모듈 설치AngularJS홈페이지에서 내려받아서 사용하면 된다. css를 통해 애니메이션을 처리한다고 했는데 예제를 봤을 땐 이 파일이 왜 필요한지 이해가 가지 않는다.애니메이션의 정의 및 적용애니메이션을 지원하는 내장 디렉티브 및 애니메이션과 관련한 이름ng-repeat: enter, leave, moveng-view: enter, leaveng-include: enter, leaveng-switch: enter, leaveng-if: enter, leaveng-class: add, removeng-show: add, removeng-hide: add, remove병렬적 애니메이션의 위험성ng-view의 경우 새 뷰를 DOM에 추가한 후기존 뷰를 DOM에서 제거한다.애니메이션 예제가 스스로 css를 통해 애니메이션을 만들고 그 클래스를 직접 입히고 있어 모듈의 왜 필요한지 다른 자료를 참고해야할 듯 하다.터치 이벤트 지원ngTouch모듈이 필요하며 AngularJS 홈페이지에서 받을 수 있다. ng-click 디렉티브가 터치 환경에서 적합하게 동작할 수 있도록 대체되며 ng-swipe-left, ng-swipe-right 디렉티브를 통해 스와이프가 발생했을 때의 동작을 지정할 수 있다.2016-02-01 추가Chapter 24: 프로비전 및 주입을 위한 서비스프로비전이라는 말이 다소 어려운데다가 책에 설명도 없다 사전적인 의미로 검색해보니 제공하다, 규정하다 등이 나오는데 이와 유사한 의미로 이해하고 AngularJS 내부에서 동작하는 함수로 알아두면 될 것 같다.AngularJS 컴포넌트 등록$provide$provide 서비스는 의존성을 충족할 수 있게끔 서비스 같은 컴포넌트를 주입할 수 있게 등록하는 데 사용된다. 대부분의 경우 $provide 서비스에서 정의하는 메서드는 Module 타입을 통해 외부로 노출되고 접근할 수 있지만 Module에서 제공하지 않는 특수 메서드도 하나 존재한다$provide 서비스가 정의하는 메서드value(name, service)constant(name, value)factory(name, service)provider(name, service)service(name, service)decorator(name, service)Module 타입을 통해 외부로 노출되지 않는 메서드는 decorator 메서드다.123456789.config(function($provide) &#123; $provide.decorator(\"$log\", function($delegate) &#123; $delegate.originalLog = $delegate.log; $delegate.log = function(message) &#123; $delegate.originalLog(\"Decorated: \" + message); &#125;; return $delegate; &#125;);&#125;);decorator는 원본 서비스명을 첫 번째 인자로하며 두번째 콜백에 반드시 $delegate 의존성을 선언하여 원본 서비스의 인스턴스를 받게 된다. 여기서 리턴되는 객체가 원본 객체를 대신하여 의존성을 리졸브 한다고 이해하면 될 듯 하다.주입 관리$injector$injector 서비스는 함수에서 선언하는 의존성을 판단하고, 의존성을 리졸브하는 책임을 진다.$injector 서비스가 정의하는 메서드annotate(fn)get(name)has(name)invoke(fn, self, locals)annotate(fn)함수 인자를 스트링으로 가져오는 역할을 한다. AngaulrJS의 의존성 주입에 대해 역할을 할 것으로 보이는데 아마도 코드로는 이런식이 아닐까 한다.(AngularJS의 코드를 확인해보지는 않았다.)12345function annotate(fn) &#123; var str = fn.toString(); var regexp = \"()안으로부터 인자의 이름을 가져와서 ','로 split하여 배열로 리턴하는 RegExp\"; return regexp.exec(str);&#125;get(name)name에 맞는 서비스를 리턴한다.has(name)인자로 스트링을 넣으면 그 인자가 의존성 객체인지를 리턴한다.invoke(fn, self, locals)fn은 호출하고자 하는 함수가 되고 self 인자는 context(this)가 될 객체다.locals는 객체인데 의존성 인자가 아닌, 즉 $injector.has(name)에 의해 false 리턴된 인자의 이름에 맞는 객체를 속성으로 제공하게 되는 역할을 하게 된다.123456var logClick = function($log, $exceptionHandler, message) &#123; return false;&#125;$injector.invoke(logClick, null, &#123; message: \"Button Clicked\"&#125;);$rootElement$rootElement는 ng-app 디렉티브를 가진 엘리먼트의 jqLite 객체의 확장이며 $injector 서비스를 반환하는 injector 메서드를 제공한다.123$rootElement.injector().invoke(logClick, null, &#123; message: \"Button Clicked\"&#125;);이런식의 접근을 할 이유가 전혀 없지만 이를 통해 AngularJS 내부의 모습을 볼 수 있다.의존성을 리졸브한다는 난해한 말을 하고 있는데 AngularJS 내부에서 읜존성 주입을 어떻게 처리하는 지를 보여주는 함수라고 생각되며 딱히 쓸일은 없어보인다.Chapter 25: 단위 테스트source codehttp://www.apress.com/9781430264484?gtmf=sZ 이동 후 Source Code/Downloads","categories":[{"name":"summary","slug":"summary","permalink":"http://blog.bglee.me/categories/summary/"}],"tags":[]},{"title":"Jekyll 블로그 운영","slug":"jekyll_setup","date":"2016-01-29T15:00:00.000Z","updated":"2018-03-29T06:03:19.627Z","comments":true,"path":"posts/2016/jekyll_setup/","link":"","permalink":"http://blog.bglee.me/posts/2016/jekyll_setup/","excerpt":"","text":"나는 메모장을 열고 .md 로 저장을 했더니 블로그에 글이 포스팅 되어 있다.설치install Jekyll1$ gem install jekyll지킬 인스톨 가이드를 참고하면 되겠다.Forking theme테마를 하나 포킹해야한다. 유료건 무료건 지킬 버전에 맞는 테마를 구글에서 검색해서 포킹한다. “jekyll theme“ 로 구글에서 검색하면 쉽게 얻을 수 있다.포킹한 후에는 이를 반드시 클론 하여 버전관리를 포함한 시작 뼈대를 갖추도록 한다.configuration테마 루트에 있는 _config.yml 파일을 자신에 맞게 수정한다.operate Jekyll두가지 방법이 있다.지킬 자체가 웹서버를 런칭하고 스스로 빌드웹서버는 Apache, Nginx등에 위탁하고 지킬을 통해 빌드만 하는 방법이다.내 선택 기준은 다음과 같았다. 기타 이미 서비스를 하고 있는 웹 페이지등이 있다면 후자를 이용하고 아무것도 해본적이 없으면 첫번째 방법을 이용하면 된다. 어차피 웹서비스는 80포트를 통해 제공되며 이는 겹쳐선 안되므로 하나만 사용 가능하다. 전자의 방법은 지킬 인스톨 가이드를 참고하면 되겠다.후자는 이미 다른 웹서버가 사용되고 있다는 가정하에 지킬 테마 밑의 제네레이트된 파일 폴더인 _site 폴더를 운영되고 있는 웹 서버에서 서빙할 수 있도록 해주면된다. 이 부분은 각자 웹서버 프로그램의 설정 가이드를 참고해야한다.(그래봤자 아파치 아니면 Nginx다)_site 폴더는 빌드를 통해 업데이트된다.1$ jekyll build --watch #watch option은 변경된 파일이 생기면 그 파일을 리빌딩한다.빌드는 위 커맨드를 통해 가능하다.운영설치가 끝나면 이제 포스팅을 작성해야하는데 하고자 하는 바는 아래와 같았다.서드파티 댓글 시스템 추가이미지와 컨텐츠(마크다운 파일) 분리컨텐츠 버전 관리테마 버전 관리서드파티 댓글 시스템 추가(Disqus)디스커스로 정했다. 설치도 너무 쉬워서 가입하고 방식에 맞는 스크립트를 받아(유니버설 스크립트) 포스트에 사용되는 레이아웃 파일을 _layout 폴더에서 찾아 수정해주면 된다. HTML을 조금 이해하고 있으면 도움이 되겠지만 눈치로 잡을 수 있는 수준이다.이미지와 컨텐츠 분리이런 공수를 따로 들이는 이유는 관리적인 측면에서의 차이 때문이다. 코딩을 하다보면 재사용성을 높이기 위해 모듈화, 캡슐화가 진행되는데 그와 다르지 않다. 컨텐츠를 버전관리할 터인데 이미지를 여기에 함께 관리하는건 바람직하지 않다는 개인적인 의견이다.드롭박스, 원드라이브, 구글 포토등 여러가지 클라우드 저장소가 있는데 여기서는 무제한 용량을 제공하는 구글 포토를 이용했다. 사용하는 방법은 간단하다. 어차피 사진은 폰으로 찍을 것이므로 폰에 구글 포토(안드로이드라면 기본적으로 깔려있을지도 모른다.)를 설치하고 공유 앨범을 하나 만든다. 공유 앨범의 이름을 블로그 포스팅을 위한 무언가로 지정해주면 관리하기 편하겠다.사진을 찍고 구글 포토를 열어서 공유 폴더에 추가해준다. 글은 어차피 PC에서 작성하므로 구글 포토에 접속한후 공유 폴더에 있는 사진을 열고 이미지 링크 복사를 통해 이미지 주소를 가져와 이를 컨텐츠파일에서 사용하면된다.컨텐츠 버전 관리테마 폴더 아래 _posts 폴더가 우리가 마크다운 파일을 작성하는 곳이 될 것이므로 이 폴더를 버전관리 하면 된다. 깃허브나 비트버킷이 있는데 비공개 저장소는 비트버킷이 가능하므로 나는 이를 이용했다.테마 버전 관리말이 테마지 지킬에서는 테마가 서빙에 필요한 모든 구조를 다 포함하고 있으므로 설정파일인 _config.yml 파일을 포함해 layout파일들이 모두 여기에 포함되므로 UI와 관련된 모든 수정이 여기서 발생하게 된다. 이 때문에 포킹이 필요하게 되며 무료 테마의 경우 보통 깃 허브를 통해 포킹하게 될 것이므로 포킹후 테마를 클론하여 여기서부터 시작하면 이미 버전관리는 시작됐고 수정하는 것들에 대해서 커밋, 푸쉬등을 퉁해 그대로 버전관리를 진행하면된다.추가적인 운영 팁(?)마크다운을 통해 로컬 텍스트 에디터를 통해 포스팅을 할 수 있다는 강력한 장점이 있지만, 글 도입부에 YAML을 통한 포맷을 반복적으로 해줘야하는데 이런 부분은 각자가 사용하는 에디터에 대한 무언가로 해결 할 수 있으리라 생각된다.단순하게는 포맷 파일을 하나 두고 열어서 복사하는 방법이 있겠고 개인적으로는 아톰을 사용하는데 아톰은 자바스크립트를 통한 핵이 가능하고 플러그인을 만들기는 공수가 큼으로 아래와 같은 방법을 통해 하고있다.2016-01-30웹페이지를 통한 이메일 발송구매한 지킬 테마에 contact 페이지가 포함되어있는데 이메일을 웹페이지에서 바로 보낼 수 있는 서비스다. 이를 위해선 서드파티 이메일 서비스가 필요하다.","categories":[{"name":"setup","slug":"setup","permalink":"http://blog.bglee.me/categories/setup/"},{"name":"draft","slug":"setup/draft","permalink":"http://blog.bglee.me/categories/setup/draft/"}],"tags":[]},{"title":"그린스모크 구매, 사용 후기","slug":"greensmoke","date":"2016-01-15T15:00:00.000Z","updated":"2018-03-29T06:03:19.626Z","comments":true,"path":"posts/2016/greensmoke/","link":"","permalink":"http://blog.bglee.me/posts/2016/greensmoke/","excerpt":"","text":"작년 블랙프라이때 부터 고민을 하다가 1년이나 밀려서 지금 구매를 하게 되었다.구매동기음주후 숙취.역류성 식도염의 직접적인 원인.2014 블랙 프라이데이 때는 국내에서 아마도 리차져블 키트라고 해서 팔고 있는 배터리 2 + 카트리지 2 조합의 키트가 아마 무료 또는 $1였던 것으로 기억한다. 뭐 이벤트였지만 당시에는 국내 직배송도 했었던 것 같고 그 때 구매를 미루면서 친구에게 전자담배 하카를 구매해 사용했었으나 세척 귀찮음, 너무 잦은 망가짐(아마 이것도 암페어가 안맞는 충전기를 이용해서 그런 것 같다)으로 연초를 태울 수 밖에 없었고 어느샌가 그렇게 시간이 흘러버렸다.2015 에도 나름의 블랙프라이 데이를 맞아 이참에 직구 경험도 해볼 겸 해서 구매를 하게 되었다.구매 과정그린스모크 홈페이지인 http://www.greensmoke.com/에서 그냥 구매를 하면된다. 구매 이전에 배대지 싸이트에 하나 가입을 해서 배대지 주소를 받아놓고 그 쪽으로 주문을 하면 되겠다. 본인 같은 경우는 직구직구를 통해 주문하였으며 DE 주소로 배송을 했다.니코틴이 20ml이상이 되면 추가적인 세금이 붙는 걸로 알고 있어서 키트에 포함된 카트리지를 포함해서 카트리지는 20개로 맞추어 주문했다.익스프레스 키트 + 카트리지 3팩을 주문하면서 첫 주문이니 만큼 다양한 향과 몸에 맞는 니코틴 양을 경험하기 주문을 아래와 같이 했다.익스프레스 키트(RED LABEL 1.2%)Tabacco GOLD 1.8%Mocha MIST 1.8%Smooth CREAM 1.8%원래 피우던 담배는 슬림형 1mg를 피웠고 그에 맞추면 0.6%가 맞겠지만 카트리지 구매가 쉽지 않은점을 고려해 한두 단계 강한 것으로 결정했다.주문은 Visa나 Master카드가 있으면 어렵지 않게 주문을 하고 주소는 배대지로 신청을 했다.2016-01-16http://www.couponbox.com에서 greensmoke 로 검색하면 쿠폰 코드가 나오는데 실제로 적용이 된다. 단돈 몇 달러라도 아낄 수 있다.배송 과정배송일은 5-6 영업일이라고 되어 있었지만 배송중 딜레이가 되어 이틀이 추가 되었으며 주말로 밀리면서 한국행 비행기가 월요일로 잡혀 실제로는 +4일 이상 연기되었다.배대지에 도착하기 전에 트래킹 넘버와 오더 넘버를 배대지에 기입해 줘야하고 입고가 완료된 경우 결재를 해주어야한다. 전자 담배같은 경우는 일반통관으로 분류된다.금요일날 한국에 도착해서 토요일 오전에 집에 도착했다. 영업상의 이유로 토요일 배송을 하지 않던 우체국이 9월 부로 토요일 배송을 재개했다고한다.사용기4가지 카트리지 향을 모두 피워 봤는데 니코틴 양에 따라서 타격감이 당연히 다르겠지만 이게 향에 따라서 다르다 스무스 크림 같은 경우는 1.8%인데도 더 부드럽게 느껴진다. 처음와서 이것 저것 해본다고 많이 빨았더니.. 목이 좀 부은 것을 보니 다음 주문에는 0.6%두개 1.2%두개가 될 것 같다.향 (2016년 이름)RED LABEL 1.2% (SIGNATURE RED)말보로 레드의 향과 비슷하다고 홍보하는 것 같으나, 처음에 하카 전자담배를 사용하면서 골랐던 향(무슨 향인지 기억은 못하나 당시에는 연초와 비슷하다고 느껴서 구매)과 매우 흡사하다. 그냥 전자담배 기본 향인거 같다. 연초랑은 잘..Tabacco GOLD 1.8% (SOUTHERN GOLD)좀 구수한 맛이 난다. 다른 1.8% 향보다 더 묵직하게 들어온다. 피자마자 별로네 했는데.. 나름 묵직한게 매력이 있는 것 같다.Mocha MIST 1.8%원두향이라고 보는게 옳다. 이 향을 피울때는 감기상태여서.. 감기가 돌아올때 즈음엔 카트리지를 다펴서 탄내가 나서 아직은 파악이 잘 안되고 있으나 특별히 매력적이진 않다.Smooth CREAM 1.8%아마 이전에 바닐라 드림즈 로 알려졌던 향인 것으로 보인다. 많은 사람들의 평가와 같이 좋았다. 가장 많이 피고 있는 카트리지.추가Menthole Ice 1.8%박하맛인데 연초의 멘솔처럼 시원하진않다 판매를 보면 1위인거 같은데 시원한 박하맛이 아닌 달달한 느낌이라고해야하나 나쁘진 않은데 기대했던 멘솔은 아니다.Absolute Tabacco 1.8% (CLASSIC)말보로 미둠을 모델로 나온 향으로 알고 있다. 개인적로는 시그니쳐 레드보다 더 묵직한 것 같다. 타바코 골드와 그나마 비슷한다 더 강하고 묵직하다. 개인적으로는 타바코 골드가 난 것 같다.아마 이전에 바닐라 드림즈 로 알려졌던 그 향인 것 같은데 많은 사람들의 평가와 같이 역시 좋다. 전자담배를 피면서 왜 꼭 연초 향을 따라가야하는 의문을 던진다. 목넘김도 부드럽고 주변에서의 거부감도 없다. 향은 좋은데 많이 피면 혀가 약간 떫떠름한 느낌이 있다.스무스 크림이 주력이 될 것 같다. 다른 향도 사용을 해보겠지만 스무스 크림의 약간 혀가 떫은 느낌과 달달한 느낌을 커버 할 수 있는 향 하나(지금으로선 타바코 골드)를 병행하면 무난할 것으로 보인다.연초는?도착한 순간 부로 바로 연초를 대체했고 오늘로 10일째다. 이전에 이미 한달 가량 끊었다가 입을 대서 그게 다시 서서히 늘어나 돌아왔던 경험이 있어 그린스모크로 잘 참고 있다. 밥을 많이 먹었을때가 위긴데 이럴땐 묵직한 놈으로.. 평소때는 스무스 크림으로.. 뭐 이런식이다.추가해마다 인지는 모르겠어 2016년이 되면서 3개 향에 대한 이름이 바꼈다. 2015에 오면서 바닐라 드림즈가 스무스 크림이 된게 아닌가 한다. 연초를 일주일에 한번 정도 태워보고 있는데 담배 처음 피울 때 느껴지는 종이가 타는 향이 느껴지고 손에서 향이 너무 심하게 나서 오히려 안피게되는 것 같아 현재 만족 중이다.2016-01-11그린스모크로 넘어온지 한달째 날. 연초를 산적은 없고 술자리에서 한대씩 빌려(?) 폈으나 10가치가 안되는 것 같다. 연초 냄새가 너무 강하고 피고나면 손 씼어야하는 불필요한 일들이 없어져서 좋다. 집에서 나가는 일이 줄어들어 집중도도 좋아진 것 같고, 숙취가 엄청 심한데 이 또한 현저히 줄어들었다.흡연량은 초반에 신기해서 많이 피던 때(이틀에 한개 소모)나 술을 오래마신 날(하루 한개 소모)을 포함해서 현재 13카트리지를 소모했으니 한개의 카트리지로 평균 2.4일 정도를 피우는 것 같다. 기존 연초도 하루 반갑, 술마신날은 한갑 이상을 태웠었다. 지금은 술자리에서 연초 생각이 거의 안나고 니코틴을 줄이려고 카트리지 주문을 니코틴 레벨 1.2%로 내려서 주문했다.개인적으로 맨솔이나, 담배맛이 별로 입에 맞지않아. 더 줄어들었던 것 같다.관세 관련 경험담배를 구매하면 관세를 물게 되는데 특별한 이벤트에 구매시에는 카트리지명이 아닌 물품명이 ‘Black Friday 2015 Sale’, ‘Snowy savings’등으로 바뀌게 된다. 기존 세일이 아닐시에는 물품명이 ‘FlavorMax™ Cartridges’ 이런 것들이 세관에서 잡히느냐 마느냐에 영향을 주는 것 같다.2016-01-212016년도 부터는 익스프레스 킷에 들어있는 케이스가 플라스틱 케이스에서 가죽 케이스로 대체됐다. 가죽케이스가 생각보다 커서 갤럭시 노트 급 사이즈가 아닌가 한다. 가죽 케이스에는 롱 배터리와 카트리지가 결합된 상태로 넣을 수 있고 단종된 플라스틱 케이스는 숏 배터리도 결합상태로는 캐리가 불가능하다. 그냥 주머니에 넣고 다니고 카트리지 하나 가지고 다니는게 편해 쓸일은 없을 듯하다.케이스를 닫은 상태케이스 내부쿠폰 코드구매시에 디스카운트 받을 수 있는 쿠폰 코드가 메일로 제공되고 있어 이 부분을 공유한다.January10 : Offer expires 11:59pm, PST January 12, 2015Gh435pE9 : 10% Off Your Next Purchase. This Coupon expires on: 01/31/162015-12-29: 18일차 마트리지 9개째 이용중이 이틀에 하나 꼴로 소비하고 있는 것 같다. 배송기간을 생각해서 오늘 추가로 4팩을 주문했다.2016-01-02: 멘솔향 추가2016-01-11: 한달 사용기, 추가 구입 정보, 쿠폰2016-01-16: 클래식향 추가2016-01-21: 케이스 추가2016-01-27: 쿠폰","categories":[{"name":"device","slug":"device","permalink":"http://blog.bglee.me/categories/device/"}],"tags":[]},{"title":"Jaybird BBX 본사 A/S 후기","slug":"jaybird_bbx_as","date":"2016-01-07T15:00:00.000Z","updated":"2018-03-29T06:03:19.626Z","comments":true,"path":"posts/2016/jaybird_bbx_as/","link":"","permalink":"http://blog.bglee.me/posts/2016/jaybird_bbx_as/","excerpt":"","text":"Jaybird BBX2013년 4월 제이버드 BBX를 랏츠몰에서 19만원에 가까운 돈을 주고 구매했다. 디자인도 디자인이고 배터리 지속시간등이 너무 마음에 들어 잘 썼던 제품이다. 2013년 7월 고장이 나서 한번 교품을 받았었고 2015년 10월 다시 고장이 났을땐 팬택 계열의 랏츠몰은 더 이상 운영을 하지 않는 상황이었다. A/S는 아직 된다는 설도 있으나 구입한지 1년이 지나 보증기간이 지난 상태에서 A/S관련 포스트를 읽고 미국 본사 A/S를 진행하기로 했다.증상고장난 내 BBX의 증상은 블루투스 페어링이 된 상태에서 음악이 나 게임등을 하다가 중간에 스스로“Power off” =&gt; “Power on” =&gt; “Searching for your music devices”뭐 이런식의 멘트가 반복되는 일종의 무한루프였다. 하드웨어 리셋을 검색하여 시도해 봤으나 동일 증상이 반복되어 일단 이에 대한 메일을 제이버드 서포트 홈페이지를 통하여 보냈다. 시차가 완전히 꼬이는 관계로 하루에 메일을 하나 받고 하나 회신을 하는데 새벽 4시경에 회신이 와서 바로 회신을 한 경우에도 다음날 새벽에 회신이 오는 것을 보면 LIVE HELP 메뉴를 통해 채팅으로 서비스를 받는편이 나을 것 같다.과정2015-12-09 나: 고장 증상, 구매 위치를 알리고 고객 지원을 받을 수 있는가?2015-12-09 Jaybird: 구매 증명을 할 수 있는가?2015-12-09 나: 랏츠몰에서 주문증명 서류발급은 아직 가능한 관계로 캡쳐 이미지 및 PDF 파일 전송2015-12-10 Jaybird: 좋다. 이름, 이메일(메일로 대화하고있는데…?) 주소, 주소, 전화번호를 다오2015-12-15 나: 정보를 보냄*2015-12-15 Jaybird: 보증 교환을 해주겠다. 자세한 상황은 메일 보냈다. 그리고 x2s(x2?)를 보내주겠다2015-12-15 나:(RMA코드 메일을 받음), 내가 x2를 받게 되는게 맞는지 재차 확인해달라.2015-12-16 Jaybird: 맞다.2015-12-16 우체국 EMS를 통해 발송(27,600(배송비) + 400(박스비))2015-12-16 나: EMS으로 보냈고 tracking number 첨부했다.2015-12-17 Jaybird: 들어오면 메일 주겠다.2015-12-23 Jaybird에 EMS 도착2015-12-24 Jaybird: x2 배송추적이 안되는 써있는데 트래킹 넘버를 포함해서 배송을 알려왔고 주문서 형식으로 이메일이 발신되었다.추적이 끊긴지 일주일이 되었고 검색 결과 LN으로 시장하는 경우 원래 갑자기 추적이 안된다고한다.2016-01-08 택배가 아닌 우편 형식인지라 박스인데도 불구하고 우편함에 들어가있었다. 추적은 안되지만 미국 본사에서 발송한지 15일만에 X2를 받아 볼 수 있게됐다.후기집에 IT기기가 굉장히 많은관계로 잭이 맞다고 아무 충전기나 사용했던게 잦은 고장의 원인이 될 수 있다는 생각이 왜 지금 드는지 모르겟다. 출력 암페어를 잘 봐야할 것 같다.국내 A/S는 1년이였는데… 본사에서… 하.. 미국. 게다가 BBX가 아닌 X2로 돌아오다니.","categories":[{"name":"device","slug":"device","permalink":"http://blog.bglee.me/categories/device/"}],"tags":[]},{"title":"제이버드 X2","slug":"jaybird_x2","date":"2016-01-07T15:00:00.000Z","updated":"2018-03-29T06:03:19.627Z","comments":true,"path":"posts/2016/jaybird_x2/","link":"","permalink":"http://blog.bglee.me/posts/2016/jaybird_x2/","excerpt":"","text":"어쩌다 보니(BBX가 망가져서 A/S보내 X2로 교환받은 포스트)를 갖게 되었다. 성능상으로의 스펙의 차이는 크게 없고 둘다 검정인데(미드나잇 블랙) X2의 색상은 무광으로 처리되어 있어 조금더 고급스러운 느낌이 든다.2016-01-22어제 간만에 외출을 하면서 간만에 사용하려고 핸드폰의 블루투스를 키고 X2전원을 눌렀는데 바로 연결됐다는 소리가 들렸다. 대기전력 상태였나? 홈페이지에서 매뉴얼을 참고해보니 맞는 것 같다. 250시간. 몇일동안 안쓰다가 바로 연결했는데 배터리가 반이나 차있어서 좋았다. 아이폰은 페어링시 배터리 잔량이 폰에 표시된다.","categories":[{"name":"device","slug":"device","permalink":"http://blog.bglee.me/categories/device/"}],"tags":[]},{"title":"Jekyll","slug":"blog_with_jekyll","date":"2016-01-05T15:00:00.000Z","updated":"2018-03-29T06:03:19.623Z","comments":true,"path":"posts/2016/blog_with_jekyll/","link":"","permalink":"http://blog.bglee.me/posts/2016/blog_with_jekyll/","excerpt":"","text":"기존 블로그 플랫폼의 경험네이버, 티스토리, 텀블러, 고스트 등등 블로그 플랫폼을 맛만 봤었다. 각자 장, 단점이 있는데 내가 느끼는 바를 표로 정리해봤다.네이버 - 쉽다, 네이버에서 유저 유입, 네이버 내에서의 강력한 커뮤니티티스토리 - 쉽다, 광고 플랫폼과의 연동, 다음에서의 유저 유입텀블러 - 마크다운 지원워드프레스 - 기억 안남고스트 - 기억 안남지킬을 선택한 이유자유도를 원했다.컨텐츠가 플랫폼 독립적이길 원했다.마크다운 언어 사용.자유도는 물론 설치형 플랫폼을 선택하는 경우 얻어진다. 워드프레스, 고스트등이 해당될 것으로 보인다. 사용하는 입장에서는 스킨 사용 폭 정도가 되지 않을까 한다.컨텐츠가 플랫폼 독립적이다. 이 말은 컨텐츠가 물건이면 플랫폼은 그걸 그저 전시하는 공간으로 사용하겠다는 이야기다. 지킬이 가장 마음에 들었던 것은 마크다운으로 컨텐츠가 관리된다는 점이다. 마크다운 언어는 매우 간결하며 text파일 이면서도 가독성이 좋다. 때문에 글을 쓰는 입장에서는 마크다운 언어 하나를 배워서 텍스트 에디터 하나만으로도 포맷을 갖춘 글 작성이 가능해진다.마크다운을 지원하는 블로그 플랫폼은 몇 가지 존재한다. 텀블러나 고스트 등이 그랬던 것으로 기억한다. 그러나 텀블러는 마크다운을 지원할 뿐 컨텐츠 독립적이진 않다.지킬은 글을 마크다운 언어만을 통해 작성한다. 그리고 설치형이기 때문에 지킬을 설치하고 인터넷에 있는 테마 하나를 받고 지킬을 통해 실행시키면 바로 서버는 운영상태가 된다. 테마 폴더안에 있는 _post 폴더에 마크다운 파일만 작성하면 된다.컨텐츠가 플랫폼 독립적이다.컨텐츠의 독립블로그 운영을 위해 깃허브등에서 원하는 테마를 포크했다고 해보자. 테마에는 각자의 설정파일이 존재하고 버전관리를 위해 포킹이 필요하다. 포크를 하고 샘플로 들어있는 _post 폴더를 삭제한다. 그리고 문서를 관리할 새로운 저장소를 하나 만들고 이를 여기에 클론을 한다. 그럼 테마는 테마대로 버전관리를 하면서 테마를 바꾸고 싶거나 할 때 아무 상관없이 포스트들이 저장되어있는 저장소를 다시 테마 안으로 클론 함으로써 컨텐츠는 플랫폼과 무관하게 계속 사용이 가능하게 된다.댓글도 독립댓글 은 컨텐츠 이상의 가치를 지닌다. 그러면서도 컨텐츠와 연관되어 있다. 컨텐츠가 플랫폼과 독립지 적이지 않은경우 여기서 문제가 발생한다. 댓글이 플랫폼에 종속적이기 때문에 만약 다른 플랫폼으로의 이전을 하고 싶은 경우에는 그 동안 다른 사람들과의 소통을 하며 가치를 키워돈 댓글들을 상실하게 된다.이를 위해선 서드파티 댓글 시스템을 도입해야하고. 이는 소셜 댓글 서비스라는 이름으로 많이 알려져있다. 이런 점들이 자유도 를 가진 플랫폼을 선택했을 때 얻어지는 점이다.지킬의 장점지킬이 내세우는 장점은 사실 이런게 아니라 스태틱 웹 서버라 하여 php등이 서버 연산을 하여 뿌려지는 반면에 지킬은 문서가 작성되면(마크다운으로) 이를 Html로 컨버팅한 파일을 생성하고 이를 바로 서빙하는 것이다. 이를 통해 서버는 적은 연산으로 더 많은 사용자를 감당할 수 있게 될 것이다.내게는 이런 점보다 서버 효율적인 면보다 자유도가 더 크게 다가온다.지킬의 단점귀찮다. 지금도 테마 폰트 가독성등의 문제를 잡고 이미지 셋업등을 해야하는데 아직도 못하고 있다.","categories":[{"name":"draft","slug":"draft","permalink":"http://blog.bglee.me/categories/draft/"}],"tags":[]},{"title":"돈주고 구매한 프로그램들","slug":"programs","date":"2016-01-05T15:00:00.000Z","updated":"2018-03-29T06:03:19.631Z","comments":true,"path":"posts/2016/programs/","link":"","permalink":"http://blog.bglee.me/posts/2016/programs/","excerpt":"","text":"Windows반디캠WebStormNetDrive2","categories":[{"name":"draft","slug":"draft","permalink":"http://blog.bglee.me/categories/draft/"}],"tags":[]},{"title":"Ionic + TypeScript","slug":"ionic-typescript","date":"2016-01-03T09:19:28.244Z","updated":"2018-03-29T06:03:19.626Z","comments":true,"path":"posts/2016/ionic-typescript/","link":"","permalink":"http://blog.bglee.me/posts/2016/ionic-typescript/","excerpt":"","text":"Angular.js와 Ionic을 공부할 겸 해서 TypeScript와 함께 앱을 제작해 보려고 한다.프로토타입 제작Ionic framework을 이용하기로 했는데 이미 Ionic은 플랫폼화가 되어버려 지금은 Ionic Creator라는 프로토타입 제작 툴을 제공한다. 여러가지 도전을 해본 결과 UI디자이너가 없는 경우라면 프로토타입을 만드는데 시간이 오래걸려(UI를 만들어야하기 때문) 실패하는 경우가 꽤 있었다. 그래서 이를 이용하기로 했다.Ionic CreatorIonic Creator는 Ionic에서 앱을 생성할때 불러올 수 있는 장점이 있어 빠르게 프로토타입을 제작할 수 있을 것 같아 바로 선택했다.1$ ionic start [APP NAME] [TEMPLATE]기본적으로 TEMPLATE에 템플릿을 지정해서 앱 생성을 하게 된다.1$ ionic start [APP NAME] creator:[IONIC CREATOR PROJECT CODE]이때 만들어 놓은 프로토 타입을 불러와서 만드려면 위와 같이 하면 된다.Ionic Creator에서 Export를 누르면 영상을 포함해서 친절하게 설명해준다.프로젝트 생성환경 셋업1$ npm -g install cordova ionic typescript gulp bower프로젝트 생성프로토 타입을 만들었으면 코드 그릇이 될 프로젝트를 생성한다.123$ ionic start [APP NAME] creator:[IONIC CREATOR PROJECT CODE]$ cd [APP NAME]$ ionic serveAPP NAME 은 앱 이름인 동시에 폴더 이름이 된다. 위 코드를 실행하면 브라우저가 뜨면서 제작한 프로토 타입이 동작하는 것이 확인된다. 여기서 부터 시작이다.2016-01-03아이오닉 프로젝트에서 관리되는 gulpfile.js 를 열고 ts파일을 와치할 수 있도록 해준다1$ npm -g install gulp-tsc12345var typescript = require('gulp-tsc');gulp.task('compile', function() &#123; &#125;)진행중참조Automating Icons and Splash Screens","categories":[{"name":"draft","slug":"draft","permalink":"http://blog.bglee.me/categories/draft/"}],"tags":[]},{"title":"리디북스 페이퍼 라이트","slug":"ridibooks_paper_lite","date":"2016-01-02T15:00:00.000Z","updated":"2018-03-29T06:03:19.632Z","comments":true,"path":"posts/2016/ridibooks_paper_lite/","link":"","permalink":"http://blog.bglee.me/posts/2016/ridibooks_paper_lite/","excerpt":"","text":"리디북스의 대국민 독서지원 프로젝트 이벤트를 모르고 지나갔는데 앵콜로 다시하길래 1, 2, 3차를 모두 지르고 4차 이벤트로 베스트컬렉션을 169,000원에 리디북스 페이퍼 라이트를 껴서 파는 이벤트까지 모두 질렀다.재밌는 이벤트인게 1, 2, 3차를 모두 결재하게되면 16만원 4차 이벤트는 16만 9천원인데 1, 2, 3차로 들어온 포인트를 여기에 사용할 수 있다. 추가로 9천원을 결재하면 된다는 이야기인데 어쨋건 페이퍼 라이트가 8만 9천원에 들어오는 상황에서 읽을지 안읽을지는 모르지만 800권 수준의 명작(?)을 8만원에 50년 대여하는… 왠지 안하면 손해보는 느낌이 들게하는 이벤트라 구매를 하게 되었다.","categories":[{"name":"draft","slug":"draft","permalink":"http://blog.bglee.me/categories/draft/"}],"tags":[]},{"title":"진행 내역","slug":"milestone","date":"2015-12-20T15:00:00.000Z","updated":"2018-03-29T06:03:19.627Z","comments":true,"path":"posts/2015/milestone/","link":"","permalink":"http://blog.bglee.me/posts/2015/milestone/","excerpt":"","text":"블로그public git repository 생성 &amp; 테마 적용포스팅을 위한 private git repository 생성포스팅을 위한 사진 공유 서비스 환경 설정운영서버(odroid-xu3-lite)domain 구매 및 DNS 등록ruby &amp; jekyll 설치 및 운영node.js 설치(via NVM)external storage dock 연결WebDAV를 이용한 NAS 구성netatalk을 통해 afp 지원transmission-daemon을 통해 torrent 원격 다운로드 지원게임C# 공부게임 제작 일지(via Unity)","categories":[{"name":"draft","slug":"draft","permalink":"http://blog.bglee.me/categories/draft/"}],"tags":[{"name":"계획","slug":"계획","permalink":"http://blog.bglee.me/tags/계획/"},{"name":"지킬","slug":"지킬","permalink":"http://blog.bglee.me/tags/지킬/"},{"name":"jekyll","slug":"jekyll","permalink":"http://blog.bglee.me/tags/jekyll/"},{"name":"milestone","slug":"milestone","permalink":"http://blog.bglee.me/tags/milestone/"}]},{"title":"Atom","slug":"atom_plugin_list","date":"2015-12-19T15:00:00.000Z","updated":"2018-03-29T06:03:19.621Z","comments":true,"path":"posts/2015/atom_plugin_list/","link":"","permalink":"http://blog.bglee.me/posts/2015/atom_plugin_list/","excerpt":"","text":"pluginsseti-icons","categories":[{"name":"draft","slug":"draft","permalink":"http://blog.bglee.me/categories/draft/"}],"tags":[]},{"title":"netatalk 3","slug":"afp","date":"2015-07-25T00:00:00.000Z","updated":"2018-03-29T06:03:19.621Z","comments":true,"path":"posts/2015/afp/","link":"","permalink":"http://blog.bglee.me/posts/2015/afp/","excerpt":"","text":"netatalkOSX finder 에서 cmd + k를 통해 네트워크 드라이브를 쉽게 연결하여 쓸 수 있는데, afp:// 프로토콜로 연결하려면 server에 netatalk 설치가 필요하다. 이 시점에서는 3.1.7버전이 사용되었고 설치된 서버는 hardkernel odroid xu3 lite가 사용됐으며 os는 ubuntu 14.04 32bit다.http://netatalk.sourceforge.net/123$ ./configure --with-init-sytle=debian$ sudo apt-get install libdb-dev$ makeO_IGNORE관련 에러가 날 수 있는데 해결방법 은 아래와 같다.include/atalk/acl.h, line 63, #define O_IGNORE 0를 추가한다.123#define O_NETATALK_ACL 0#define O_IGNORE 0 // added#define chmod_acl chmod1$ sudo make installafp는 ln -s로 생성되는 symbolic link를 지원하지 않는 것으로 보인다.","categories":[{"name":"program","slug":"program","permalink":"http://blog.bglee.me/categories/program/"}],"tags":[]},{"title":"nginx-webdav","slug":"nginxwebdav","date":"2015-07-23T15:00:00.000Z","updated":"2018-03-29T06:03:19.630Z","comments":true,"path":"posts/2015/nginxwebdav/","link":"","permalink":"http://blog.bglee.me/posts/2015/nginxwebdav/","excerpt":"","text":"NGINX WebDAV setupnginx에 모듈을 추가하기 위해 빌드를 다시 해야하므로 nginx stable 버전 source와 nginx-dav-ext-module을 다운로드 받아 압축을 푼다.nginxnginx-dav-ext-module기존 설치되어 있는 nginx의 설정을 복사하기 위해 아래 명령어를 실행하고 –with부터 복사를 해둔다.12345bglee@deptno:~/tmp/nginx/nginx-1.8.0$ nginx -Vnginx version: nginx/1.4.6 (Ubuntu)built by gcc 4.8.2 (Ubuntu/Linaro 4.8.2-19ubuntu1)TLS SNI support enabledconfigure arguments: --with-cc-opt='-g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security -D_FORTIFY_SOURCE=2' --with-ld-opt='-Wl,-Bsymbolic-functions -Wl,-z,relro' --prefix=/usr/share/nginx --conf-path=/etc/nginx/nginx.conf --http-log-path=/var/log/nginx/access.log --error-log-path=/var/log/nginx/error.log --lock-path=/var/lock/nginx.lock --pid-path=/run/nginx.pid --http-client-body-temp-path=/var/lib/nginx/body --http-fastcgi-temp-path=/var/lib/nginx/fastcgi --http-proxy-temp-path=/var/lib/nginx/proxy --http-scgi-temp-path=/var/lib/nginx/scgi --http-uwsgi-temp-path=/var/lib/nginx/uwsgi --with-debug --with-pcre-jit --with-ipv6 --with-http_ssl_module --with-http_stub_status_module --with-http_realip_module --with-http_addition_module --with-http_dav_module --with-http_geoip_module --with-http_gzip_static_module --with-http_image_filter_module --with-http_spdy_module --with-http_sub_module --with-http_xslt_module --with-mail --with-mail_ssl_module압축을 해제한 nginx source 디렉토리에서 아래와 같이 configure를 설정한다12bglee@deptno:~/tmp/nginx/nginx-1.8.0$ ./configure --prefix=/etc/nginx --conf-path=/etc/nginx/nginx.conf --sbin-path=/usr/sbin/nginx --pid-path=/var/run/nginx.pid --lock-path=/var/lock/nginx.lock --user=http --group=http --http-log-path=/var/log/nginx/access.log --error-log-path=/var/log/nginx/error.log --http-client-body-temp-path=/var/lib/nginx/client-body --http-proxy-temp-path=/var/lib/nginx/proxy --http-fastcgi-temp-path=/var/lib/nginx/fastcgi --http-scgi-temp-path=/var/lib/nginx/scgi --http-uwsgi-temp-path=/var/lib/nginx/uwsgi --with-imap --with-imap_ssl_module --with-ipv6 --with-pcre-jit --with-file-aio --with-http_dav_module --add-module=/home/bglee/tmp/nginx/nginx-dav-ext-module-master --with-http_geoip_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_realip_module --with-http_spdy_module --with-http_ssl_module --with-http_stub_status_modulebglee@deptno:~/tmp/nginx/nginx-1.8.0$ service nginx start설정이 끝났으면 빌드와 설치를 하기 위해 아래와 같이 입력한다12bglee@deptno:~/tmp/nginx/nginx-1.8.0$ make &amp;&amp; make installbglee@deptno:~/tmp/nginx/nginx-1.8.0$ service nginx start빌드 오류일 경우 make에서, 퍼미션 오류일 경우 make install이 nginx를 설치하는 과정에 났다고 보면된다.전자의 경우는 구글에서 솔루션으르 검색하고 후자의 경우는 sudo make install로 설치하면 해결된다마지막으로 nginx 구동을 위해 아래 명령어를 실행하고 퍼미션 오류의 경우는 sudo를 붙여주면 된다.123bglee@deptno:~/tmp/nginx/nginx-1.8.0$ service nginx stopbglee@deptno:~/tmp/nginx/nginx-1.8.0$ service nginx reloadbglee@deptno:~/tmp/nginx/nginx-1.8.0$ service nginx start인증을 통해 제공하려면 https://www.digitalocean.com/community/tutorials/how-to-set-up-http-authentication-with-nginx-on-ubuntu-12-10를 참고한다.","categories":[{"name":"program","slug":"program","permalink":"http://blog.bglee.me/categories/program/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://blog.bglee.me/tags/nginx/"},{"name":"nginx webdav","slug":"nginx-webdav","permalink":"http://blog.bglee.me/tags/nginx-webdav/"},{"name":"webdav","slug":"webdav","permalink":"http://blog.bglee.me/tags/webdav/"},{"name":"dav","slug":"dav","permalink":"http://blog.bglee.me/tags/dav/"}]},{"title":"LEARN: Unity & C#","slug":"unity-csharp","date":"2015-07-21T15:00:00.000Z","updated":"2018-03-29T06:03:19.633Z","comments":true,"path":"posts/2015/unity-csharp/","link":"","permalink":"http://blog.bglee.me/posts/2015/unity-csharp/","excerpt":"","text":"교재유니티와 C#으로 배우는 게임 개발 교과서002. 디지털 프로토타입 제작18장: HELLO WORLD: 첫 번째 프로그램Rigidbox의 mass는 질량으로 단위는 1KG가 된다.Rigidbox 속성을 추가해야지만 물리각 작동된다.prefab은 instance화가 가능한 GameObject다.code에서 Instantiate를 통해 연결된 prefab을 생성할 수 있다.프로젝트 파네에 instance화가 가능한 prefab은 항상 큐브 모양의 아이콘이 왼쪽에 표시된다.19장: 변수와 컴포넌트float은 double보다 정확도가 떨어지지만 속도가 빠르기 때문에 모든 기본 제공 유니티 함수는 double이 아닌 flaot형을 사용한다.float은 1이하 수천 이상에서 심각하게 정확도가 떨어지기 때문에 게임의 요소는 1이상 수천 이하에 유지되는 것이 효율적이다.char는 ‘’ string은 “”으로 감싸져야지만 된다.주요 유니티 변수 타입변수설명Vector33개의 flaot 변수의 집합Color투명 정보가 포함된 색Quaternion회전 정보Mathf수학 함수 라이브러리Screen디스플레이에 대한 정보SystemInfo장치에 대한 정보GameObject씬에 포함된 모든 게임오브젝트 형식유니티 게임오브젝트와컴포넌트컴포넌트설명트랜스폼위치, 회전 배율MeshFilter화면에 보이는 모델Renderer게임오브젝트 표시Collinder게임오브젝트의 물리적 존재Rigidbody물리 시뮬레이션스크립트여러분이 작성하는 C# 스크립트20장: 부울 연산과 조건문 &&, || 는 단축 연산자로써 첫 번째 구문에서 답이 나온경우 두번째 구문을 실행하지 않는다. &, | 는 첫 번째 구문과 상관없이 두번째 구문까지 평가한다. &는 | 보다 우선순위가 높다. switch문은 리터럴의 동등 비교만 허용21장: 루프22장: 리스트와 배열23장: 함수와 매개 변수params keyword를 통해 동일한 형식의 매개 변수를 수에 제한 없이 받도록 할 수 있다.1234567int Add(params int[] ints) &#123; int sum = 0; foreach (int i in ints) &#123; sum += i; &#125; return (sum);&#125;24장: 디버깅클래스 명과 파일 명은 동일해야 한다.재생중이거나 일시정지 상태에서의 변경사항은 적용되지 않는다.25장: 클래스set 접근자에는 암시적 변수 value가 존재한다.[SerializeField] 특성은 private 변수를 인스펙터에서 확인하고 편집할 수 있게 해준다.123int Add(params int[] ints) &#123;[SerializeField]private int _num = 0;26장: 객체 지향적 사고27장: 애자일 사고방식너무 귀찮아서 더 이상 읽을 수가 없다.003. 게임 프로토타입 예제와 실습28장: 프로토타입 1: 사과 받기코드보다 인스펙터에서의 public 변수 수정이 우선하게 된다.Destroy(this);는 Script 컴포넌트 자체를 삭제하게 되며 인스턴스 삭제를 위해서는 Destroy(this.gameObject);를 사용한다.123456789// MonoBehaviour ClassAwake() // Start() 보다 먼저 호출된다. 데이타 세팅등에 사용된다.Start() // 시작할 때 한번 호출 된다.Update() // 프레임 마다 호출 된다.// 외Camera.main // main camera 접근 전역 변수PlayerPref // javascript localStorage 역할을 한다.Application.LoadLevel(\"Scene Name\"); // Scene을 로드한다.29장: 프로토타입 1: 미션 데몰리션magnitude는 Vector의 length다12transform.Find(\"Object Name\"); // 하위 오브젝트를 찾을때&lt;GameObject&gt;gameObject.SetActive(false); // GameObject가 비활성화 되면 이벤트, 렌더링 함수가 호출 되지 않는다.","categories":[{"name":"summary","slug":"summary","permalink":"http://blog.bglee.me/categories/summary/"}],"tags":[{"name":"유니티와 C#으로 배우는 게임 개발 교과서","slug":"유니티와-C-으로-배우는-게임-개발-교과서","permalink":"http://blog.bglee.me/tags/유니티와-C-으로-배우는-게임-개발-교과서/"},{"name":"unity","slug":"unity","permalink":"http://blog.bglee.me/tags/unity/"},{"name":"unity3d","slug":"unity3d","permalink":"http://blog.bglee.me/tags/unity3d/"},{"name":"게임 개발","slug":"게임-개발","permalink":"http://blog.bglee.me/tags/게임-개발/"},{"name":"C#","slug":"C","permalink":"http://blog.bglee.me/tags/C/"},{"name":"씨샵","slug":"씨샵","permalink":"http://blog.bglee.me/tags/씨샵/"}]},{"title":"Google IO extended Seoul","slug":"google_io_extension_session.web","date":"2015-07-14T15:00:00.000Z","updated":"2018-03-29T06:03:19.625Z","comments":true,"path":"posts/2015/google_io_extension_session.web/","link":"","permalink":"http://blog.bglee.me/posts/2015/google_io_extension_session.web/","excerpt":"","text":"Google IO extendedChrome exchanted 2015GeoLocation APIpermissionMETA TAGmeta tag theme, content 로 주소창의 색을 바꿀 수 있다.simply recommend installing your web app설치 유도 웹 배너, 크롬에서 동작 가능(install banner)일반적으로 manifest.json을 생성html의 link태그에서 ref=’manifest’ href=’xxx.json’과 같은 형식123window.addEventListener('beforeinstallprompt', function(e) &#123; //e.userChoice.then&#125;);chrome custom tab프로그램을 실행시키는 방법browserwebview둘간에 컨텍스트 공유가 되지 않는다.chrome custom tab은 컨텍스트 공유가 가능하다.(로그인 정보 등)sugar의 홈메뉴와 같은 느낌인듯weight: browser &gt; chrome custom tab &gt; webviewcct가 뜨기전에 pre-start, pre-fetch등이 가능하다.native app install bannerandroid만 가능자주들어오는 방문자(2주 2일 2회이상)일 경우 네이티브 앱 설치 프로모션 배너를 띄울 수 있음service workeroff-line지원가능.web worker와는 다르게 대몬과 같이 동작한다 생성이 아닌 설치의 개념으로 말해진다.web worker는 ui thread와는 다르게 dom에 대한 접근이 불가능한데 이 점은 web worker와 같다.push 서비스의 구현이 가능하다. chrome browser에서만 지원이 된다.service worker의 경우 타 브라우저에서도 지원을 하기로 한 상태, 사파리는 모르겠음.service worker가 지원되지 않는 경우에도 기존과 같이 동작이 가능한 장점이 있다.Polymer첫 폴리머 사이트: google-status.com?translate comnunitysantatracker.google폴리머를 구성하는 4개의 스펙에 대한 관심을 가져달라.Polymer Starter KitWeb Starter Kit프로젝트 템플릿 &amp; 워크플로speaker: @ragingwindvulcanize: concat과 비슷한 과정(crisper?)stream도 한번써보시구요celenium은 무엇인지?12345$ npm install -g generator-polymer$ yo polymer$ // yo polymer:element new-element$ // yo polymer:seed new-element$ // yo polymer:ghmkcd 명령어가 존재했었나?커스텀 엘레먼트들이 모이는 곳FireBase와 Angular.js기본적으로 PaaSParse, Firebase, bass.ioAngularFire라는 라이브리가 존재AngularFire쓰지말고 mvc.js쓰지 말라고RAILResponseAnimationIdleLoadCritical Rendering PathrequestAnimationFrame API를 사용하라selector는 복잡도를 낮게 하라wil-change(transform) 사용크롬 실행실 화면에서 shift키 6번 히든메뉴디자이너가 없어도 괜찮아무료 이미지 사이트unsplashlifeofpixfloating action button은 1개정도lazied button 10개 정도버튼은 대문자Guidelinegetmdl.io","categories":[{"name":"summary","slug":"summary","permalink":"http://blog.bglee.me/categories/summary/"}],"tags":[{"name":"google io","slug":"google-io","permalink":"http://blog.bglee.me/tags/google-io/"},{"name":"google io extended","slug":"google-io-extended","permalink":"http://blog.bglee.me/tags/google-io-extended/"},{"name":"web 세미나","slug":"web-세미나","permalink":"http://blog.bglee.me/tags/web-세미나/"}]}]}