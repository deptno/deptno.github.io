<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>봉로그</title>
  
  <subtitle>do 봉지니어링 | 기술 관련된 글 포스팅은 앞으로 &lt;a href=&quot;https://medium.com/@deptno&quot;&gt;medium.com/@deptno&lt;/a&gt;에 포스팅합니다.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.bglee.me/"/>
  <updated>2018-07-16T18:11:38.986Z</updated>
  <id>http://blog.bglee.me/</id>
  
  <author>
    <name>deptno@gmail.com</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cognito, Multi IDP Login 분석</title>
    <link href="http://blog.bglee.me/posts/2018/cognito/cognito/"/>
    <id>http://blog.bglee.me/posts/2018/cognito/cognito/</id>
    <published>2018-07-16T18:00:00.000Z</published>
    <updated>2018-07-16T18:11:38.986Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>:warning: 작성 중</p></blockquote><blockquote><p>:warning: 개인적인 정리라 확실성을 띄는 단어를 사용하지만 실제론 그렇지 않을 수 있다.</p></blockquote><blockquote><p>이 글은 목적이 존재하며 Cognito 의 소개 글이 아니다. Cognito 는 AWS 문서를 참조 바란다.</p></blockquote><blockquote><p>현재라는 문구가 사용되면 작성 시점인 2018년 7월 17일이다.</p></blockquote><p><code>사용자 풀</code> 과 <code>연동 자격 증명 풀</code> 두 가지가 존재하며 각각 따로 생성이 가능하며 연동도 가능하다. 궁극적으로 알고자 하는 것은 아래 와 같다.</p><ol><li>여러 IDP의 로그인을 통해 정보를 취합하는 앱을 만들경우 이 로그인 정보들을 어떻게 취합해서 어떻게 관리할 것인가?</li><li>사용자 풀 에서도 IDP 를 연동할 수 있고, 연동 자격 증명에서도 사용자 풀과 여타 IDP 연결이 가능한데, 무엇이 다른가?</li></ol><p>특별히 궁금한 부분은 AWS 문서에도 <a href="https://docs.aws.amazon.com/ko_kr/cognito/latest/developerguide/cognito-user-pools-identity-federation.html" target="_blank" rel="noopener">노트</a>로도 표시되어 있다.</p><blockquote><p>참고</p><p>타사(연동)를 통한 로그인을 Amazon Cognito 사용자 풀에서 사용할 수 있습니다. 이 기능은 Amazon Cognito 자격 증명 풀(연동 자격 증명)을 통한 연동과 무관합니다.</p></blockquote><p>결국 두 방식은 다르다는 뜻으로 해석되며 <strong>2 번과 관련해서는 예상 되는 결과</strong> 는 아래와 같다.</p><ul><li><p>사용자 풀 베이스</p><p>회원가입 후 로그인 이후에 IDP 로그인을 지원하며 이에 따라 정보가 자연스럽게 취합이 가능.</p></li><li><p>연동 자격 증명 베이스</p><p>로그인 퍼스트 전략으로 인증된 IDP와 앱이라면 일단 로그인이 가능하며 그에 따른 인가가 이루어짐.</p></li></ul><h2><span id="사용자-풀">사용자 풀</span></h2><p>사용자 풀은 자체 DB를 갖는 일반적인 구현 형태와 같다. 때문에 회원 가입, 회원 정보, 로그인 방식(MFA 와 같은), SMS, Email 인증등을 전반적으로 제어 할 수 있다.</p><h3><span id="연동-gt-자격-증명-공급자">연동 &gt; 자격 증명 공급자</span></h3><p>일단 연동 자격 증명과는 달리 입력 요구사항이 다르다.</p><blockquote><p>ID(Client ID) 외에 앱 보안(Secret Key)를 요구하고 인증 범위(Scope)에 대한 지정이 가능하다. 명시적(explicit) 또는 3-way 로그인 방식에서 쓰이는 요구 사항과 같으며 이에 대한 뒷 작업을 Cognito가 해주는 것으로 예상 된다.</p></blockquote><h4><span id="현재-지원되는-idp">현재 지원되는 IDP</span></h4><ul><li>Facebook</li><li>Google</li><li>Login with Amazon</li><li>SAML</li><li>OpenID Connect</li></ul><h3><span id="연동-gt-속성">연동 &gt; 속성</span></h3><blockquote><p>IDP 로그인을 통해 들어온 정보와 가입시의 정보가 다른 경우 어떤 정보가 저장되는가?</p></blockquote><hr><h2><span id="연동-자격-증명federated-identities">연동 자격 증명(Federated Identities)</span></h2><p>기본적으로는 <strong>사용자 풀</strong> 없이도 단지 인증된 <strong>IDP</strong>와 <strong>앱 정보</strong>를 통해 유저를 인증하고 <strong>롤</strong>(IAM)에 따라 인가할 수 있다. 간단한 어플리케이션에서 유용할 것으로 보인다.</p><h3><span id="자격-증명-풀-편집">자격 증명 풀 편집</span></h3><p><strong>인증되지 않은 역할</strong>, <strong>인증된 역할</strong>에 IAM을 할당하여 권한을 지정 함</p><h3><span id="인증-공급자">인증 공급자</span></h3><p><strong>인증 공급자(Identity Provider - IDP)</strong>를 등록한다. 인증 공급자는 OAuth를 지원 업체로 생각 할 수 있다.</p><p><strong>IDP</strong> 등록을 위해서는 각 <strong>IDP</strong> 에서 생성한 App ID 가 필요하며 여기서 등록해 둔다.</p><blockquote><p><code>예제 0</code> 페이스북을 통해 얻은 토큰 등록</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AWS.config.credentials = <span class="keyword">new</span> AWS.CognitoIdentityCredentials(&#123;</span><br><span class="line">    IdentityPoolId: <span class="xml"><span class="tag">&lt;<span class="name">연동</span> 자격 증명 풀 <span class="attr">ID</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">    Logins        : &#123;</span></span><br><span class="line">        'graph.facebook.com': response.authResponse.accessToken&lt;Facebook access token&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>이렇게 <code>credentials</code> 를 등록함으로써 로그인이 된 것으로 간주하고 <strong>인증된 역할</strong> 의 권한을 얻는다.</p><h4><span id="여러-idp를-통해-로그인이-필요한-경우">여러 IDP를 통해 로그인이 필요한 경우</span></h4><p>여러 IDP를 통해서 로그인이 필요한 경우에는 각 로그인마다 다른 유저로 인식 되므로 이전 로그인 정보를 취합하여 다시 저장할 필요가 있다. 즉, <code>Logins</code> 의 오브젝트를 확장해야한다. 코드로 표현하면 다음과 같을 것으로 보인다.</p><blockquote><p><code>예제 1</code> 여러 IDP 토콘을 저장하는 경우</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AWS.config.credentials = <span class="keyword">new</span> AWS.CognitoIdentityCredentials(&#123;</span><br><span class="line">    IdentityPoolId: <span class="xml"><span class="tag">&lt;<span class="name">연동</span> 자격 증명 풀 <span class="attr">ID</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">    Logins        : &#123;</span></span><br><span class="line">        'graph.facebook.com': response.authResponse.accessToken&lt;Facebook 억세스 토큰&gt;,</span><br><span class="line">    'cognito-idp.&lt;리전&gt;.amazonaws.com/&lt;유저풀 ID&gt;': result.getIdToken().getJwtToken()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p><code>예제 2</code> 순서가 정의되고 이미 <code>credentials</code> 이 이미 등록어 있어 이를 확장하는 경우</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AWS.config.credentials = <span class="keyword">new</span> AWS.CognitoIdentityCredentials(&#123;</span><br><span class="line">    IdentityPoolId: <span class="xml"><span class="tag">&lt;<span class="name">연동</span> 자격 증명 풀 <span class="attr">ID</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">    Logins        : &#123;</span></span><br><span class="line"><span class="xml">        ...AWS.config.credentials,</span></span><br><span class="line"><span class="xml">    'cognito-idp.<span class="tag">&lt;<span class="name">리전</span>&gt;</span>.amazonaws.com/<span class="tag">&lt;<span class="name">유저풀</span> <span class="attr">ID</span>&gt;</span>': result.getIdToken().getJwtToken()</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;)</span></span><br></pre></td></tr></table></figure><h4><span id="현재-지원되는-idp-목록">현재 지원되는 <strong>IDP</strong> 목록</span></h4><ul><li>Cognito</li><li>Amazon</li><li>Facebook</li><li>Google+</li><li>Twitter / Digits</li><li>OpenID</li><li>SAML</li><li>사용자 지정</li></ul><h4><span id="use-case">Use Case</span></h4><h5><span id="두개의-idp-facebook-으로-로그인-후-cognito-로-다시-인증하는-경우">두개의 IDP: Facebook 으로 로그인 후, Cognito 로 다시 인증하는 경우</span></h5><p><code>예제 0</code> 의 코드와 같은 방식으로 두번 각기 등록하는 경우는 유저가 2명으로 인식되나 <code>Logins</code> 에 두 정보를 함께 등록하는 경우 이 정보가 취합되어 한명의 유저로 인식된다.</p><p><code>Logins</code> 에 한번이라도 함께 등록되면 각기 다른 <strong>IDP</strong>에 의해 발급된 두개의 토큰은 함께 연결되는 것으로 보인다. 때문에 함께 저장하는 순간 유저 수 인식이 2 에서 1명으로 변경된다.</p><h2><span id=""><img src="federated_identities_logins.png" alt="federated_identities_logins"></span></h2><p>위 이미지는 <code>Logins</code> 에 함께 저장 후 대쉬보드의 화면이며 <strong>Facebook</strong> 로그인(파란색)과 <strong>Cognito</strong> 로그인(녹색)이 각각 카운트가 1이나 총 자격 증명이 1 로 인식되는 걸 확인 할 수 있다. 함께 저장하기 전에는 총 자격 증명이 2 였다.</p>]]></content>
    
    <summary type="html">
    
      Cognito, multi IDP login
    
    </summary>
    
    
      <category term="cognito" scheme="http://blog.bglee.me/tags/cognito/"/>
    
      <category term="multi idp" scheme="http://blog.bglee.me/tags/multi-idp/"/>
    
      <category term="idp" scheme="http://blog.bglee.me/tags/idp/"/>
    
      <category term="user pool" scheme="http://blog.bglee.me/tags/user-pool/"/>
    
      <category term="federated Identities" scheme="http://blog.bglee.me/tags/federated-Identities/"/>
    
  </entry>
  
  <entry>
    <title>typora</title>
    <link href="http://blog.bglee.me/posts/2018/typora/"/>
    <id>http://blog.bglee.me/posts/2018/typora/</id>
    <published>2018-07-16T04:48:06.000Z</published>
    <updated>2018-07-16T06:13:48.710Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="typora-마크다운-에디터-소개">Typora, 마크다운 에디터 소개.</span></h1><blockquote><p>Typora 를 주제로 Typora 를 사용하여 글 작성을 테스트 중이다. :cat2: 때문에 글 자체 보다는 이를 통해서 블로그 포스팅에 대한 생산성 검증 목적이 있다.</p></blockquote><h2><span id="마크다운-에디터-연대기">마크다운 에디터 연대기</span></h2><p>사용하는 혹은 사용했었던 에디터들이다.</p><table><thead><tr><th>에디터</th><th>평</th></tr></thead><tbody><tr><td><a href="http://www.vim.org" target="_blank" rel="noopener">ViM</a></td><td><a href="https://github.com/vim/vim" target="_blank" rel="noopener">오픈소스</a>, 지금도 간혹 쓴다. 한글 사용시 ViM 커맨드에 대한 고질적인 문제, 외부 프리뷰 이슈, 플러그인 설정 필요.</td></tr><tr><td><a href="https://bywordapp.com" target="_blank" rel="noopener">Byword</a></td><td>앱스토어 추천, 할인에 샀으나 특이점 없음.</td></tr><tr><td><a href="http://pad.haroopress.com" target="_blank" rel="noopener">하루패드</a></td><td><a href="https://github.com/rhiokim/haroopad" target="_blank" rel="noopener">오픈소스</a>, 독립 프로개름으로는 아마도 ViM을 지원하는 유일한 에디터가 아닐까한다. 국내 개발자이신 <a href="https://github.com/rhiokim" target="_blank" rel="noopener">Rhio</a> 님이 개발했다.</td></tr><tr><td><a href="https://code.visualstudio.com" target="_blank" rel="noopener">VSCode</a></td><td><a href="https://github.com/Microsoft/vscode/" target="_blank" rel="noopener">오픈소스</a>, 마소의 오픈소스 에디터, 마크다운을 기본적으로 지원.</td></tr><tr><td><a href="http://jetbrains.com/webstorm" target="_blank" rel="noopener">Webstorm</a></td><td>개발 툴인데 붙어 있으니 가끔 <code>README.md</code> 작성용으로 사용</td></tr><tr><td><a href="https://marktext.github.io/website/" target="_blank" rel="noopener">MarkText</a></td><td><a href="https://github.com/marktext/marktext" target="_blank" rel="noopener">오픈소스</a>, 가장 최근에 사용했던 에디터, 테이블 삽입, 에디팅과 프리뷰가 함께 어우러진 것이 인상적.</td></tr></tbody></table><p>한동안 미디움에서 글을 쓰고 있었는데 <a href="https://typora.io" target="_blank" rel="noopener">Typora</a> 라는 끝내주는 마크다운 에디터를 발견했다. 사실 본지는 좀 오래되었는데 최근에 쓰고 있던 마크다운 에디터가 만족스러워서 시도는 하지 않고 있다가 한글 타이핑시 문장 마지막에 <code>Tab</code> 입력시 글자가 사라지는 버그로 인해 고생해서 옮겨타게 되었다.</p><h2><span id="typora">Typora</span></h2><p>타이포라는 아직 베타 버전이며 곧 상용화 될 것으로 보인다. 안정적이며 별 버그가 없다. 테마도 다양하게 지원되고 있으며 마크다운을 통해 작성되며 글은 바로 테마가 입혀진 모습으로 보여진다. 프리뷰와 에디터가 빌트인 된 것으로 생각하면 된다.</p><h3><span id="이모지emoji">이모지(emoji)</span></h3><p>이모지를 훌륭하게 지원한다. 찾아볼 필요없이 <code>:</code> 를 입력하는 순간 자동 완성이 이미지와 함께 지원된다.</p><h3><span id="테이블">테이블</span></h3><p>일반적인 에디터를 이용할 때 가장 문제가 되는 것은 테이블 작성이다. 테이블 작성 문법이 시간이 오래걸려 여기서 생산성에 대한 이슈가 생기는데 커맨드를 통해 빠르고 직관적으로 테이블 생성이 가능하다.</p><h3><span id="이미지">이미지</span></h3><p>이미지 지원도 다소 짜증이 나는 영역인데, 블로그 글을 포스팅 할 때 이미지를 그냥 드래그해서 붙일 수 있다. 또한 그 것을 같은 폴더에 저장할 것인지 등도 정할 수 있으므로 사용성이 꽤나 최적화 되어있다.</p><h2><span id="모자란-점">모자란 점</span></h2><p>정말로 쓸 수 있는 프로그램이 되려면 몇 가지를 개선한다. 아직은 만족하고 있으나, 사업 계획서와 같은 방대한 문서를 작성할때 이슈가 되는 것 들이 몇가지 있었다.</p><h3><span id="실행-취소-다시-실행undo-redo">실행 취소, 다시 실행(Undo, Redo)</span></h3><p>이 부분이 다소 불안정적이다. 한글 작성과 함께 꼬이는 이슈일 수 있다. 많은 글을 작성하면서 당연히 신뢰하고 있는 실행 취소와 같은 기능들이 방금 전 타이핑이 아닌 그 전에 타이핑한 글을 취소한다던지 하는 이슈가 있었다. 난 글을 작성할 때 단락의 위치를 괘나 바꾸는데 그래서 생기는 문제인지는 모르겟으나 실행 취소가 바로 전 타이핑에 대한 것이 아닌 경우가 존재했다.</p><p>이는 꽤 치명적인 글로 그 취소를 내가 인지하지 못하는 경우가 있으면 글이 틀어져 버린다.</p><hr><blockquote><p>일단 여기까지 작성후 퍼블리싱 테스트 :cat2:</p></blockquote>]]></content>
    
    <summary type="html">
    
      Typora, 마크다운 에디터
    
    </summary>
    
    
      <category term="typora" scheme="http://blog.bglee.me/tags/typora/"/>
    
      <category term="markdown" scheme="http://blog.bglee.me/tags/markdown/"/>
    
      <category term="editor" scheme="http://blog.bglee.me/tags/editor/"/>
    
  </entry>
  
  <entry>
    <title>미디움으로 이사합니다.</title>
    <link href="http://blog.bglee.me/posts/2018/move-to-medium/"/>
    <id>http://blog.bglee.me/posts/2018/move-to-medium/</id>
    <published>2018-03-28T15:00:00.000Z</published>
    <updated>2018-03-29T06:41:17.921Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://medium.com/@deptno" target="_blank" rel="noopener">https://medium.com/@deptno</a>으로 이사합니다.</p><p>RSS: <a href="https://medium.com/feed/@deptno" target="_blank" rel="noopener">https://medium.com/feed/@deptno</a></p><p>이 곳엔 가끔 업데이트나 더 개인적인 주제들을 담고자 합니다.</p>]]></content>
    
    <summary type="html">
    
      RSS 구독자 분들을 위한 안내
    
    </summary>
    
      <category term="service" scheme="http://blog.bglee.me/categories/service/"/>
    
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="http://blog.bglee.me/posts/2017/python/"/>
    <id>http://blog.bglee.me/posts/2017/python/</id>
    <published>2017-11-10T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.631Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>macOS 기반으로 작성되었다.</p></blockquote><p>ml(머신러닝) 공부를 하기 위해 파이썬을 환경을 설정했다.</p><h2><span id="installation">installation</span></h2><p>brew는 기본적으로 설치되어 있어야 한다. <a href="http://deptno.github.io/posts/2016/osx" target="_blank" rel="noopener">참조</a></p><p>설치 각각에 종속성이 있을 수 있으므로 패키지 설치시마다 터미널을 재시작하면서 하도록 한다.</p><p>아나콘다라는 파이썬 배포판으로 데이터 사이언스 관련 패키지들을 포함하고 있다. 보통 책들에서 강력히 추천하므로 설치한다. 파이썬 배포판이므로 글을 쓰는 현재 python 3.6.3을 포함하여 설치된다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install anaconda</span><br></pre></td></tr></table></figure><p>프로젝트별 독립된 개발 환경을 만들어주는 <code>virtualenv</code>와 이를 편하게 사용하도록 해주는 <code>virtualenvwrapper</code>를 설치한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install virtualenv virtualenvwrapper</span><br></pre></td></tr></table></figure><p>사용하는 쉘의 설정 파일을 열어 다음을 추가한다. 설정 파일을 쉘에 따라 다르다.</p><p>~/.zshrc or ~/.bashrc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python virtualenv settings</span></span><br><span class="line"><span class="built_in">export</span> WORKON_HOME=~/workspace/virtualenvs</span><br><span class="line"><span class="built_in">export</span> VIRTUALENVWRAPPER_PYTHON=/usr/<span class="built_in">local</span>/anaconda3/bin/python</span><br><span class="line"><span class="built_in">source</span> /usr/<span class="built_in">local</span>/anaconda3/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure><p><code>~/workspace/virtualenvs</code> 이 부분은 사람마다 다른 경로를 사용하므로 사용하고자 하는 경로를 쓰면된다. 설정파일이 적용되기 전에(터미널 재시작 전) 폴더를 만들어준다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/workspace/virtualenvs</span><br></pre></td></tr></table></figure><p>터미널을 재시작하면 스크립트가 돌고 아래와 같은 명령어를 사용할 수 있게된다.</p><ul><li>mkvirtualenv 프로젝트명</li><li>rmvirtualenv 프로젝트명</li><li>workon 프로젝트명</li><li>deactivate</li></ul><p><code>ml</code>이라는 가상황경을 위한 라이프 사이클은 아래와 같다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 가상환경를 생성한다.</span></span><br><span class="line">bglee@since-20171107  mkvirtualenv ml</span><br><span class="line"><span class="comment"># 가상환경를 종료한다.</span></span><br><span class="line">(ml)  bglee@since-20171107  deactivate</span><br><span class="line"><span class="comment"># 가상환경에 진입한다.</span></span><br><span class="line">bglee@since-20171107  workon ml</span><br><span class="line"><span class="comment"># 가상환경를 종료한다.</span></span><br><span class="line">(ml)  bglee@since-20171107  deactivate</span><br><span class="line"><span class="comment"># 가상환경를 삭제한다.</span></span><br><span class="line">bglee@since-20171107  rmvirtualenv ml</span><br></pre></td></tr></table></figure><p>이제 가상환경은 설정이 되었고 프로젝트를 활성화(진입)한 상태로 <code>pip install package_name</code>을 할 경우 가상환경에 패키지가 포함되게 된다.</p>]]></content>
    
    <summary type="html">
    
      머신러닝을 위한 macOS 파이썬 환경설정
    
    </summary>
    
      <category term="service" scheme="http://blog.bglee.me/categories/service/"/>
    
    
      <category term="python" scheme="http://blog.bglee.me/tags/python/"/>
    
      <category term="파이썬" scheme="http://blog.bglee.me/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"/>
    
      <category term="ml" scheme="http://blog.bglee.me/tags/ml/"/>
    
      <category term="머신러닝" scheme="http://blog.bglee.me/tags/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D/"/>
    
      <category term="anaconda" scheme="http://blog.bglee.me/tags/anaconda/"/>
    
      <category term="아나콘다" scheme="http://blog.bglee.me/tags/%EC%95%84%EB%82%98%EC%BD%98%EB%8B%A4/"/>
    
      <category term="virtualenv" scheme="http://blog.bglee.me/tags/virtualenv/"/>
    
      <category term="virtualenvwrapper" scheme="http://blog.bglee.me/tags/virtualenvwrapper/"/>
    
  </entry>
  
  <entry>
    <title>Netlify</title>
    <link href="http://blog.bglee.me/posts/2017/netlify/"/>
    <id>http://blog.bglee.me/posts/2017/netlify/</id>
    <published>2017-10-03T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.627Z</updated>
    
    <content type="html"><![CDATA[<p>Netlify 는 스태틱 웹을 위한 CMS다. Git 서비스들을 통해 제공되며 레포지터리에 푸시를 할 경우 이를 자동으로 감지하고 빌드하며 재 배포한다. 여기에 본인이 도메인을 가진게 있다라면 본인의 도메인을 연결하여 서비스 할 수 있다.</p><blockquote><p>스태틱웹은 동적으로 URL을 생성하는 것이 아닌 그냥 실제 html파일 자체로 서빙을 한다고 생각하면 단순하다.</p></blockquote><p>Netlify 는 추가적으로 Let’s encrypt 를 서비스 안으로 포함시켜서 SSL(https://) 을 지원하며 이를 위해 DNS를 품고 있다. 자동으로 지원되지만 자신만의 도메인이 있어 이를 사용할 때는 Netlify DNS를 사용해야한다.</p><p>이번 &lt;bglee.me&gt;의 DNS를 Netlify 로 옮기면서 모든 페이지에 SSL을 적용하고 기존 블로그는 <a href="https://deptno.github.io" target="_blank" rel="noopener">https://deptno.github.io</a>로 되돌려 하나의 루트로 접근 경로를 통일했으며 기존 <a href="https://blog.bglee.me">https://blog.bglee.me</a>는 이제 SSL을 적용하고 기존 패스 그대로 <a href="https://deptno.github.io" target="_blank" rel="noopener">https://deptno.github.io</a>로 리다이렉트 시키도록 세팅했다. 이를 세팅 과정은 로컬 환경이 아닌 깃헙 레포지터리를 이용할 정도로 단순했고 Netlify 에서 지원하는 리다이렉트 옵션도 매우 직관적이었다.<a href="https://github.com/deptno/blog.bglee.me" title="적용 레포지터리" target="_blank" rel="noopener">1</a></p><h2><span id="배포">배포</span></h2><p>글을 작성하고 있는 현재 Netlify 에서 지원하고 있는 Git 클라우드 서비스는 아래와 같다.</p><ul><li>Gitub</li><li>Gitlab</li><li>Bitbucket</li></ul><p>잠깐 부연하자면 비공개 레포지터리를 만들기 위해서 Github은 유로 플랜을 써야하지만 나머지 둘은 기본적으로 비공개 레포지터리를 개인에게 무료로 허용한다.</p><p>로그인하면 바로 사용을 위한 화면이 시작되며 순서는 아래와 같다.</p><p><img src="netlify-sequence.png" alt="순서"></p><ul><li>사용하고 있는 레포지터리 서비스를 선택한다.(Git 클라우드 서비스들)</li><li>배포에 사용될 레포지터리를 선택한다.</li><li>배포에 사용될 브랜치, 빌드시 명령어, 그리고 빌드 명령어를 통해 생성된 배포될 파일들을 가리키는 디렉토리를 작성한다.</li></ul><p><img src="netlify-deploy.png" alt="배포"></p><p>그럼 바로 배포가 시작되며 앞으로 레포지터리에 푸시를 할 때마다 자동으로 빌드 =&gt; 배포가 진행된다.</p><h2><span id="커스텀-도메인과-dns">커스텀 도메인과 DNS</span></h2><p>커스텀 도메인을 을 사용하기 위해서는 <code>domain settings</code>에 들어가서 <code>custom domain</code>을 누르고 본인의 도메인을 입력해야한다. 도메인 셋업은 <code>www.YOUR_DOMAIN</code>을 통해야 SSL서비스를 받을 수 있다.</p><p>예를 들어 필자는 <code>www.bglee.me</code>를 입력하고 <code>HTTPS</code> 에서 주소를 확인한뒤에 <code>Force TLS connections</code>를 활성화 시켜 http접속을 https로 강제 리다이렉트 시켰다.</p><p>Netflify 에서는 <code>bglee.me</code>가 아닌 <code>www.bglee.me</code>를 등록하라고 권고하고 있으며 <code>www.bglee.me</code>를 등록시에 <code>bglee.me</code>도 자동으로 Netlify에 의해 등록되며 &lt;bglee.me&gt; 접속시 &lt;<a href="http://www.bglee.me&gt;로" target="_blank" rel="noopener">www.bglee.me&gt;로</a> 강제 리다이렉트된다.</p><h2><span id="추가적인-기능">추가적인 기능</span></h2><p><strong>와…</strong> 한 기능들을 몇개 지원한다.</p><h3><span id="브랜치를-통한-ab-테스트-지원">브랜치를 통한 A/B 테스트 지원</span></h3><p>브랜치를 추가적으로 등록할 수 있는데(A/B테스트 메뉴) 자동으로 로드밸런싱을 해서 A/B테스트를 하게 해준다.</p><h3><span id="pr시-스테이지-url">PR시, 스테이지 URL</span></h3><p>PR이 왔을시 이에대한 Preview URL을 생성할 수 있으며 이를 스테이지로 활용할 수 있다.</p><hr><h2><span id="next">next</span></h2><p>이제 스태틱 사이트를 작성하고 배포해보자.</p><hr>]]></content>
    
    <summary type="html">
    
      Git 레포지터리 Push 만으로 https까지 적용된 사이트를 지속적으로 빌드하고 배포할 수 있다.
    
    </summary>
    
      <category term="service" scheme="http://blog.bglee.me/categories/service/"/>
    
    
      <category term="netlify" scheme="http://blog.bglee.me/tags/netlify/"/>
    
      <category term="https" scheme="http://blog.bglee.me/tags/https/"/>
    
      <category term="ssl" scheme="http://blog.bglee.me/tags/ssl/"/>
    
      <category term="스태틱 웹" scheme="http://blog.bglee.me/tags/%EC%8A%A4%ED%83%9C%ED%8B%B1-%EC%9B%B9/"/>
    
      <category term="static web" scheme="http://blog.bglee.me/tags/static-web/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript와 Redux connect</title>
    <link href="http://blog.bglee.me/posts/2017/typescript-redux-connect/"/>
    <id>http://blog.bglee.me/posts/2017/typescript-redux-connect/</id>
    <published>2017-10-02T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.633Z</updated>
    
    <content type="html"><![CDATA[<p>타입스크립트와 리덕스로 SPA를 구현하는데 있어 기본적인 셋업이 아닌 문법적인 측면에 포커싱된 글로 타입스크립트를 활용하는데 도움이 되었으면한다.</p><p>필자는 하드 타이핑을 하지 않으며 추가적으로 린트를 쓰지 않는다. 리덕스는 자체적으로 타입스크립트 데피니션 파일(d.ts)을 가지고 있으므로 따로 타입 관련 패키지를 설치하지 않아도 된다.</p><h2><span id="설치">설치</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev typescript</span><br><span class="line">npm install redux</span><br></pre></td></tr></table></figure><h2><span id="redux">redux</span></h2><p>리덕스에 대한 설명을 돕기 위해 루트 스토어가 가지는 스테이트의 타입을 아래와 같이 정의하기로한다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.d.ts</span></span><br><span class="line"><span class="keyword">interface</span> RootState &#123;</span><br><span class="line">bglee: User</span><br><span class="line">deptno: User</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">name: <span class="built_in">string</span></span><br><span class="line">email: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="connectargs">connect(..args)</span></h3><p>리덕스를 쓰면서 가장 많이 쓰게 되는 함수일텐데 코드를 먼저 보이면 아래와 같다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123;connect, bindActionCreataors&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> StateProps &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> DispatchProps &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> OwnProps &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Props = StateProps &amp; DispatchProps &amp; OwnProps</span><br><span class="line"><span class="keyword">interface</span> State &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Container = connect&lt;StateProps, DispatchProps, OwnProps&gt;(</span><br><span class="line">(state: RootState) =&gt; (&#123;&#125;),</span><br><span class="line">dispatach =&gt; bindActionCreators(&#123;&#125;, dispatch)</span><br><span class="line">)(</span><br><span class="line"><span class="keyword">class</span> Component <span class="keyword">extends</span> React.Component&lt;Props, State&gt; &#123;</span><br><span class="line">render() &#123;</span><br><span class="line"><span class="keyword">return</span>&lt;p&gt;hello world&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p>위 코드는 완전히 동작하는 코드이고 컨테이너를 정의하기 위해 풀어쓴 기본적인 형태다. 참고로 connect 함수는 추가적인 옵션을 기술하기 위해 4개까지 인자를 받을 수 있다.</p><p>connect를 보면 3개의 타입을 받고 있다. 순서대로 살펴 보겠다.</p><h4><span id="stateprops">StateProps</span></h4><p>connect의 첫번째 인자는 <code>mapStateToProps</code>로 정의되어 있으며 함수 명과 같이 <code>Store</code>의 state를 <code>Component</code>의 props로 주입하는 함수다. 이 함수의 리턴 타입이라고 생각하면 된다.</p><p>예를 들어 Store에 <code>bglee</code>라는 프로퍼티를 연결하고자 한다면 <code>mapStateToProps</code>는 아마도 다음과 같이 작성되게 된다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStaetToProps = <span class="function">(<span class="params">state: RootState</span>) =&gt;</span> state.bglee</span><br></pre></td></tr></table></figure><p>그러면 Container는 props로 bglee가 가지고 있는 <code>name</code>, <code>email</code>을 받게 된다. 그럼 그에 맞춰서 <code>StateProps</code>를 정의하면 된다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StateProps &#123;</span><br><span class="line">name: <span class="built_in">string</span></span><br><span class="line">email: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>작성하고 보니 <code>User</code> 타입과 동일하다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StateProps = User</span><br></pre></td></tr></table></figure><p>로 정의해도되고 코드에서 StateProps를 User로 치환해도 된다. 이 경우는 예제를 위해 특수한 케이스기 때문에 이러하지만 여러 state를 props로 연결해야한다라면 곧 확장을 해야하니 StateProps라는 이름의 컨벤션을 유지해서 코드 일관성, 가독성을 확보하자.</p><p>다시 <code>mapStateToProps</code> 함수를 구현한 코드를 보면 아래와 같이 보일 것이 의심치 않는다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStaetToProps = (state: RootState): <span class="function"><span class="params">StateProps</span> =&gt;</span> (&#123;</span><br><span class="line">name: state.name,</span><br><span class="line">email: state.email</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>이해를 돕기 위해 완전히 풀어서 보였다. StateProps가 리턴되고 있다는 것만 인지하고 있으면 되며 위와 같은 코드작성은 connect가 타입을 받는 이유와 상충되므로 줄여서 작성하도록 하자.</p><h4><span id="dispatchprops">DispatchProps</span></h4><p>두번째 인자는 dispatch할 액션들이 Component의 props로 매핑된다. 위와 마찬가지로 두번째 인자의 이름인 <code>mapDispatchToProps</code>의 리턴 타입이다.</p><p>완벽한 이해를 위해 아래와 같이 액션이 정의해보자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contactBglee = <span class="function">(<span class="params"><span class="keyword">from</span>: <span class="built_in">string</span></span>) =&gt;</span> (&#123;</span><br><span class="line"><span class="keyword">type</span>: <span class="string">'CONTACT_BGLEE'</span></span><br><span class="line">payload: &#123;</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>액션은 <code>type</code>을 포함하는 오브젝트를 리턴하는 함수이며 <code>bindActionCreators</code>함수를 통해 dispatch가능한 형태가 된다.</p><p>그럼 두번째 인자의 구현부를 다시 보자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch = bindActionCreators(&#123;&#125;, dispatch)</span><br></pre></td></tr></table></figure><p>이름을 달고 정의한 액션을 바인딩해보자</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> bindActionCreators(&#123;</span><br><span class="line">contactBglee</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>작성된 <code>mapDispatchToProps</code>함수를 두번째 인자로 전달하게 되며 Container는 <code>contactBglee</code>액션을 디스패칭할 수 있다. Container는 <code>contactBglee</code> props를 가지고 있다는 의미며 이를 컴파일러에게 알려주기위해 두번째 DispatchProps는 아래와 같이 정의된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Dispatchprops &#123;</span><br><span class="line">contactBglee: typeof contactBglee</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>typeof</code>를 유심히 보자 contactBglee의 액션이 <code>from: string</code>인자를 취하는데 이를 재 다시 정의하는 것이아니라 기존 정의로부터 타입을 가지고 와서 추가해준다. 따라서 우린 중복정의 없이 기존 정의를 <code>typeof</code> 키워드를 통해서 쓸 수 있다.</p><h4><span id="ownprops">OwnProps</span></h4><p>마지막 타입은 기존 우리가 컴포넌트를 정의할 때 받는 부모로 부터 받게되는 그 인자를 정의하면 된다. <strong>컴포넌트를 컨테이너로 변경하는 경우라면 기존 컴포넌트의 인자가 OwnProps로 변경된다.</strong></p><hr><p>개인적으로 수없이 정의하게 되는 이런 타입과 함수들이 매우 반복적이기 때문에 <code>mapStateToProps</code>와 같은 함수를 정의하는 대신 inline으로 삽입하는 것을 선호하며 위에 설명한 것들을 함쳐 결과를 보면 아래와 같다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123;connect, bindActionCreataors&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123;contactBglee&#125; <span class="keyword">from</span> <span class="string">'./actions'</span> <span class="comment">// 액션이 존재하는 곳</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> StateProps <span class="keyword">extends</span> User &#123;&#125; <span class="comment">// type으로 정의도 가능하다</span></span><br><span class="line"><span class="keyword">interface</span> DispatchProps &#123;</span><br><span class="line">contactBglee: <span class="keyword">typeof</span> contactBglee</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> OwnProps &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Props = StateProps &amp; DispatchProps &amp; OwnProps</span><br><span class="line"><span class="keyword">interface</span> State &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Container = connect&lt;StateProps, DispatchProps, OwnProps&gt;(</span><br><span class="line">(state: RootState) =&gt; (&#123;</span><br><span class="line">...state.bglee</span><br><span class="line">&#125;),</span><br><span class="line">dispatach =&gt; bindActionCreators(&#123;</span><br><span class="line">contactBglee</span><br><span class="line">&#125;, dispatch)</span><br><span class="line">)(</span><br><span class="line"><span class="keyword">class</span> Component <span class="keyword">extends</span> React.Component&lt;Props, State&gt; &#123;</span><br><span class="line">render() &#123;</span><br><span class="line"><span class="keyword">return</span>&lt;p&gt;hello world&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><h2><span id="next">next</span></h2><p>이제 <code>render()</code>함수 안에서 this.props 그리고 <code>.</code>을 찍어보자.</p>]]></content>
    
    <summary type="html">
    
      redux connect를 제대로 typing 해보자
    
    </summary>
    
      <category term="dev" scheme="http://blog.bglee.me/categories/dev/"/>
    
      <category term="ts" scheme="http://blog.bglee.me/categories/dev/ts/"/>
    
    
  </entry>
  
  <entry>
    <title>Next.js</title>
    <link href="http://blog.bglee.me/posts/2017/next-js/"/>
    <id>http://blog.bglee.me/posts/2017/next-js/</id>
    <published>2017-05-07T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.630Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="nextjs">Next.js</span></h1><p>현재 회사의 <a href="https://www.rsquare.co.kr" target="_blank" rel="noopener">고객사이트</a>를 <a href="https://zeit.co/blog/next2" title="next.js" target="_blank" rel="noopener">next.js</a>와 <a href="https://www.typescriptlang.org/" title="typescript" target="_blank" rel="noopener">typescript</a> 기반으로 2017-04-10 일 기준으로 배포되었다. 간단하게 소개를 하고자 한다.</p><h2><span id="nextjs">next.js</span></h2><blockquote><p><a href="https://zeit.co/blog/next2" title="next.js" target="_blank" rel="noopener">next.js</a>는 node.js, <a href="https://facebook.github.io/react/" title="react.js" target="_blank" rel="noopener">react</a>기반의 유니버살 렌더링을 지원하는 프레임웍이다. 첫 접속시에는 서버로부터 첫 페이지를 구동하기 위한 청크를 가져가게되며 한번 접속한 페이지에 대해서는 데이터 청크가 있으므로 SPA와 같이 동작하게 된다.</p></blockquote><h3><span id="라우팅">라우팅</span></h3><p>라우팅은 기본설정으로 <code>pages/</code> 디렉토리가 루트가 된다. 기본 라우팅은 <code>index.html</code>에 매칭되는 <code>index.js</code>가 된다.</p><p>디렉토리 구조가 그대로 서비스 라우팅에 매칭되기 때문에 특별히 할 일이 없어서 빠른 속도로 개발을 시작할 수 있다.</p><p>그럼 html에 해당하는 template은 어디서 제어하는가?</p><h4><span id="pages_documentjs">pages/_document.js</span></h4><p><code>_document.js</code>는 <code>index.html</code>의 템플릿에 해당하는 정보를 내려주는 리엑트 컴포넌트로 시그니쳐가 <code>React.Component</code>의 상속이 아닌 <code>next/document</code> 패키지의 Document 컴포넌트를 상속해서 만들게 된다. 자세한건 문서를 참조한다.</p><h4><span id="pages_errorjs">pages/_error.js</span></h4><p>SSR이 지원되기때문에 데이터를 서버에서 미리 패칭하여 내릴 수 있다. 이런 경우를 포함해서 예외처리가 제대로 되지 않은 경우 <code>500</code>에러를 내리게 되는데 그에 대한 에러 <code>status</code>를 받아 그에 맞는 화면을 내릴 수 있다. <code>_document.js</code>와는 달리 <code>React.Component</code>를 상속한다.</p><h3><span id="api">api</span></h3><p>next.js에서는 리액트 컴포넌트를 내릴때 특수한 <code>static</code> 메서드를 정의할 수 있는데 이 함수는 서버와 클라이언트 모두에서 사용되며 서버일 경우와 클라이언트일 경우에 대한 분기를 여기서 정할 수 있다. 이를 통해서 서버인 경우에 대한 처리, 클라이언트에 대한 처리를 추가할 수 있다.</p><h4><span id="getinitialprops">getInitialProps()</span></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Index <span class="keyword">extends</span> React.Component&lt;<span class="literal">null</span>, <span class="literal">null</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> store: Store&lt;RSquareStore&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> getInitialProps(&#123;req&#125;) &#123;</span><br><span class="line">        <span class="keyword">const</span> server = !!req;</span><br><span class="line">        <span class="keyword">const</span> store  = <span class="keyword">await</span> storeCreator(reducer, <span class="literal">null</span>, server);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">await</span> store.dispatch(getCatalogue());</span><br><span class="line">        &#125; <span class="keyword">catch</span>(ex) &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> initialState = store.getState();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;initialState, server, catalogue: initialState.themes.catalogue&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.store = storeCreator(reducer, props.initialState, props.server);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Provider store=&#123;<span class="keyword">this</span>.store&#125;&gt;</span><br><span class="line">                &lt;Layout&gt;</span><br><span class="line">                    &lt;Head&gt;</span><br><span class="line">                        &lt;title&gt;&#123;<span class="string">`SEO_TEXT`</span>&#125;&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;/</span>Head&gt;</span><br><span class="line">                    &lt;Home catalogue=&#123;<span class="keyword">this</span>.props.catalogue&#125;/&gt;</span><br><span class="line">                &lt;<span class="regexp">/Layout&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Provider&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>단순한 구현은 위와 같다. 구조에는 redux가 쓰였으며 이를 위해 스토어를 생성해서 내리고 있는 걸 볼 수 있다. <code>&lt;Head&gt;</code>컴포넌트도 보이는데 <code>helmet</code> 역할로 헤더쪽으로 자식 태그들을 펌핑해준다. 동적으로 바껴야하는 메타태그들을 여기서 처리하면 된다.</p><h3><span id="pros">pros</span></h3><ul><li>라우팅이 정형화된 디렉토리 구조로 되어 있기 때문에 직관적이다.</li><li>API가 적다.</li><li>유니버설 렌더링의 지원한다.</li></ul><h3><span id="cons">cons</span></h3><ul><li>표준으로 자리잡았다 싶은 기존의 리액트용 라이브러리들과 함께 사용하려면 커스텀 셋업이 필요하다.</li></ul><p>###</p>]]></content>
    
    <summary type="html">
    
      react SSR 을 지원하는 next.js의 사용법을 간단히 소개한다.
    
    </summary>
    
      <category term="dev" scheme="http://blog.bglee.me/categories/dev/"/>
    
      <category term="js" scheme="http://blog.bglee.me/categories/dev/js/"/>
    
    
  </entry>
  
  <entry>
    <title>Texts 구현</title>
    <link href="http://blog.bglee.me/posts/2017/texts/"/>
    <id>http://blog.bglee.me/posts/2017/texts/</id>
    <published>2017-05-07T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.633Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="texts-구현"> 구현</span></h1><p><img src="https://lh3.googleusercontent.com/t_LQOLOXJ64l4zi05A_-By3QDDo7FIvWREe9meD6ZCuAUBlv8Y-DwyvzvShtR1v192sdYwfvgGG8e4S5pEsuAksPuyPj6MTBZBZvHvZIvMkyFH2j2I6_A4VIeZ3GOKyGigOg0dID1VQpXYTDkIDNJ_fFzjH39iPbM7p08KX1UWhOT02uU0yR0RK-3lH8obg57t9sohm4OUZVa-skdrOWh1U_qM_yKAiGhhkUIFBFAjCvdpmmiQIGk-zWX2MpVMHqkTDDbF9wyp87m2PbYegL5SuNTibFrYVTnRHfeCS8cA1uV7skajLXVK9cMuoKbSgyjMQAM3ZQ_kiaez78tvMz03tKKxtghcf4oyQHkHD3OIx15HdJad3W48oJxTBkyPO9DvR7r7dRVT4mGw70Tx1dZcYog6YeWPzXMCXl6SgO37QP3raxZMpkgbhWy5kzhbSmE-uIigUHUyiEo9gLhOwsVNwW1pzW9-LP4HDuwO7XGeVTep9SAaPCAIs4_SfiLwM3L0BoEPpxPPY7MBd-6FkofxblJsf_uset1CHbpT2xqUG2CHKO8Q79YJqgte5I34JK6mj42S89EDRO0lbg3VG769NRsbWuCLT4GWagjHJw5gpkdsvkC0xpszdilkBUprqzqy27ZbJti2I4VtBx53qlUOCDTKQdW_TN9NyH=w1139-h410-no" alt="" title="texts image"></p><blockquote><p>기획자 디자이너, 퍼블리셔와의 협업시 문구 변경으로 인한 피로를 덜기 위해 ID기반의 문구 관리를 앱</p></blockquote><h2><span id="동기">동기</span></h2><ul><li>부동산 계열에서 일을 하다보니 너무많은 term이 존재한다.</li><li>사소한 문구 변경이 데일리로 일어난다.</li><li>퍼블리셔 쪽에서도 html에 대한 이력관리를 원한다.</li><li>문구 변경과 markup의 변경이 구분되지 않는다.</li><li>react로 퍼블리싱하지 않는 이상 태그를 그대로 사용하지 못하므로 daily diff이슈가 존재한다.</li><li>여러 곳에서 동일하게 쓰이는 문구 변경이 일어난 경우 diff에 혼란이 있다.</li></ul><h2><span id="개발">개발</span></h2><blockquote><p>일단 퍼블리셔 쪽에서 <code>ID</code>를 사용하용하여 퍼블리싱 할 수 있게 끔 하는 것을 최우선으로 했다.</p></blockquote><ul><li>독립적으로 사용할 수 있도록 <a href="https://www.serverless.com" target="_blank" rel="noopener">serverless</a>를 통해 DB까지 한번에 deploy한다.</li><li>backend 엔드포인트만 사용자 별로 바꾸면 되니까 fe는 직접 만들어서 배포했다. <strong><a href="https://texts.surge.sh" target="_blank" rel="noopener">Texts</a></strong></li></ul><h2><span id="운영">운영</span></h2><h3><span id="기획스트링-관리-주체">기획(스트링 관리 주체)</span></h3><ul><li><a href="https://texts.surge.sh" target="_blank" rel="noopener">https://texts.surge.sh</a>?endpoint=https://[BACKEND_ENDPOINT] 접속</li><li>스트링 마음껏 만들고 잘 됬으면 deploy한다.</li></ul><h3><span id="퍼블리셔">퍼블리셔</span></h3><ul><li>퍼블리셔 쪽에서는 <code>&lt;div data-text-id=&quot;TEXT_ID&quot;/&gt;</code>와 같은 형식으로 퍼블리싱을 할 수 있게한다.</li><li>퍼블리셔는 눈으로 이를 확인할 수 있어야하므로 이를 치환해주는 태그를 서비스해준다. <strong><a href="https://texts-translator.surge.sh" title="texts" target="_blank" rel="noopener">Texts Translator</a></strong></li><li>퍼블리셔가 동적인 동작을 위해 <code>jQuery</code>태그를 심듯이 심어주면 동적으로 확인이 가능해준다.</li></ul><h3><span id="개발">개발</span></h3><ul><li>개발 버전에서는 퍼블리셔와 같이 태그를 심어서 스트링 관리주체가 변경하는 것을 즉각적으로 확인할 수 있게끔 한다.</li><li>프로덕션 릴리즈시에 아래 형식으로 저장해서 CI빌드시에 넣으면된다.</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ http post https://[END_POINT]/json &gt; language_ko.json</span><br></pre></td></tr></table></figure><h2><span id="todos">todos</span></h2><ul><li>퍼블리셔쪽에 구문 변경으로 인한 스트레스에서 벗어나고 싶지않냐고 설득한다.</li><li>기획자분이 스트링을 관리할 수 있도록 제안하고 설득한다.</li></ul><h2><span id="히스토리">히스토리</span></h2><ul><li>표준을 이용할 수 있게 끔 <code>Intl</code>을 붙이려고 디자이너쪽에서 태그를 어떻게 사용하게 해야할지 감이 오지 않아 뒤로 미뤘다.</li></ul><h2><span id="장점">장점</span></h2><ul><li>퍼블에서도 모델을 분리한다.</li><li>모델, 디자인, 컨트롤의 물리적인 관리주체(부서)가 명확해 진다.</li></ul><h2><span id="단점">단점</span></h2><ul><li>서비스가 아니라 aws 설치 형태라 결국 나만의…</li></ul>]]></content>
    
    <summary type="html">
    
      기획자 디자이너, 퍼블리셔와의 협업시 문구 변경으로 인한 피로를 덜기 위해 ID 기반의 문구 관리
    
    </summary>
    
      <category term="dev" scheme="http://blog.bglee.me/categories/dev/"/>
    
      <category term="js" scheme="http://blog.bglee.me/categories/dev/js/"/>
    
    
  </entry>
  
  <entry>
    <title>yarn</title>
    <link href="http://blog.bglee.me/posts/2016/yarn/"/>
    <id>http://blog.bglee.me/posts/2016/yarn/</id>
    <published>2016-12-11T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.634Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://yarnpkg.com/assets/feature-speed.png" alt=""></p><p><code>yarn</code>은 동시 다운로드를 지원하는 <code>npm</code>이라고 보면된다. 디펜던시 트리를 저장하고 있어서 빠르게 인스톨을 하므로 CI등에서 위력을 발휘한다.<br>기본 지식은 <a href="https://yarnpkg.com/en/docs/cli/info" target="_blank" rel="noopener">문서</a>를 참고하면 된다.</p><blockquote><p><code>yarn global add [package]</code> 커맨드를 통해 인스톨을 한 경우 <code>npm</code>과 달리 실행이 안되는 문제가 있다.</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; yarn global add typescript</span><br><span class="line">yarn global v0.17.8</span><br><span class="line">warning No license field</span><br><span class="line">[1/4] 🔍  Resolving packages...</span><br><span class="line">[2/4] 🚚  Fetching packages...</span><br><span class="line">[3/4] 🔗  Linking dependencies...</span><br><span class="line">[4/4] 📃  Building fresh packages...</span><br><span class="line">success Installed typescript@2.1.4 with binaries:</span><br><span class="line">      - tsc</span><br><span class="line">      - tsserver</span><br><span class="line">warning No license field</span><br><span class="line">✨  Done <span class="keyword">in</span> 1.56s.</span><br><span class="line"></span><br><span class="line">&gt; tsc</span><br><span class="line">zsh: <span class="built_in">command</span> not found: tsc</span><br></pre></td></tr></table></figure><p><code>bash</code> 를 이용하고 있다면 될 수도 있을 것 같은데 필자와 같이 <code>zsh</code>를 사용하고 있다면 아래와 같이 한줄을 추가해자.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"export PATH=\$PATH:`yarn global bin`"</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><p>이후 실행</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; tsc -v</span><br><span class="line">Version 2.1.4</span><br></pre></td></tr></table></figure><p><code>npm</code>을 통해서도 인스톨을 했다라면 패스 문제로 버전 문제가 생길 수 있으니 둘중 하나만 사용하자.</p><hr><p>2016-12-26 추가</p><p><code>brew</code>를 통해 <code>yarn</code>을 설치한 경우 위 방법으로는 <code>yarn global add [package]</code>로 추가한 모듈이 동작을 안한다. <code>npm global</code>, <code>yarn global</code>, <code>brew</code>가 꼬여서 생기는 문제일 것 같은데 일단 해결책은 <code>brew</code>를 통해서 설치했다면 다시 아래를 추가로 입력해주면 된다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"export PATH="</span><span class="variable">$PATH</span>:<span class="variable">$HOME</span>/.config/yarn/global/node_modules/.bin<span class="string">"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      facebook 에서 만든 `NPM` 의 래퍼 `yarn`에 대해서 설명한다. `yarn`을 소개한다.
    
    </summary>
    
      <category term="setup" scheme="http://blog.bglee.me/categories/setup/"/>
    
      <category term="js" scheme="http://blog.bglee.me/categories/setup/js/"/>
    
    
      <category term="npm" scheme="http://blog.bglee.me/tags/npm/"/>
    
      <category term="yarn" scheme="http://blog.bglee.me/tags/yarn/"/>
    
  </entry>
  
  <entry>
    <title>W3C HTML5 Conference 2016</title>
    <link href="http://blog.bglee.me/posts/2016/w3c-html5-conference-2016/"/>
    <id>http://blog.bglee.me/posts/2016/w3c-html5-conference-2016/</id>
    <published>2016-12-07T12:10:13.000Z</published>
    <updated>2018-07-16T06:10:14.940Z</updated>
    
    <content type="html"><![CDATA[<p>개인 정리</p><hr><p><img src="https://lh3.googleusercontent.com/SQ9w6ZjKzT0NjWcpBNb6EH1j-EJUA762WiyhVjVXvrqusDFXsuNSs3R0Oz_T6JTpvOxqREQ2IyqwGQ3f-gc6wS_O9D98AO7woVzCxVEfOJcpG1abOk7FcweH0HtVh3ZJcRc-BqT9gZR3DW60kAqhdgWXWMzk8FJZfsxI32tLKGooxSTyz5BDmZT8YhrybZ77b3q5TgCrdCw4hOFkEU5tbXD8OMvo0ZLkqDn4gvpEq04-9mSgHOX7dAX8jKZ9M2BmSuBQtN_Zog2gmoXpKiVhtH4zExqOr_Eldb2pOTJslGJo0PFi_oEEK8u0mW3AYAvog91NzdH71YmZZfHh9UOYivxbiHvss-GIoAPohSyHm8fmSdFl6AEw-qw5WPZ7YnjGpN8Ll_-IUcAhd4-cEPBzQ-9E3XgfGPeGH3qWajuuYt1Q6BVfNTX_D7UOWveOVIV4VWuCxufGi2NCGlL5M_ZVqt7ZVSrQZX0jFgWVA_qY8FE4BPZPcB5dI_eRp8FuAQq8mYJxYV0Uk8wHf50N23zeMWTJPibNniMKyecbyXU3rktm1yG92drvTdiyBaY7gc0pdv_v5aRc7gUemueFlK8FsBVlwfBIdgW-moDUrBFrGlnXFjI3gjJsJ-lPgKVVkhTPGqoQTWB5h-ija2wqpACnSBGsCD2gqiYPmt2lX4f2SUg=w895-h672-no" alt=""></p><h2><span id="키노트-1박종목">키노트 1(박종목)</span></h2><h3><span id="웹의-발전">웹의 발전</span></h3><ul><li>스태틱 웹</li><li>웹 2.0(ajax) - symbolic boom</li><li>read, write web(muchine to muchine), 스맨틱 웹(figure, article, header tag), 웹 3.0</li></ul><h3><span id="네이버의-인공지능-사례들">네이버의 인공지능 사례들</span></h3><ul><li>페이지랭킹은 오래됬고 머신러닝으로 랭킹 먹인다.</li><li>지식 쇼핑 40억개 상품, 4000카테고리가 있어서 딥러닝을 통해 자동분류한다.</li><li>위치 기반 검색 지역의 특성등을 인공지능으로 추출한다.<ul><li>전주 한옥마을에 대한 블로그 데이터의 자연어를 분석해서 전주 한옥마을에 대한 특성들을 분석함(크롤링과는 좀 다름)<ul><li>Context-aware analysis based on charateristics of loacation</li><li>해시 태그화 등</li></ul></li></ul></li><li>이미지 검색시의 정렬등</li><li>상품검색의 스타일 서치(유사 상품) topic model을 추출한다.</li><li>인식기술이 많이 발전함<ul><li>머신러닝을 하면서 인식률이 85% =&gt; 95%로 증대</li></ul></li><li>음석 합성도 지원함(사전, 뉴스 읽기, 라인 사전)</li><li>기계번역(통계기반 번역) =&gt; 머신러닝(뉴런) 투입하면서 번역률이 2배정도됌</li><li>amica.ai, 12초 whale browser는 파파고 엔진으로 웹페이지 번역 지원됨</li></ul><p>사용자와의 인터렉션은 음성기반으로 바뀔꺼다.(시리 등등)<br>챗봇(사용자들은 메시징하는데 더 많은 시간을 쓴다(웹은 20%정도)) - 페이스북<br>자율주행(아직은 연관성 별로 없음)<br>스마트 홈(IoT)<br>로봇</p><h3><span id="관련된-웹-표준">관련된 웹 표준</span></h3><ul><li>Voice XML</li><li>시맨틱 웹(3.0에서 실패했던 것이 지금)</li></ul><h3><span id="이에-대한-안좋은-시각생각">이에 대한 안좋은 시각(생각)</span></h3><ul><li>웹표준이 아닌, 애플, 구글, 페이스북등이 사실상 리딩</li><li>산업에 변화에 비해 웹 표준은 느리다는게 걸림</li><li>태생이 다큐먼트 컨셉</li></ul><h3><span id="web의-next">Web의 Next?</span></h3><ul><li>IoT</li></ul><h2><span id="키노트-2김국현">키노트 2(김국현)</span></h2><p>IT 세대론…</p><p>코볼은 | C, C++에<br>Java(자바는 코볼을 품음) | JS<br>에 막히고 3세대로 가고 있다.</p><p>특이사항 없음</p><p>@goodhyun</p><h2><span id="패널토의">패널토의</span></h2><p>웹이 다큐먼트인가? 거의 UI로 사용된다. 그러면 모델이 다큐먼트인게 맞는가<br>1조개의 센서, 세금을 블록체인으로 걷는다.<br>서로 다른얘기 함.. 여튼 지금 혁명중</p><p>Q: 네이버 브라우저 왜 만드셨어요?</p><p>A: 사용성이 안좋다. 선두업계 주자라 인터넷 환경 자체를 개선하겠다.</p><p>Q: 삼성도 MS따라서 오픈소스하나?</p><p>A: 변명함, artik이라는 보드도 오픈소스로 내놓음 ecma준수하는 jscript 만듬(40k정도)</p><p>Q: 웹이 성숙된 표준을 가지고 잘 따라고 있는가?</p><p>A: 웹 !== 웹브라우저, 칩에도 js call이 들어간다. 쉐이딩 영역도 js가 먹을꺼같다. iot도 먹고있다. 웹을 구성하는 기술들로 간다.</p><p>Q: JS로 IoT하는데 이게 웹인가?</p><p>A:</p><ul><li>웹이라고 하는듯 의견이 갈림</li><li>스펙은 잘 따라가지 못하기 때문에 프레임웍에서 많은 일들을 해야하며 리액트를 디펙토로 가던지 등등 맞다고 생각되는 것을 밀어야한다.</li><li>웹의 기본 철학은 탐험과 연결이다.</li></ul><p>Q: 4차 산업 혁명 준비 예산은? 내년</p><p>A: 주용환</p><ul><li>40억 규모: 엑티브엑스 개선, 웹 표준 확산</li><li>기업지원은 웹이 새롭게 쓰이는 서비스에 지원하려함 올해 2억 수준이었는데 10억 이상 수준으로 편성하려함, VR등 국내사례가 별로 없음.</li><li>빅테이터, 인공지능 이쪽이 지원 받을게 많다.</li></ul><p>Q: 뉴런번역 API 제공 계획 없나</p><p>A: 모른다 ㅠㅠ</p><hr><h2><span id="트랙-b">트랙 B</span></h2><h3><span id="second-screen-amp-webrtc">Second Screen &amp; WebRTC</span></h3><h4><span id="webrct-표준-현재와-미래">WebRCT 표준 현재와 미래</span></h4><p>최진호 - REMOTE MONSTER</p><p>페이스 챗 카카오톡 슬랙, 아마존 등등에서 다 사용이나 아직 Draft단계이며 5년정도밖에 되지 않는다.</p><p>전화기 오픈소스라고 생각하면 이해하기 빠르며 표준화를 진행중이다.(구글이)<br>P2P지만 서버(시그널 서버)는 필요하다.<br>토폴로지 구성 및 브로드캐스팅이 가능</p><p>API</p><ul><li>getUserMedia</li><li>RTCPeerConnection</li><li>RTCDataChannel</li></ul><p>표준화된 프레임웍이 없다.<br>네트워크 및 안드로이드 파편화에 따라 성능차이가 많이 난다.<br>UDP를 사용</p><p>그럼에도 불구하고</p><ul><li>커뮤니티가 강하다. <a href="https://www.facebook.com/groups/rtc.korea" target="_blank" rel="noopener">https://www.facebook.com/groups/rtc.korea</a></li><li>WebRTC PaaS도 존재한다.</li><li>1200+ 서비스, 브라우저들이 지원함, 3.1조억+ 기업 인수, 투자 규모</li><li>엔지니어 구하기가 힘들어서 인수할 정도로 귀족 개발자</li><li>17년 1Q Recommandation 예정</li><li>엣지도 지원, 애플도 지원 예정 (H.264)</li><li>크롬 55에 RTC관련 업데이트가 대거</li><li>용량이 크기때문에 IoT에 대응하기에는 쉽지않지만 빌드 잘하면된다..</li><li>AR, VR에 유용할 것으로 예상된다.</li><li>Google Duo = WebRTC + QUIC 빠른 서비스.</li><li>통신, 방송, IoT분야에서 활약할 것으로 기대된다.</li></ul><h4><span id="webrct-서비스-개발사례와-시사점">WebRCT 서비스 개발사례와 시사점</span></h4><p>이랑혁 - 구루미</p><p>HLS보다 딜레이가 적다. RTSP, RTMP, HLS 가능<br>일반전화 연결이 가능하다(?)</p><p>협업 &gt; 교육 &gt; 상담(의료) &gt; 관제 등 순으로 비지니스 니즈가 있었음</p><p>WinXP, IE 이슈 해결</p><ul><li>일렉트론</li><li>세계적으론 20%대이니 기다려라(국내는 70%이상)</li><li>아니면 앱 만들어서 배포해라</li></ul><p>기회</p><ul><li>크롬 기반 브라우저 확산(웨일 브라우저)</li><li>에코 확장<ul><li>대기업의 신규 서비스</li><li>교육 및 의료 부문 전환중(정부 3.0)</li></ul></li><li>ActiveX 제거</li></ul><h4><span id="second-screen과-웹-커넥티비티">Second Screen과 웹 커넥티비티</span></h4><p>송효진 - LG전자</p><p>다른 기기로 화면이나 앱을 보내서 실행하는 것</p><p>커넥티비티</p><ul><li>네트워크를 통해 떨어진 두 지점을 연결</li></ul><p>ECMA<br>W3C<br>IETF(L3)<br>IEEE(L2)</p><p>IETF</p><ul><li>HTTP/2(One TCP Connection)</li><li>QUIC(based on UDP)</li><li>IPv6</li><li>IPv6 over Bluetooth/NFC(IOT 기반으로 이터넷이아닌디바이스에서 가능)</li></ul><p>Application</p><ul><li>W3C Presentation API</li><li>W3C Remote Playback API</li></ul><p>Underlying Protocol</p><ul><li>SSDP, mDLS</li></ul><p>기대</p><ul><li>교육 분야</li><li>전광판(QR 대체)</li></ul><p>FlyWeb Project</p><p>웹페이지가 서버를 구동하고 디바이스가 여기에 접속 가능</p><h3><span id="웹고속화">웹고속화</span></h3><h4><span id="ampaccelerated-mobile-pages는-어떻게-빠른-성능을-내는가">AMP(Accelerated Mobile Pages)는 어떻게 빠른 성능을 내는가?</span></h4><p>김태훈 - 네이버 <a href="http://facebook.com/groups/webfrontend" target="_blank" rel="noopener">http://facebook.com/groups/webfrontend</a></p><ul><li>구글 라이브러리다. amp.js 다른거 할필요없이 가이드를 따르면 된다.</li><li>인스턴스 로딩이 가능하다.</li><li>커스텀 엘리먼트 기반이다.</li><li>url + #development=1 를 사용하면 에러 뿜어준다.</li><li>amp.js는 외부 js를 허용하지 않는다.</li><li>AMP Cache - 구글이 CDN 으로 다 뿌려준다.</li><li>HTML &lt;=&gt; AMP-HTML 페어로 구성 또는 AMP-HTML 온리</li><li>슬랙등에 링크걸면 AMP로딩해준다.</li><li>amp 컴포넌트를 사용해서 리소스를 로딩하게되면 뷰포트에 보이는 시점에 레이지로딩한다.</li><li>크로스 브라우징 해결해준다.</li><li>속도는 엄청 좋다는 말로 부족하다.</li><li>https만 가능하다(video)</li><li>커스텀 js를 사용하지 못하는 치명적인 단점이있어서 이벤트 페이지 같은 경우에 적합할 것으로 보임.</li></ul><p>특징</p><ul><li>비동기 스크립트만 로딩 허용</li><li>모든 리소스의 사이즈 지정</li><li>확장 컴포넌트들이 렌더링 차단 없이 실행한다.</li><li>써드 파티 자바스크립트 크리티컬 패스에서 제거</li><li>?(CSS관련)</li><li>웹폰트 효율적으로 허용</li><li>GPU 가속 애니메이션으로만 제한됨(레이아웃 변경 CSS는 막힌다)<strong>(css triggers 참조)</strong></li><li>리소스 로딩 순서 제어(뷰포트에 의해)</li><li>페이지 즉시 로드</li><li>리플로우 최적화</li><li>스타일 변경 작업을 배치작업을 통해서 최적화한다(코드 붙여서 작성하면됌)</li></ul><p>6억+ 페이지가 700k+ 사이트가 작성되었다.</p><p>커스텀 엘리먼트를 사용해서 라이프 사이클을 제어한다(이를 통해 뷰포트안에 있을때만 로딩등 처리)</p><h4><span id="프로그레시브-웹앱pwa">프로그레시브 웹앱(PWA)</span></h4><p>송정기 - 삼성전자</p><p>모바일 웹사이트</p><p>장점</p><ul><li>URL, 연결성, 빠른 배포(URL &gt; store)</li><li>표준 기반 다양한, 폭넓은 기기 지원</li></ul><p>단점</p><ul><li>Native 대비 떨어지는 UX</li><li>성능</li><li>기능</li></ul><hr><p>Manifest + Service Worker + Push</p><hr><p><a href="https://whatwebcando.today" target="_blank" rel="noopener">https://whatwebcando.today</a></p><p>PWA - 홈스크린 인스톨레이션, 오프라인 모드, 푸시 메시지</p><ul><li>머무는 시간이 3배 증가</li><li>40% 더 재접속</li><li>70% 홈스크린을 통해 들어오는 유저가 구매할 확률이 더 높다</li><li>3X 데이터를 덜 사용한다</li></ul><p>PWA List 앱 참조</p><p>PWA를 구성하는 표준 기술</p><h5><span id="web-app-manifest">Web App Manifest</span></h5><p>네이티브와 동일한 앱 접근성을 제공한다. 크롬, 오페라, 삼성 브라우저, 사파리<br>메니페스트가 추가됏을때는 브라우저에서 탭했을때 메뉴가 다르게 뜬다.<br>홈화면에 인스톨레이션을 지원하는 로직은 아직 사파리가 지원하지 않는다. 인스톨레이션 팝업은 브라우저별 휴리스틱 알고리즘을 통해 제공된다.</p><p><a href="http://pwa.rocks" target="_blank" rel="noopener">http://pwa.rocks</a></p><p>PWA indication의 조건</p><ul><li>https://</li><li>Service worker</li><li>WebApp Manifest</li></ul><p><code>theme_color</code>를 통해 상태바 색도 바꿀 수 있다.<br><code>display</code>를 통해 풀사이즈 앱으로 띄울 수 있다.</p><p>Splash screen - 크롬이 들고나오고 삼성 인터넷도 탑재 예정, 로딩 전 앱 로딩 화면처럼 만들어준다.</p><h5><span id="service-worker">Service Worker</span></h5><p>오프라인 우선, 백그라운드 처리</p><p>이벤트마다 워커가 종료된다. 웹 워커와는 다르다. 실 브라우저 구현(크로미움 기준) 2-30초는 살아있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> navigator.serviceWorker;</span><br><span class="line">sw.register(scriptURL, &#123;<span class="attr">scope</span>: scopeURL&#125;);</span><br><span class="line">;;</span><br><span class="line">oninstall = <span class="function"><span class="params">e</span> =&gt;</span> &#123; <span class="comment">/* pre-cache here */</span> &#125;;</span><br><span class="line">onfetch = <span class="function"><span class="params">e</span> =&gt;</span> &#123; <span class="comment">/* respond with magic */</span> &#125;;</span><br><span class="line">onactivate = <span class="function"><span class="params">e</span> =&gt;</span> &#123; <span class="comment">/* Deleting cache is on you * &#125;; // 서비스 워커 버전이 변경됐을때</span></span><br><span class="line"><span class="comment">registration.update(); // 강제 업데이트</span></span><br></pre></td></tr></table></figure><p>SW의 이벤트가 가지고 있는 <code>watUntil</code> 메서드를 통해 SW가 죽는 것을 방지할 수 있다.<br>캐시에 애드하는 형식 캐시에 매칭되지 않으면 거기서 <code>fetch</code>한다.</p><p>Service Worekr Cookbook 찾아볼 것 <a href="https://jakearchibald.com" target="_blank" rel="noopener">https://jakearchibald.com</a></p><h5><span id="push-api">Push API</span></h5><p>푸시의 효과는 검증됨.</p><p>필수요소</p><ul><li>Background Service <strong>(Service Worker)</strong></li><li>Push 등록/해지/이벤트 <strong>(Push API)</strong></li></ul><p><code>push</code>이벤트를 받아서 캐싱에 저장하고 노티피케이션을 띄움 띄운 후에는 클릭 이벤트를 받아 그에 따른 처리.</p><p><a href="https://medium.com/samsung-internet-dev" target="_blank" rel="noopener">https://medium.com/samsung-internet-dev</a></p><p>삼성 인터넷 베타 프로그램 신청 <a href="https://goo.gl/1yFP1L" target="_blank" rel="noopener">https://goo.gl/1yFP1L</a></p><h3><span id="web-엔진">Web 엔진</span></h3><h4><span id="naver-webkit-sling-project-소개-및-오픈소스">Naver Webkit - Sling Project 소개 및 오픈소스</span></h4><p>김준걸 - 네이버 랩스</p><ul><li>슬링 4년 6개월 작업했고 오늘 깃헙에 오픈했다.</li><li>애플의 웹킷에서 fork</li><li>win/android 지원</li><li>JS엔진 - JSC vs V8(과할 수록 유리 V8, 실사용에선 JSC, 슬링은 JSC)</li><li>리소스가 부족해서 안드로이드로 개발 =&gt; 스크립팅 =&gt; C++ 소스 제네레이팅(android pp, github 참조)</li><li>크로미움 네트워크 성능이 뛰어남</li><li>GFX Tool for Sling 이라는 디버깅 툴 만들어서 그걸로 선검증 후포팅</li><li>WebExtensions API가 400개 정도 되서 아직 다 지원은 못함</li><li></li></ul><h4><span id="chrome-dev-summit-2016-참관기">Chrome Dev Summit 2016 참관기</span></h4><p>김지한 - 네이버 랩스</p><ul><li>PWA 포커싱</li><li>AMP to PWA</li><li>매 단계마다 20%의 사용자가 떨어져나간다.(설치나, 가입 등등 모두)</li><li>3G 기준으로 5초 이내에 인터렉션이 가능해야한다.</li><li>홈 화면에 추가된 사이트는 4배 더 많이 방문한다(알리바바, 2016)</li></ul><p>PRPL pattern - Push, render, Pre-cache, Lazy-load</p><p><code>&lt;link rel=&quot;preload&quot;/&gt;</code></p><p>크롬 51+, 오페라 41+, 안드로이드 5+</p><p><a href="https://www.flipkart.com" target="_blank" rel="noopener">https://www.flipkart.com</a> PWA의 정석<br><a href="https://www.housing.com" target="_blank" rel="noopener">https://www.housing.com</a> 부동산 체크</p><h5><span id="crediential-api">Crediential API</span></h5><p><code>navigator.credentials</code> 인증을 브라우저에 던진다.</p><h5><span id="web-payment-api">Web Payment API</span></h5><p>브라우저에 결재 던짐</p><h5><span id="debugging-the-web">Debugging the Web</span></h5><ul><li>크롬개발자도구</li><li>Lighthouse 익스텐션(PWA)</li></ul><h5><span id="결론">결론</span></h5><ul><li>PWA의 핵심 - 오프라인 지원, 로딩 성능 향상</li><li>Lyft등 선행 사업자들도 이머징 마켓 중심으로 적용 중</li><li>로그인, 결재 등이 브라우저로 이동(크롬, 안드로이드), 이에 대한 강력한 지원</li></ul><h4><span id="html5기반-웹앱-그리고-다가올-http-2">HTML5기반 웹앱 그리고 다가올 HTTP / 2</span></h4><p>커넥션 제약으로 이미지 등을 로딩할때</p><ul><li>image sprite</li><li>local cache<code>&lt;link rel=&quot;prefetch&quot; href=&quot;image.png&quot;/&gt;</code></li><li>domain lookup, <code>x-dns-prefetch-control</code>, <code>preconnect</code></li><li>minify</li><li><code>prerender</code></li><li><code>preresolve</code></li><li>google에서 instant page 검색</li></ul><h5><span id="http2">HTTP2</span></h5><ul><li>바이너리 기반 프로토콜</li><li>헤더 압축</li><li>멀티플렉스 스트림(프로세스, 쓰레드 같은 개념)</li><li>스트림 프라이어티티(리소스 의존성 지정가능)</li><li>서버 푸쉬</li></ul><p>1.1 에선 핑퐁 치던걸 2에선 한방에 내림</p><p>APM<a href="https://ampproject.org" target="_blank" rel="noopener">https://ampproject.org</a> + PWA</p><p>포커싱이 HTTP2가 아니라 아쉬움</p>]]></content>
    
    <summary type="html">
    
      W3C HTML 5 컨퍼런스 2016 요약
    
    </summary>
    
      <category term="summary" scheme="http://blog.bglee.me/categories/summary/"/>
    
    
      <category term="pwa" scheme="http://blog.bglee.me/tags/pwa/"/>
    
      <category term="amp" scheme="http://blog.bglee.me/tags/amp/"/>
    
  </entry>
  
  <entry>
    <title>2016년 12월</title>
    <link href="http://blog.bglee.me/posts/2016/2016-12/"/>
    <id>http://blog.bglee.me/posts/2016/2016-12/</id>
    <published>2016-12-04T10:58:37.000Z</published>
    <updated>2018-03-29T06:03:19.620Z</updated>
    
    <content type="html"><![CDATA[<p>벌써 12월이다. 미션들이 여러개가 떨어져서 이래저래 공부와 삽질을 하면서 11월 한달을 보냈다. 한달에 한번 포스팅할 시간도 없어서 정리를 하고간다.</p><h2><span id="독서">독서</span></h2><ul><li>클로저 시작하기 - 기본 개념과 7주 훈련 프로그램</li><li>빠른 모바일 앱 개발을 위한 React Native</li><li>디스커버리 Go</li></ul><p>예전에는 정독을 목표로 책을 펴고 <strong>서문</strong>부터 읽어나갔었는데 출퇴근 시간을 아껴서 공부하다보니 실무에 쓰일 수 있는 부분을 먼저 읽기위해 <strong>목차</strong>를 읽고 고급 내용을 다루는 뒷 부분을 나중에 읽게 되었다.</p><p>11월 중순 부로 서버까지 커버해야하는 상황이 오면서 회사에서 쓰이는 언어인 클로저(이전에도 한번 읽긴 했었다.)와 <strong>Go</strong>를 공부해야하는 상황인데 기존에 인계 받은 것 중에는 <strong>루비 온 레일즈</strong>도 존재한다.</p><h2><span id="블로그">블로그</span></h2><p>서브 도메인을 구현했다. 이제까지 블로그가 집에서 굴리는 작은 서버를 통해 서비스되고 있었는데 이를 나스로 옮겨 잘 사용하고 있었는데 조카들이 와서 전원을 뽑아 놓는 바람에 이틀 정도 서비스가 중단되는 것을 계기로 깃헙 페이지를 통해 서비스를 제공하면서 도메인도 <strong><a href="http://blog.bglee.me">http://blog.bglee.me</a></strong>로 옮겼다.</p><h2><span id="next">Next</span></h2><p>공부에 치이는 상황에서 주어진 시간을 최대한 활용하고 추후의 빠른 개발 및 데브옵스를 위해서 기존 API 서버의 <strong>GraphQL</strong> 프록시를 도전하기도 했고 앱에 대한 니즈 또한 존재해 리액트 네이티브를 공부했다. 시간이 얼마 없기 때문에 <strong>GraphQL</strong>은 드랍했고 메인 프로젝트의 일정을 맞추기 위해 주니어들과 함께 다시 <strong>FrontEnd</strong> 코드를 작성중에 있다.</p><p>웹 서빙을 위해 EC2, ECS, S3 static hosting 여러가지를 해왔는데 각각의 장단점이 있고 Serverless 스택 또한 러닝커브가 있지만 한번 구현이 완료되면 안정성과 비용 절감이 이루어지는 만큼 이 부분이 다음 타겟이 될 것 같다. 첫 시도는 주어진 시간의 한계로 친구에게 맡긴 상황인데 이 부분이 잘 해결되었으면 한다.<br>ㅏ</p>]]></content>
    
    <summary type="html">
    
      벌써 12월이다. 미션들이 여러개가 떨어져서 이래저래 공부와 삽질을 하면서 11월 한달을 보냈다. 한달에 한번 포스팅할 시간도 없어서 정리를 하고간다.
    
    </summary>
    
      <category term="summary" scheme="http://blog.bglee.me/categories/summary/"/>
    
    
  </entry>
  
  <entry>
    <title>AWS EC2 Container Service(ECS)를 통한 배포</title>
    <link href="http://blog.bglee.me/posts/2016/aws-ec2-container/"/>
    <id>http://blog.bglee.me/posts/2016/aws-ec2-container/</id>
    <published>2016-11-05T06:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>ecs</code> 는 현재 서울 리전에서는 지원되고 있지 않다. 글을 쓰다가 개인 업무가 있어서 끊어 쓰다보니 매끄럽지가 않은데 질문사항이나 잘못된 점이 있으면 피드백 주세요.</p></blockquote><p><img src="https://lh3.googleusercontent.com/KLmTMdEkWSEkTDl9l8oe840Cxd8Siu4MG4qJJ9Z6emVjRhsH3_uC9WPhstkLq_q5qoRiFv20Ws_VSx7c0bsO1FfG8lfV8OSDEcQWHCLf4ZB5aOtRai4BmLmDJPEA1hVadtsyBVxJRzomTv-J-svCzFpyX1_jBwSdmi_FUCj31iJKNM0WsZc4nxkBHYz_2oBD2vbCa-HzAhcsDwgt61VzKRTyQHH0W9_ygKllbofMhHa6_x4hTwkmVW_MgGunvS2EULiJfnscxlW-QveQ9EGGWjx__xHBk_QhXYdbbPhf5U4rZw3nkejvTa12BfgnsvB9ROWvL3nFCO_NtKoAabNCVJ5cpZrHokxy7Aul02nTHcyXIjRpwuEaZd4Us3rQ2y_rL5sWEtE70FQCBmM_iYwfKTsTdPg_fkQkGO4nj5Idbe-RcCQ0oOsGcw1f67VTwsowi-S9T999WFdSSHsg3Y1jwrZ1JLnHkTZWwwRO0QEAjLAW1g3NsH3DPKuH6qdG3i269fauB-rsdqsqoB4s7VKaTN-JcuqRdqwuZAcBG1zYimIhFdVe7Qvobn8mwDbTo-InwPUM_qSClu6SRTYnTgGMDyhmsijwYHmePk1q8M5RM7RZlBLW5w=s803-no" alt=""></p><h2><span id="개요">개요</span></h2><p><code>aws console</code> 을 통해 <code>EC2 Container Service</code>(ecs) 에 진입하면 3개의 메뉴가 보인다.</p><ul><li>Cluster</li><li>Task Definitions</li><li>Repositories</li></ul><blockquote><p>Cluster</p></blockquote><p>하드웨어 클러스터를 의미한다. EC2의 모임이라고 생각하면 편하다.</p><blockquote><p>Task Definitions</p></blockquote><p>이 곳에서 Docker 파일을 통해 <code>task</code> 를 정의한다. 정의한 <code>task</code>를 <code>cluster</code>에 할당하여 동작시킨다고 생각하면된다. <code>task</code> 에서는 <code>메모리를 얼마나 사용할 것인가?</code> 등의 <code>docker</code> 설정을 포함한다.</p><blockquote><p>Repository</p></blockquote><p><code>aws</code> 에서 사용할 수 있는 <code>docker hub</code> 라고 이해하면 빠르다. 이 곳에 빌드된 <code>docker image</code> 를 올린다.</p><h2><span id="실제-구성">실제 구성</span></h2><h3><span id="저장소-구성-및-업로드">저장소 구성 및 업로드</span></h3><h5><span id="docker-image-build">docker image build</span></h5><p>먼저 어플리케이션을 구현하고 <code>Dockerfile</code>을 통해 이미지로 빌드한다(빌드 과정은 이 포스트의 영역을 넘어간다).</p><h5><span id="docker-저장소-생성">docker 저장소 생성</span></h5><p>빌드 된 이미지를 <code>ecs repository</code> 에 업로드하기 위해서 <code>ecs</code> 서비스의 <code>repository</code> 에 진입하여 <code>Create repository</code> 버튼으로 저장소를 생성한다.</p><h5><span id="docker-image-upload">docker image upload</span></h5><p>친절하게 <code>ecs</code>에서 <code>repository</code> 를 선택하면 <code>View Push Commands</code> 라는 버튼을 통해 업로드 방법을 볼 수 있다. <code>login</code>, <code>build</code>, <code>tag</code>, <code>push(upload)</code> 순으로 명령어가 적혀있는데 저장소 url, region을 자신에 맞게 수정하고 올리면된다.</p><h3><span id="task-definitions">task definitions</span></h3><h5><span id="task-생성">task 생성</span></h5><p><code>Task Definitions</code> 메뉴에서 <code>Create a Task Definition</code> 버튼을 눌러 생성한다. <code>Container Definitions</code> 에서 <code>Add container</code> 버튼을 통해 컨테이너를 등록해야하는데, <code>image</code> 에서는 프로토콜(<code>http://</code>)을 제외한 이미지 경로를 넣어준다.</p><p>메모리의 경우는 <code>task</code> 가 실행될 실제 컨테이너의 메모리 안에서 설정하면된다. 실제 사용하는 메모리보다 적게 잡을 경우 속도저하, <strong>응답없음</strong> 등을 경험할 수 있다. 실제로 PDF를 생성하는 서버를 구현했다가 랜더링 할 메모리가 모자라 응답없음을 경험했었다.</p><p>추가적으로 포트 매핑, CPU unit 등을 설정해준다.</p><h3><span id="cluster-에-배포">cluster 에 배포</span></h3><h5><span id="cluster-생성">cluster 생성</span></h5><h5><span id="service-생성">service 생성</span></h5><p>클러스터를 생성하고 나서 클러스터에 제공할 서비스를 생성한다. 여기서는 위에서 정의한 <code>task</code> 와 이를 서비스할 <code>cluster</code> 를 지정하고 몇개의 <code>task</code>를 돌릴 것인지 등을 셋업한다. 추가적으로 <code>ELB</code>, <code>auto scaling</code>등도 셋업을 한다.</p><p><strong>ELB</strong> 최근에 <strong>Application Load Balandcer</strong> 가 추가 되면서 기본설값이 되어 있다. 기존에 쓰이던 ELB는 <strong>Classic Load Balancer</strong> 니 참고 바란다.</p><hr><p>여기 까지는 그냥 따라오면 되는데 중요한 문제가 있다. <strong>cluster</strong> 에 등록된 컨테이너 인스턴스가 없다. 이제 이를 세팅해야한다. cluster에 ec2 instance를 등록하기 위해서는 <code>ecs agent</code>가 설치된 이미지가 로드되야한다. 이건 유저가 스스로 설치할 수도 있지만 기본적으로 아마존에서 제공하는 이미지가 있다.</p><p>테스트를 위해 <strong>ec2 instance</strong> 를 생성한다. <strong>AMI</strong>는 <strong>Amazon ECS-Optimized Amazon Linux AMI</strong> 를 이용한다.</p><p><strong>auto scaling group</strong>, <strong>launch configuration</strong> 을 통해 서비스를 하는게 정석이다.</p><p>여기서 <strong>user data</strong> 를 설정해서 인스턴스가 ecs에 접속해서 클러스터에 등록을 할 수 있도록 설정해 줘야한다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> ECS_CLUSTER=CLUSTER_NAME &gt;&gt; /etc/ecs/ecs.config</span><br></pre></td></tr></table></figure><p>user 데이터의 내용은 위와 같다.</p><p>여기서 <strong>CLUSTER_NAME</strong> 부분을 통해 인스턴스가 로딩되면서 ecs agent가 실행되게되고 여기서 ecs 에 접속하여 cluster에 등록되게 된다.</p><hr><h3><span id="update-revision">update revision</span></h3><p>docker image가 업데이트 되어 재 배포가 필요한 경우에는 task의 new revision을 선택하고 container를 눌러서 한번 업데이트를 누른다(현재 컨테이너가 같은 docker이름을 참조하더라도 재 참조를 하도록) 리비전이 생성되면 생성된 task를 서비스에 업데이트하게 되면 현재 구동되고 있는 task가 active로 업데이트된 task가 primary로 등록되며 시간이 조금 지나면 active가 내려가고 primary가 active되면서 서비스가 이어지게 된다.</p><h2><span id="trouble-shotting">trouble shotting</span></h2><p>###* cat /etc/ecs/ecs.config</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could not register module=&quot;api client&quot; err=&quot;ClientException: Cluster not found.</span><br></pre></td></tr></table></figure><ul><li><code>/etc/ecs/ecs.config</code> 에 cluster 이름이 정확히 올라가 있는지 2번 확인한다.</li><li>그래도 안되면 ecs agent api call이 public ip를 요구하므로 public ip가 있어야한다.(또는 프록시 등의 다른 방법) ec2를 확인한다.</li></ul>]]></content>
    
    <summary type="html">
    
      aws ec2 container service 를 통해 서비스를 배포하자.
    
    </summary>
    
    
      <category term="ecs" scheme="http://blog.bglee.me/tags/ecs/"/>
    
      <category term="ecs_cluster" scheme="http://blog.bglee.me/tags/ecs-cluster/"/>
    
      <category term="ecs.config" scheme="http://blog.bglee.me/tags/ecs-config/"/>
    
      <category term="aws" scheme="http://blog.bglee.me/tags/aws/"/>
    
      <category term="ec2" scheme="http://blog.bglee.me/tags/ec2/"/>
    
      <category term="ec2 container" scheme="http://blog.bglee.me/tags/ec2-container/"/>
    
  </entry>
  
  <entry>
    <title>deview-2016</title>
    <link href="http://blog.bglee.me/posts/2016/deview-2016/"/>
    <id>http://blog.bglee.me/posts/2016/deview-2016/</id>
    <published>2016-10-23T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.624Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="deview-2016">Deview 2016</span></h1><p><img src="https://lh3.googleusercontent.com/o5PfgOsLJtkIDI1hRbb89DS8Os9SG_IJer64JvJfJyyS6zYuI_j0bTb2TPolXO2cYhL4gL9IZwc=w2145-h1343-no" alt=""></p><h2><span id="cto">CTO</span></h2><h3><span id="keynote">keynote</span></h3><p>회사에서 프론트엔드 개발차 지원해준 기회기 때문에 FE로 스케줄을 잡았는데 키노트를 들으니.. 로봇과 음성인식 세션이 궁금했지만 계획대로 진행하기로했다.</p><p>네이버 랩스는 무인 주행, 음성 인식(자연어), 로봇에 집중하고 있는 것으로 보인다. 무인 주행 자체에 집중하기 보다는 시각데이터를 파싱하는 목적이 큰 것으로 보였다.</p><p>M1(?) 이라는 네이버 랩스 로봇 영상이 보여졌는데 돌아다니면서 영상을 찍는데(머리가 카메라로 무장) 단순이 동영상을 찍는게 아니라 걸 돌아다니면 녹화했던 영상 데이터를 다시 보여줄 때는 걸려있던 액자들의 내용을 바꿔서 보여줬다. 3D 맵 데이터로 파싱해서 데이터화 하고 있는 것으로 보였다.</p><h3><span id="d2">D2</span></h3><h4><span id="naver-open-source">Naver Open Source</span></h4><p>2016년 4개를 공개함 <a href="https://github.com/naver.com" target="_blank" rel="noopener">https://github.com/naver.com</a></p><ul><li>pinpoint star: 2300</li></ul><p>나눔 고딕 폰트가 금일 업데이트 되었다.</p><p>지도 API는 일일 20만 콜이 가능하다.</p><h4><span id="d2-startup-factory">D2 Startup Factory</span></h4><p>스타트업 지원</p><h4><span id="papago">papago</span></h4><p>한국, 일본, 영어, 중국어 지원</p><h4><span id="whale">Whale</span></h4><p>네이버의 Chromium 기반 브라우저다. 12월 런칭 예정이다 [공식 홈페이지]<a href="https://whale.google.com" target="_blank" rel="noopener">https://whale.google.com</a></p><ul><li>네이버 브라우저 스플릿창 지원</li><li>글자 선택만으로 검색</li><li>스마트 팝업(구석에 나옴)</li><li>이미지 번역</li><li>악성코드 제어</li><li>파파고 기술이 들어가있음</li></ul><p>12월 발표</p><h4><span id="blue">BLUE</span></h4><p>생활 환경 지능(Ambient Intelligence) - 사용자가 요구하지 않아도 상황을 인식하고 추천하는 것</p><ul><li>understand - 이해하는 것</li><li>anticipatory - 답/정보/action을 예상 추천</li><li>natural UX 음성, gesture등</li></ul><h5><span id="amica">AMICA</span></h5><blockquote><p>AMI Connected All</p></blockquote><p>영상이 소개되었는데 아이템은 팔찌로 보이고 차 내에서 또 자기전에 말을 하는데 음성인식관련으로 siri와 매우 유사했다.</p><p><a href="https://amica.ai" target="_blank" rel="noopener">https://amica.ai</a></p><p><code>자연어 처리는 음성에만 국한된 것이 아닌 채팅에서도 사용이 가능하다.</code>는 것을 기억해야할 듯</p><p>AMICA는 11/7 까지 클로즈 베타 신청 받음(막상 들어가보니 11/6일)</p><p>Samsung ARTIK 으로(Intel Edison류의 보드인 것으로 보임) 포팅되어있어 사용이 가능하다.</p><h4><span id="자율주행">자율주행</span></h4><p>미국(?)의 기준인 NHTSA level 3 수준이다.</p><h4><span id="naver-labs-m1">NAVER LABS M1</span></h4><p>Indoor mapping robot</p><ul><li>공간 인식 및 정보화, 3D 실내지도</li></ul><p>이미지 인식기술은 인공지능 기술과 합성되면 사람의 눈과 같은 역할을 하게될 것으로 보여졌다.(카메라니 당연히 눈이지만 시각정보를 인간과 같이 파싱하는 느낌)</p><h2><span id="session01web-payment-api의-현재와-미래">Session#01(Web Payment API의 현재와 미래)</span></h2><p>2015-10 에 표준화 작업이 시작됨</p><h3><span id="motivation">Motivation</span></h3><p>68%는 카트에 담고 결재하지 않음, 데스크탑 보다 모바일에서 그보다 나가는 비율이 66% 더 됨</p><ul><li>폼이 너무 복잡하다</li><li>계정생성 귀찮음</li><li>모바일 디자인이 구림</li><li>로딩 속도</li></ul><h3><span id="web-payment-with-basic-cards">Web Payment with Basic Cards</span></h3><p>크롬 53(4?)에서부터 지원한다.</p><p>구성</p><ul><li>Payment Request API,</li><li>Payment Method Identifiers</li><li>Basic Card Payment</li></ul><p>복잡한 form으로 처리 되는 것을 <strong>one button</strong> 으로 처리한다.</p><p>브라우저가 가지고 있다. 판매자가 수용하는 payment request를 날리면 카드 리스트만 리스트업 됨</p><h4><span id="benefit">benefit</span></h4><h5><span id="user">user</span></h5><ul><li>쇼핑몰에 관계없이 같은 ux제공</li><li>처음 이용 쇼핑몰에서도 저장된 신용카드를 이용가능</li></ul><h5><span id="merchant">merchant</span></h5><ul><li>결재 ux개발안해도됌</li><li>보안이슈 및 서버 운용비용 절감</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> methodData = [&#123;</span><br><span class="line">supportedMethods: [<span class="string">'visa'</span>, <span class="string">'master'</span>],</span><br><span class="line">&#125;, &#123;</span><br><span class="line">supportedMethods: [<span class="string">'sampay'</span>],</span><br><span class="line">data: &#123;</span><br><span class="line">merchantID: <span class="string">'12345'</span>,</span><br><span class="line">...</span><br><span class="line">&#125;]</span><br><span class="line"><span class="keyword">var</span> pr = <span class="keyword">new</span> PaymentRequest(methodData, details, options);</span><br></pre></td></tr></table></figure><p>shippingOptions: 배송정보<br>paymentOptions: 어떤 정보를 입력받고 받지 않을지 결정</p><p>프로미스 기반</p><p>언급된 이벤트</p><ul><li>shipping address change event</li><li>shipping options change event</li></ul><p>지원하지 않는 지역이나 옵션이 올 경우에 대한 처리를 이벤트를 받아 처리할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.updateWith(<span class="comment">//이벤트 업데이트</span></span><br></pre></td></tr></table></figure><p>결재를 판매자측 서비스에서 처리하는데 개발 부하가 걸린다</p><p>앞으로 미래는 payment app을 사용한 결재가 있다.</p><h3><span id="web-payment-with-payment-apps">Web Payment with Payment Apps</span></h3><blockquote><p>SamsungPay, AliPay 등을 통해</p></blockquote><p>신용카드 뿐만 아니라 결재 앱을 카드처럼 지원한다.</p><p>페이먼트 앱</p><ul><li>웹 기반(현재 포커스 되어있음 w3c)</li><li>네이티브 기반(완전히 정의되지 않음) =&gt; 네이티브를 트리거하는 방식으로 진행 될 예정(지금이랑 같지 않은가?)</li></ul><h4><span id="service-worker">service worker</span></h4><ul><li>브라우저가 죽어도 살아있다.</li><li>브라우저에 설치되게 되며 필요한경우(푸시 알람) 이벤트를 수신받은 브라우저에 의해 활성화된다.</li><li>지정된 origin 및 scope에서만 동작하며, Secure Context에서 실행됨을 보장.</li></ul><p>payment app &lt;&gt; service worker 는 1:1 관계다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.serviceWorker.register(<span class="string">'/tree_pay.js'</span>).then(</span><br></pre></td></tr></table></figure><h2><span id="session02graphql">Session#02(GraphQL)</span></h2><p>기존</p><ul><li>rest<ul><li>필드제한 한계</li><li>필터 문제</li><li>문서 문제</li><li>동기화 문제</li></ul></li><li>json:api</li></ul><h3><span id="graphql">GraphQL</span></h3><ul><li>query</li><li>mutation</li></ul><p>object type을 가지고 schema를 정의</p><p>object</p><pre><code>* type(required): name* args: 인자* resolve: return function</code></pre><p>rest: postman / graphql: GraphiQL(chrome extension)</p><h3><span id="relay">Relay</span></h3><p>React와 GraphQL을 엮는다.</p><blockquote><p>Node</p></blockquote><p>Resource에 대한 단일 interface</p><blockquote><p>Connection(페이지네이션 특화)</p></blockquote><p>Node를 여러개 가져온다</p><blockquote><p>React Relay</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">React.createContainer(COMPONENT_NAME, &#123;</span><br><span class="line">fragments: &#123;</span><br><span class="line">editor(props의 이름: <span class="function"><span class="params">()</span> =&gt;</span> Relay.QL<span class="string">`</span></span><br><span class="line"><span class="string">fragment on User &#123;</span></span><br><span class="line"><span class="string">pictureURL</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;EditorInfo.getFragment</span></span></span><br></pre></td></tr></table></figure><blockquote><p>Mutation Config</p></blockquote><hr><p>query(node, connections),<br>변경(mutation)</p><p>참고 <a href="http://learngraphql.com" target="_blank" rel="noopener">http://learngraphql.com</a></p><p>검색해 볼 것</p><ul><li>nosyncdb</li><li>lukka</li><li>awesome graphql</li></ul><p>Q&amp;A 시간에 질의 응답을 볼때 Relay와 Redux는 함께 사용하기 껄끄러운(베스트 프렉티스가 없는) 상황으로 보여지며 기존 Redux 사용시의 전략인 외각 오브젝트에서 데이터 로직을 처리하고 나머지를 퓨어 컴포넌트로 가져가는 방식이 아닌 서버쪽 데이터를 활용하는 대부분의 컴포넌트가 Relay로 바인딩 되게 된다.</p><p>Redux, Relay 모두 Flux 아키텍쳐의 영향을 받았으므로 개인적으로는 Store가 로컬에 있느냐 리포트에 있냐를 차이로 보고 있지만 컴포넌트가 데이터와 강하게 커플링되는 것에 대한 거부감이 있는 것이 사실이다. 실제 적용을 해보면서 답을 찾아야할 부분으로 보인다.</p><h2><span id="session03electron">Session#03(Electron)</span></h2><p>검색시에는 <code>github eletron</code>으로 검색해야 한다.</p><p>slack과 microsoft가 샘플이 됨(Document에도 존재하지 않는 것들이 쓰이니 볼 것)<br>electron은 소스가 다 보인다. 로직을 백엔드로 빼서 구현했다고 말하고 있다.</p><p>로직을 백엔드로 빼면서 Command 패턴을 사용했는데 로직이 백엔드로간 이유는 보안상의 이유라고 한다.(여기서의 백엔드는 <strong>local</strong>에서 node server를 돌린다는 이야기다.</p><p>Devtron 이라는 크롬 익스텐션이 존재하는 이를 개발 환경에서 이용할 수 있다.</p><p>node 바이너리 솔루션</p><ul><li>enclosejs: 플랫폼에 맞춘 바이너리화</li></ul><p>eletron-builder</p><p>개인적으로 인상적인 세션은 아니었고 개발 방법론, 패턴등을 설명했음에도 30분내에 발표가 마무리되었다.</p><h2><span id="session04한-달-만에-개발한-하이브리드-앱-50만-사용자-서비스가-되기까지">Session#04(한 달 만에 개발한 하이브리드 앱, 50만 사용자 서비스가 되기까지)</span></h2><h3><span id="해먹남녀">해먹남녀</span></h3><p>하이브리드가 넘어야할 장애물</p><ul><li>view 전환 효과</li><li>300ms의 지연이 존재(웹뷰) - single tab, double tab을 잡기 위해 존재<ul><li>hammer.js, fastclick.js가 있음</li></ul></li><li>transition<ul><li>3d translate css 이용</li></ul></li><li>push<ul><li>cordova 등</li></ul></li></ul><p>백수시절 6개월동안 7개의 앱을 만듬(평균 2주)</p><p>해먹남녀는 IonicFramework을 이용해서 제작했다. 1달만에 웹뷰를 이용한 하이브리드앱을 제작했으나 2달의 안정화 작업을 거쳤다.</p><p>1주차</p><p>comonent부터 ui를 만듬<br>문제는 라우팅으로는 위계 제어가 힘들다.</p><p>2주차</p><p>어려운 문제들을 해결하기 시작</p><ul><li>sync</li><li>플러그인 업데이트 종속성</li><li>다중업로드</li><li>보안정책(애플)</li></ul><p>3주차</p><p>성능</p><ul><li>데이터 프리패치</li><li>터치 컨트롤 통제<ul><li>스크롤시 터치를 받지 않는 등으로 속도 향상</li></ul></li><li>이미지 리사이징</li><li>css blur처리가 속도가 느려서 40px짜리를 up scaling해서 속도를 향상 시킴</li></ul><p>4주차</p><ul><li>png 처리 투명</li></ul><h3><span id="voc-사용자-피드백-대응">VOC 사용자 피드백 대응</span></h3><p><a href="https://microsoft.github.io/code-push" target="_blank" rel="noopener">https://microsoft.github.io/code-push</a></p><p>클라우드에서 버전이 바뀌면 파일을 보내줌 급할때만 씀</p><h3><span id="cordova핵시configxml-프로젝트-설정-파일">cordova핵시config.xml 프로젝트 설정 파일</span></h3><p>버전관리, hook script 테스크 자동화, info, plist 자동 작성</p><h3><span id="세션-발표자의-회고">세션 발표자의 회고</span></h3><p>하이브리드 앱과 네이티브 앱 사이에는 넘을 수 없는 성능(트랜지션 등을 말하는 듯) 차이가 존재하나 하이브리드 앱이 보여주는 수준 자체가 준수하기 때문에 문제가 없다.</p><p>하이브리드 앱이 네이티브를 대체한다기 보다는 빠른 Time To Market을 맞추기 적합하며 이를 활용한다는 전략적 차원으로 발표자는 설명했다.</p><p>하지만 React Native가 있다면 어떨가…</p><h2><span id="session055년간의-네이버-웹엔진-개발삽질기-그리고">Session#05(5년간의 네이버 웹엔진 개발/삽질기 그리고…)</span></h2><p>Naver Labs의 신규 브라우저 Whale의 개발에 대한 스토리다. 사실 이 세션은 고민이 많았다. 선택할 수 있는 세션이 4개 였는데 다음과 같았다.</p><ul><li>Clean Front-End Development</li><li>React로 개발자 2명이 플랫폼 4개를 서비스하는 이야기</li><li>우리 팀에서도 코드리뷰를 할 수 있을까?</li><li>5년간의 네이버 웹엔진 개발/삽질 그리고…</li></ul><p>원래는 첫번째 세션을 들을까 준비했는데 Single Page Application만 5년 이상을 진행했고(심지어 임베디드 웹 브라우저에서도…) 사실 이 정도의 기간이 SPA 역사기 때문에 나이가 어린 세션 발표자거나(실망 시킨 경우가 많았다) 뻔해 보이거나 답 없는 주제(React vs Angular)와 같은 주제를 피하고 <strong>다수</strong>의 개발자들이 시간과 노력을 들여 진행한 프로젝트 <strong>이야기</strong>가 듣고 싶어 이 세션을 선택했고 결과 적으로 성공적이었다.</p><p>브라우저 세션 답게 블락 다이어그램으로 스택을 소개하고 공감가는 삽질기를 들을 수 있었다. Q&amp;A 시간을 포함해서 45분인데 그중에 무려 30분을 Webkit 기반으로 진행한 프로젝트 연혁을 말하고 있었는데. 결론적으로는 Webkit을 버리고 Chromium 기반으로 만들었다고…</p><p>국내에 브라우저를 낼 수 있는 기업이 얼마나 있겠는가 기대를 걸어본다. 브라우저 같은 뿌리 기술은 가지고 있으면 시너지를 낼 것도 많고 파급력을 가지는 대신 그 만큼 출시 이후에 끌고가는 문제도 있는 아무쪼록 잘 되었으면 한다.</p><h3><span id="whale">Whale</span></h3><p>일단 feature가 실제 사용 패턴과 관련 된 것이 맘에 들었다 대단히 실질적으로 사용패턴을 분석을 한 것으로 보였다.</p><p>Over Tabber를 예로 들었는데(탭을 엄청나게 띄워 놓는 사람) 이유인 즉슨 이렇다는 거다.</p><ul><li>쇼핑몰에서 고르는데 인덱스 페이지 하나를 두고 상세 페이지를 들어갔다가 나왔다 하기 귀찮으니 여러개를 띄워둔다.</li><li>사내에서 보라고 링크 공유가 왔는데 아예 안보는 것은 매너가 아니니 일단 띄워놓고 하염없이 둔다.</li><li>구글에서 검색을 한뒤에 원하는 결과를 찾는데 이 때 도움이 될 것 같은 것은 일단 띄워둔다.</li></ul><p>실제로 나도 봐도 그렇기 때문에 깊이 공감을 했다. 그래서 Whale은 스플릿 뷰를 지원하고 쇼핑몰등에서 유용히 사용할 수 있도록 했다.</p><p>읽기 모드를 미려하게 지원하고</p><p>블락하면 궁금하고 블락하지 않자니 너무 떠대는 탭들을 스마트 탭뷰를 만들어서 정리해서 볼 수 있도록 구현했다.</p><p>크롬 익스텐션이 풀리 호환되며 자체 지원을 위한 것도 준비되어있다.</p><p>음성 검색(파파고?) 이 들어가있다.</p><p>퀵 서치기능이 들어가있어서 단순 드래그만으로 단어나 인물등을 검색할 수 있는데 단순 검색이 아닌 검색 기반의 회사인 만큼 컨텍스트 검색을 통해 연관성이 높은 결과 값을 받을 수 있다.</p><p>일단 기능이 마음에 든다. 고민의 흔적도 공감할 수 있어서 개인적으로는 <code>아 맞게 고민했구나? (내가 쓸 수 있게...)</code> 이런 느낌을 받았다.</p><p>12월 런치로 보인다. <a href="https://whale.naver.com" target="_blank" rel="noopener">https://whale.naver.com</a></p><hr><h2><span id="deview-2016에-대한-개인적인-감상">deview 2016에 대한 개인적인 감상</span></h2><p>회사 업무도 업무고 상당히 가기 귀찮았는데 잘 갔다왔다는 생각이 든다. 무료 세미나에 가면 제품 홍보 성격이 강하다거나 어린 세션 발표자(어리다고 뭐라 하는 것이 아니라.. 확률상)의 경우 준비 미숙으로 50분 세션을 10분만에 끝내버리는 경우도 많았는데 그 보다는 훨씬 나았고 주제 자체가 진보된 것이 많았다. 무료 했었는데 좀 의지를 태울 수 있었다.</p>]]></content>
    
    <summary type="html">
    
      Deview 2016 세미나 정리
    
    </summary>
    
      <category term="summary" scheme="http://blog.bglee.me/categories/summary/"/>
    
    
      <category term="deview2016" scheme="http://blog.bglee.me/tags/deview2016/"/>
    
      <category term="deview" scheme="http://blog.bglee.me/tags/deview/"/>
    
  </entry>
  
  <entry>
    <title>AWS API Gateway - Lambda - Travis-CI prototype 구현</title>
    <link href="http://blog.bglee.me/posts/2016/aws-gateway-lambda-ci/"/>
    <id>http://blog.bglee.me/posts/2016/aws-gateway-lambda-ci/</id>
    <published>2016-09-25T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>aws serverless architecture</code> 의 핵심에 <code>api gateway</code> 와 <code>lambda</code> 가 있다. 두 서비스는 모드 서울 리전에서 사용이 가능하다. 이를 이용하여 프로토타입을 작성해 보자.</p></blockquote><h2><span id="architecture">architecture</span></h2><p><code>node</code>로 서버를 구성하는 것을 예로 들자면 아래와 같다.</p><table><thead><tr><th>node application</th><th>express-router</th><th>logic</th></tr></thead><tbody><tr><td>aws</td><td>api gateway</td><td>lambda</td></tr></tbody></table><p>aws에서 제공하는 아키텍쳐 예시를 보면 이해가 쉽다.</p><p><img src="https://awsblogskr.s3-ap-northeast-2.amazonaws.com/articles/2016-04-serverless/serverless-amazon-s3.png" alt="serverless architecture"></p><p><em><a href="https://api.example.com" target="_blank" rel="noopener">https://api.example.com</a></em> 부분을 통해 api gateway에 접근하면 라우팅을 통해 필요한 lambda함수를 콜하게 된다. 그리고 db 등에 데이터를 연산을 하고 다시 사용자에게 응답을 리턴한다.</p><p>이 포스트는 실무에 적용이 가능하도록 아래와 같은 내용을 담고있다.</p><ul><li>lambda 함수 생성</li><li>api gateway - lambda 함수 연결(parameter, header 설정)</li><li>development, production 모드를 분리하기 위한 stage 활용</li><li>travis ci를 통한 배포 자동화</li></ul><p>실제 구현 순서와는 상관없이 설명하기 편하게 상향식 접근 방법으로 작성한다.</p><h2><span id="lambda-함수-구현">lambda 함수 구현</span></h2><h3><span id="코드-구현-방식">코드 구현 방식</span></h3><p>lambda는 다음 3가지 방식으로 코드를 구현 할 수 있다.</p><ul><li>inline editing</li><li><strong>upload zip file</strong></li><li>upload from s3</li></ul><p>이 포스트는 배포 자동화까지가 목표이므로 2번째 안으로 진행한다.</p><h3><span id="구현-언어">구현 언어</span></h3><p><code>lambda</code>는 <code>java</code>, <code>python</code> 등 몇가지 언어를 지원하는데 이 포스트는 <code>nodejs</code> 4.3 버전을 기준으로 설명한다. nodejs 4.3은 <code>es2015</code>(a.k.a es6) 를 부분적으로 지원하는데 훌륭하진 않으며 다행이 <code>Promise</code>, <code>Set</code> 정도는 지원을 하고 있다.<br>이외에 코드 작성은 방식은 자유지만 컴파일 또한 비용이며 polyfill등을 이용하게 되는 경우 용량이 늘어나므로 추천하진 않는다.</p><h3><span id="lambda-함수-생성">lambda 함수 생성</span></h3><p>간단하면서도 lambda와 api gateway가 연결되면서 parameter들이 어떻게 전달되는지를 볼 수 있도록 코드를 작성한다. 배포하기 전 빠른 진행을 위해 aws에서 제공하는 <code>inline editor</code>를 사용해 바로 소스를 작성하도록 하자.</p><p><a href="https://console.aws.amazon.com" target="_blank" rel="noopener">aws console</a> 에서<code>lambda</code>를 선택해서 lambda 페이지에 진입한 후 왼쪽 사이드 바에서 <code>functions</code>를 누르고 <code>create a Lambda function</code>을 눌러 lambda 함수를 생성하도록 하자.</p><p><code>Select blueprint</code> 화면이 나오면서 template 들이 보여지는데 <code>skip</code> 버튼을 눌러 다음 스텝으로 간다.</p><p><code>configure triggers</code> 화면이 나오는데 우리는 api call을 통한 실행을 할 것이므로 <code>api gateway</code>를 선택하고 <code>next</code>를 누른다.<br><img src="https://lh3.googleusercontent.com/Y5RrAUzYbGCZF1Ei9TI8G8r3rNkEDVtTJxp3unq9N3-CNRfo0oEeLVlD2bBDqmqOM0hNmD5Z4TO-aV7URlndgAjXAHxW5ADU98mW1W-mvbqVIu8mtvdKS8ujNd0Xsxez_jbosmy3zxWeRlyk9tSz3qpm1sNcY3UqWmEYoIyuDUUmhsHAtuW74XnHU93Vq49XQtL6sdOLjUI6QC2Ts3XMR2v6752ZIaISRPXpmxZRpOB6x6ZXXErJ_poJMDqjoCoZJDmtST2ry3-T9tdnz37S-SvuD03g6EmF2ogILD8amHdycwkQWEVKiSNLBiw2-i_gjhIgov7nKowMCPI0BuJRnxyTC7WGitmCjsdtj7nV_G13gvQVz-4CkdOp3EKTwgEjZxq3zzfbpA-wbhgYSoAdSVtzxpwRA1WMIPvhNk7FAp0Afte0hvTaX807p9qvmJgkTw0ebaLV5Aj_M-COz2Mo7vScyYC2Rauan_O3Iu6KlXSNG-5zzF4u0cFjCWnv38xbscccKYZ3kOoY40gt0WajQ0OHG3IFG0YuAS4DUXn_pItE_b_oPaqNRehKPgK1CkcHZlK_1dlYlHRCJZ0dkkWFMirpJ6KpWJbeNEfimzM6KKRkfjg9jg=w1218-h546-no" alt=""></p><p><code>configuration function</code> 에서는 함수에 대한 설정을 한다. 아래와 같이 설정한다.</p><table><thead><tr><th>config</th><th>value</th></tr></thead><tbody><tr><td>Name</td><td>loopbackArgument</td></tr><tr><td>Description</td><td></td></tr><tr><td>Runtime</td><td>Node.js 4.3</td></tr><tr><td>code entry type</td><td>Edit code inline)</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exports.handler = <span class="function">(<span class="params">event, context, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    callback(<span class="literal">null</span>, &#123;</span><br><span class="line">        event: event,</span><br><span class="line">        context: context</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>export</code>할 함수 이름을 정하고(여기선 <code>handler</code>) lambda의 signiture대로 3개의 인자를 받는다. 인자를 간략히 설명하면 다음과 같다.</p><table><thead><tr><th>argument</th><th>description</th></tr></thead><tbody><tr><td>event</td><td>event call에 대한 정보로 parameter, header등이 이 인자로 매핑된다.</td></tr><tr><td>context</td><td>lambda 함수 자체에 대한 정보</td></tr><tr><td>callback</td><td>리턴함수라고 생각하면된다, 첫 번째 인자는 Error 객체, 첫 번째 인자가 null 경우 성공으로 간주되고 2번째 인자가 응답값으로 사용된다.</td></tr></tbody></table><p>이 코드는 단순히 람다 함수의 인자를 그대로 응답하는 <code>handler</code>함수를 반환하고 있다.</p><p>이 외는 기본 설정을 이용하며 <code>role</code>을 정해줘야하는데 이전에 람다를 위한 role을 만들지 않았다면 생성 후 선택하고 <code>next</code>를 함수를 생성한다.</p><h2><span id="api-gateway-lambda-함수-연결parameter-header-설정">api gateway - lambda 함수 연결(parameter, header 설정)</span></h2><p><code>api gateway</code>에서는 라우팅 테이블을 만들때 swagger를 지원한다. 기 구현된 서버가 swagger를 통해 문서화가 되어 있다라면 serverless architecture를 바로 적용할 수 있을 것으로 보인다.<br>특히 swagger에 <a href="http://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html" target="_blank" rel="noopener">api gateway extensions</a>가 존재하는데 이 부분을 swagger에 함께 작성하게 되면 파라메터나 응답값에 대한 정의를 문서 작성 단계에서 끝낼 수 있다.</p><p>이제 <code>api gateway</code>를 설정할 차례다.</p><h3><span id="api-생성">API 생성</span></h3><p><a href="https://console.aws.amazon.com" target="_blank" rel="noopener">aws console</a> 을 통해 api gateway 서비스에 접속한 후 <code>APIs</code> 메뉴에서 <code>Create API</code>를 누른다.</p><p>New API를 선택하고 <code>API name</code>에 <code>test</code> 라고 작성한다.<br>Actions를 눌러 <code>Create Method</code>를 선택하고 <code>post</code>를 선택한후 check 버튼을 눌러 생성한다.<br>이러면 생성한 <code>POST</code> method에 대해 setup하는 화면이 나오고 이미지와 같이 설정을 하여 위에서 작성한 <code>lambda</code> 함수를 연결한다.</p><p><img src="https://lh3.googleusercontent.com/BF-csXtOhMEE6WspJMUm7eZ7c6cr7_aM0Swxx_DFf0JXhE2c1TwVsB3REoLH30XMkyqQ01kiqZzwNumbqLkbpJ8ZUvj1PlXBK599B7kdjy2w38j9OXxwjtyRWo1rrve2TtxcQfaB5RKJrXmMtRiqiTW4Ojx0gig0NblF-l1sefCvQQuAmHDwDihrN0CYvXgRgPIIkV42kH4CW_tUX2rJtdCisScuSp2iJfc8I6piFwXKIIIWtiUFm7aNRFWds9norKHmpZFg9tJNCW6NdGvA_NsB4phrz-i286cgxUqL_UPvrksJ-_vvRAEm4NKi0cvw3qoRa8cDHQJHe-RAZKgcJgrSuyKkv6j8-Qw3MWVAB_ISlObYFAiEL-kt7C4fJ67zRGFa_BQp9dX1EnJZhSLXJ6jA_9RI63uxxrSuMvc0TBOHCwUtH6R5GvjMp_RpSVdHVrCoPYmKJ-qRPZre7SHnz5n9tfgSUfY97hiFLze-EeqYD8Ydc_dYrzyREgMhe-E8xxOzhfTgqQc-jarA-v2HpTiovD8g5AG_gLEbUhvISQJGRaUZXiCeRW-EZ8phipGYN5h5Yz9A7250P6T_9gFvNSGTb_vJKUeTBEL16jM96GdZzLj3Ww=w783-h400-no" alt=""></p><p>물론 함수명과 리전은 작업중인 상황에 맞게 넣어야한다.</p><h3><span id="api-설정">API 설정</span></h3><h4><span id="method-request">Method Request</span></h4><p>설정할 것은 없지만 <code>header</code>와 <code>query string</code>이 들어오는 것을 확인하기 위해 이미지와 같이 추가해 둔다.<br><img src="https://lh3.googleusercontent.com/vGNzrnq8mtX_glpQje0FTPMxqrXSkLpzEgWdDvfRe3oTCy-5dl40FLX9PhS1-i1tE6ECxszAc6U2jcWU3IvcP5tHLE20pmC4SNWx_uF7_bXlBWipFAENk11BSNIgFkws73UNRw2UycbSAp1q1uP7k69dWvuTGf3w2-w3uLcyUBKOSHukkFyFVBjd84nFHNm8b-sDr2RTE6sOdXQtJNsO0oQ6rOzgxu608HLW-iuS-LIdtMx6nNx92OONE-45P4Q05OlrT5QMNloXw2xr4xr-Ri5tq1EYcBbVm24PrePbUgpOhl9ZqKq_MZq-4pwMoYBWNSer4RCyJCuZxwATNn5ylEexzVLKaAYodFPwSFLbQ9ISL5-sZH0ZRVaAq0a1ZHM94bawcO50hOBjfagTF9Lamdc459-QLfk-TJlmHvg6BWWmyj17FAs8hT8Wn8FEKwBHOzmKj96JQOATff4grr2ZCFhM3H_XxF5JgFYkuPjUEOl91oJB3o14KLat8tIYcEmikC-lB6mafVXELgrYUVNDvqTDId3PFbKdDNdXYKevjk-XuSLgL3k7dticdFtCNhTfKSKpUA6MfX4A7wqgiYuJcK69gylm_vGUg1hoXzhWY7Ny2xo4Hw=w1192-h705-no" alt=""></p><h4><span id="integration-request">Integration Request</span></h4><p>여기선 <code>Method Request</code>에서 설정한 parameter 들을 받기 위한 설정인데 기본 템플릿을 적용하여 아래 이미지와 같이 설정한다.<br><img src="https://lh3.googleusercontent.com/yrQo0p55cgPUD7xTWGpXznNhTalanKmSUtGMWKBTGRNFTuhd3xBZRtlKc9sxsvtYBQclLVeRMvsxhHMC29ONSJ_aXoIqKKSFxulBV2_EDCAd6QuDlu8z5S2dceF1Qj-Es8SjbAg8uE-S0ttxZZIAGvIISN4vK7Y623GnEKb2RhVKPBQW-JB5FN9qgTtYVmCSwDLny9-QFXg7lRZtOeB82Wgn2SiycGyd-wNTyxe6j4cQV12umkC9czZvn2QAwRX_Xl6mzK6nDtoqvXbebe31hxAUUc2DzVnywpIO0LH33a1-vg2KF2Uau9VMfsk0SlC2B-QkXTUdkQSuVDrXN0VXrAfSSiGT6RCF2XwMm9vbK81JV6IH_jlcwxN2jufquEgjMugBCNa0hPFIs4vyj-747FT_9mp-dAlKYWGUF0Cf3rZpE-B-n4nZdiV175Cz0KLVoIuF26cgR2W0SbK2HBxIY3xMdJBnHmwOmr40ailQXudRvPzHXbJk6bS2eYKpz53kAdOOHLHbqHPYgSIKLDtT3CDF4RKQGc-FSkzUcDM93zqYUnGLvcRu2AESbRqq2D6GIjEP_WUUhsUsOtnljyzIvt-BWYNzU8bgD3jUndCmN0cZz_cAQg=w960-h597-no" alt=""></p><h3><span id="api-deploy">API Deploy</span></h3><p>사용을 위해 Resources 옆 Actions 를 선택하고 <code>Deploy API</code>를 선택한다.</p><p><img src="https://lh3.googleusercontent.com/wFO9ggX6eq_T46j0iEYnzGS1yMy74cNWPY9mGU9GhijI2hIxgfut6emscJ607db5BlGgZNPCbcQgBPCKUvYfKtCm3wpZx1xK0mE5-4-i7ABIpDH7GmSAv5o67gPalQTXsFwSvrW0havFns21c3H-PLd-rA80gm-typkeWRxbjKWgM54-gEjAiC2FVEGNdYaso9SQWsnujEUgschszxMhhRaJzC05zD8-L2Nd6ZW4b94ii_xzYjoz4bNrqQiGvMuDExiatSj8AcTg_KsGhm-FgctyyZX0zP8smvh89_sSyLE37y3baz5-9tq9Te42Mkfhj0pIO6zW-lP0ONVYyQhVjtBeZcW4RPzwsfXwunBE_t7vmPGC7yNtRPHChqtBP37XHjNkMNIR4ADhPr_Uyu_yhvk76Gzxw0JXuJATFg9DeT-Ct88_-nLG-9jzb4j1_RgZW0LAgL-BiUObujoweBDBcbmhAlpHP63DZZQ5FeBSyxAVx1u_0vKO8O7qENNDOmOFpiWlrzkjf9YS5OhkQsplCnSUQnjIpVm8K5aQCix8DcvxXhxfpkv_0ZLi5ym6GWLChP8T3-oru4ylc4lgSZwm7K9QUKvyzHbwWakSZGsrguDe2EcvfQ=w599-h412-no" alt=""></p><p>이미지와 같이 <code>[New Stage]</code> 로 <code>prod</code>를 입력 후 deploy 버튼을 누르면 <code>Stages</code> 화면으로 진입하면서 <code>endpoint</code>가 될 url이 <code>Invoke URL</code> 이라는 이름으로 보인다.<br>이제 이 url을 통해 api call 이 가능하며 당장 <code>postman</code>이나 <code>curl</code>등을 통해 확인이 가능하다.</p><p>1차적으로 <code>api gateway</code>와 <code>lambda</code>함수를 연결해서 실행을 확인해 볼 수 있는 상태가 되었다.</p><h2><span id="development-production-모드를-분리하기-위한-stage-활용">development, production 모드를 분리하기 위한 stage 활용</span></h2><p>작성한 코드를 실행해보면 아래와 같은 형태의 <code>json</code>이 응답으로 전달됨을 확인 할 수 있다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"event"</span>: &#123;</span><br><span class="line">    <span class="attr">"body-json"</span>: &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    "params": &#123;</span><br><span class="line">      "path": &#123;&#125;,</span><br><span class="line">      "querystring": &#123;</span><br><span class="line">        "deptno-param": "deptno test"</span><br><span class="line">      &#125;,</span><br><span class="line">      "header": &#123;</span><br><span class="line">        "Authorization": "deptno test"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "stage-variables": &#123;&#125;,</span><br><span class="line">    "context": &#123;,</span><br><span class="line">      "http-method": "POST",</span><br><span class="line">      "stage": "prod",</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "context": &#123;</span><br><span class="line">    "memoryLimitInMB": "128",</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Integration Request</code>에서 설정한 기본 템플릿을 통해 전달된 event 오브젝트와 context 객체의 내용이 구현한 함수의 기능대로 동작한다면 위와 같은 결과 값을 받을 수 있으며, 코드에 보여지는 부분들은 자주 참조 되는 영역만을 코드에 표시했다.</p><p>event 객체의 구조는 앞으로 사용할 lambda 함수에서 event 객체를 사용하는 <code>reference</code>가 된다.<br>보면 <code>event</code> 에도 <code>context</code>가 존재하는데 여기에 <code>stage</code> property가 있고 우리가 deploy했던 stage를 참조할 수 있는데 이를 통해 (프로덕션 코드와 개발코드가 분리되는데 맞지만) lambda 함수에서 개발 버전 또는 배포 버전의 일에 대해 분기를 할 수 있게 된다.</p><h2><span id="travis-ci를-통한-배포-자동화">travis ci를 통한 배포 자동화</span></h2><p>code로 대신한다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">- provider:</span> <span class="string">lambda</span></span><br><span class="line"><span class="attr">  function_name:</span> <span class="string">loopbackArgument</span></span><br><span class="line"><span class="attr">  role:</span> <span class="attr">arn:aws:iam::...</span></span><br><span class="line"><span class="attr">  handler_name:</span> <span class="string">handler</span></span><br><span class="line"><span class="attr">  region:</span> <span class="string">ap-northeast-2</span></span><br><span class="line"><span class="attr">  access_key_id:</span> <span class="string">...</span></span><br><span class="line"><span class="attr">  secret_access_key:</span></span><br><span class="line"><span class="attr">    secure:</span> <span class="string">...</span></span><br><span class="line"><span class="attr">  runtime:</span> <span class="string">nodejs4.3</span></span><br><span class="line"><span class="attr">  timeout:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><p>조금 부연하자면</p><ul><li><code>role</code>은 lambda함수를 생성할 때 줬던 role(lambda 함수 실행을 위한) 이 들어가야된다.</li><li>추가적으로 메모리 사용량 설정등도 가능하다.</li><li>s3를 통해 업로드하는 방식과 달리 폴더를 압축해서 zip파일을 업로드하게 되는데 이때 용량제한이 걸린다. 압축한 파일을 용량이 <code>50MB</code>를 넘어가면 deploy에 실패하게 되니 주의하자.<ul><li>이 때는 s3에 upload 하고 추가로 스크립팅을 통해 deploy 되야하므로 번거로워진다.</li></ul></li></ul><h2><span id="next">next</span></h2><blockquote><p>실무 적용 및 효율 적인 업무를 위한 추가 적인 작업들은 아래와 같다.</p></blockquote><p>todo</p><ul><li>custom domain을 통한 배포<ul><li>ssl 적용</li></ul></li><li>api gateway<ul><li>cors 적용</li></ul></li><li>swagger를 통한 문서화 및 배포</li><li>slack을 통한 알림 처리</li></ul>]]></content>
    
    <summary type="html">
    
      aws serverless architecture 의 핵심에 api gateway 와 lambda 가 있다. 두 서비스는 모드 서울 리전에서 사용이 가능하다. 이를 이용하여 프로토타입을 작성해 보자.
    
    </summary>
    
      <category term="dev" scheme="http://blog.bglee.me/categories/dev/"/>
    
      <category term="aws" scheme="http://blog.bglee.me/categories/dev/aws/"/>
    
    
      <category term="aws" scheme="http://blog.bglee.me/tags/aws/"/>
    
      <category term="ci" scheme="http://blog.bglee.me/tags/ci/"/>
    
      <category term="api gateway" scheme="http://blog.bglee.me/tags/api-gateway/"/>
    
      <category term="lambda" scheme="http://blog.bglee.me/tags/lambda/"/>
    
      <category term="travis" scheme="http://blog.bglee.me/tags/travis/"/>
    
      <category term="lambda 배포" scheme="http://blog.bglee.me/tags/lambda-%EB%B0%B0%ED%8F%AC/"/>
    
  </entry>
  
  <entry>
    <title>aws code deploy - ci</title>
    <link href="http://blog.bglee.me/posts/2016/aws-code-deploy/"/>
    <id>http://blog.bglee.me/posts/2016/aws-code-deploy/</id>
    <published>2016-08-14T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.621Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="todo">TODO</span></h2><ul><li style="list-style:none"><input type="checkbox">권한 이슈에 따른 이슈 (IAM role)</li><li style="list-style:none"><input type="checkbox">트러블 슈팅</li><li style="list-style:none"><input type="checkbox">github - ci - slack 링크 연결</li></ul><hr><p>aws를 잘 모르는 상태에서 aws code deploy와 travis ci, slack을 통해 배포하기 위해 삽질한 기록.</p><p>입사한지 4개월이 조금 넘어가는데 프론트엔드를 리딩을 하다보니 배포에 대한 니즈를 느끼게 되었고 그 삽질한 과정이다. 첫번째 프로젝트는 ci까지는 연결하고 배포는 쉘 스크립트를 이용해 scp로 운영하는 서버에 배포했다. 현재는 두번째 프로젝트를 조용히(?) 진행하고 있는데 n대의 서버에 배포하는 프로젝트를 곧 진행하게 될 것 같아 이 기회에 진행했다.</p><p>회사는 현재 aws를 통해 서비스를 제공하고 있고, github enterprise를 통해 코드를 관리하고 있으며 travis-ci를 도입하는 단계에 있다. aws code deploy 는 배포 코드를 여러대의 aws 서버에 순차적으로 또는 한번에 배포를 할 수 있게 하는 시스템이라 생각하면 된다.</p><p>코드 작성 부터 배포 까지의 한 사이클은 다음과 같다.</p><blockquote><p>github</p></blockquote><p>code 작성 =&gt; commit =&gt; push =&gt; pull request =&gt; merge</p><blockquote><p>ci</p></blockquote><p>pull =&gt; test =&gt; deply</p><blockquote><p>code deploy</p></blockquote><p>배포파일 download =&gt; 각 서버에 워하는 대로 배포</p><p>github =&gt; ci에 대한 것은 <a href="XXX">github - travis ci - slack</a> 포스트를 참조한다.</p><hr><h2><span id="code-deploy-설정">code deploy 설정</span></h2><p>배포는 여러가지 방법이 있는데 <code>aws code deploy</code> 는 aws에서 여러대의 서버에 배포를 할때 쓰인다. aws를 잘 모르는 상태에서 시간이 꽤나 걸렸는데 권한 설정에 대한 이해가 발목을 잡았던 것 같다.</p><p>우리는 지금 코드가 푸시되면 ci를 돌리고 있고 그 결과를 slack으로 받고 있다. 이제 ci가 성공했을 때 deploy를 해야한다. code deploy가 의미를 가지려면 여러대의 서버를 사용해야하고 auto scaling등의 기능을 사용해야하겠지만 여기선 배제한다.</p><p>알아둬야할 사항은 다음과 같다.</p><ul><li>aws console 에서 우리가 접근 할 서비스는 아래와 같다.<ul><li>EC2</li><li>CodeDeploy</li><li>Identity &amp; Acceess Management(IAM)</li><li>S3(s3를 통해 배포된다면)</li></ul></li><li>ec2 instance 자체에 code deploy를 위한 <code>role</code> 을 설정해줘야하며 이는 instance 시작 후에 변경이 불가능(?) 하다(이미 돌아가고 있는 인스턴스에는 적용할 수 없다).</li><li>codedeploy-agent 가 각 인스턴스 마다 설치 되어있어야 한다.</li><li>code deploy는 배포 데이터를 s3 또는 github으로 부터 번들링 된 데이터를 가져와서 실행하게 된다.</li><li>번들링 된 데이터에는 code deploy가 무엇을 배포해야할지 알 수 있게 하는 설정파일이 <code>root</code> 에 포함되어야 한다. 파일 이름은 <code>appspec.yml</code> 이다.</li></ul><h3><span id="appspecyml">appspec.yml</span></h3><p><a href="http://docs.aws.amazon.com/ko_kr/codedeploy/latest/userguide/app-spec-ref.html" target="_blank" rel="noopener">참고 문서</a> 를 보면 단순하고 또 정리가 잘 되어 있으므로 참고하기가 편하다(읽기 귀찮으면 <a href="http://docs.aws.amazon.com/ko_kr/codedeploy/latest/userguide/app-spec-ref-example.html" target="_blank" rel="noopener">example</a> 로 직행).</p><p>단순하게 실 사용하는 파일 내용은 다음과 같다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">0.0</span></span><br><span class="line"><span class="attr">os:</span> <span class="string">linux</span></span><br><span class="line"><span class="attr">files:</span></span><br><span class="line"><span class="attr">  - source:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">    destination:</span> <span class="string">/var/www/renderer/</span></span><br></pre></td></tr></table></figure><p><code>appspec.yml</code> 에서 <code>files</code> 섹션을 보면 <code>source</code>와 <code>destination</code>이 있는데 <code>source</code> 는 번들링 파일의 구조를 기준으로 root를 설정한다. 쉽게 말하면 <code>appspec.yml</code> 이 있는 위치가 root(<code>/</code>) 가 된다.</p><p><code>destination</code> 은 각 서버에 복사될 위치를 나타내며 서버안에서의 위치를 생각하면 된다.</p><blockquote><p>code deploy는 각각의 서버에서 직접 번들링된 파일을 내려받아 실행되는 구조로 보인다. 이 때문에 인스턴스 생성 때문에 <code>code deploy</code> 에 대한 <code>role</code> 을 가지고 있어야 한다. 번들링 된 배포 파일의 위치가 <code>s3</code> 라면 이에 대한 권한 설정은 덤이다.</p></blockquote><hr><p>대략적인 한 사이클에 대한 설명은 끝(?)났으니 실제로 따라해 보도록 한다. 글은 니즈의 순서대로 작성하고 올바른 순서는 표시를 하도록 하겠다.</p><hr><ul><li>iam role 설정<ul><li>ec2 isntance</li><li>deployment group</li></ul></li><li>codedeploy-agent 설치</li><li>배포서버 destination의 권한 확인</li></ul><hr><h3><span id="iam-설정">IAM 설정</span></h3><p><code>aws console =&gt; IAM =&gt; roles</code> 에서 <code>Create New Role</code> 을 선택해서 code deploy 대한 설정을 해야한다. 생성 후에 <code>Trust Relationships =&gt; Edit Trust Relationship</code> 에서 다음과 같이 설정한다</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Version"</span>: <span class="string">"2012-10-17"</span>,</span><br><span class="line">  <span class="attr">"Statement"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"Effect"</span>: <span class="string">"Allow"</span>,</span><br><span class="line">      <span class="attr">"Principal"</span>: &#123;</span><br><span class="line">        <span class="attr">"Service"</span>: [</span><br><span class="line">          <span class="string">"ec2.amazonaws.com"</span>,</span><br><span class="line">          <span class="string">"codedeploy.[:region].amazonaws.com"</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"Action"</span>: <span class="string">"sts:AssumeRole"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:region은 ec2가 존재하는 region을 설정하면된다.</p><p>//TODO: role</p><h3><span id="2-ec2-설정">[2] EC2 설정</span></h3><blockquote><p>IAM 설정</p></blockquote><p>[1] 에서 생성한 role을 선택해서 instance를 생성 하도록 한다.</p><blockquote><p>codedeploy-agent 설치</p></blockquote><p>문서화가 잘 되어 있어 그대로 따라하면 된다. <a href="http://docs.aws.amazon.com/ko_kr/codedeploy/latest/userguide/how-to-run-agent-install.html" target="_blank" rel="noopener">문서</a></p><h3><span id="3-aws-codedeploy">[3] AWS CodeDeploy</span></h3><p><code>codedeploy</code> 설정에 진입하고 <code>Create New Application</code> 버튼을 눌러 배포할 <code>application</code> 에 대한 설정을 한다.</p><blockquote><p>Application Name</p></blockquote><p>배포할 어플리케이션의 이름이다.</p><blockquote><p>Deployment Group Name</p></blockquote><p>같은 설정을 통한 배포로 엮일 그룹 이름을 지정한다.</p><blockquote><p>Add Instances</p></blockquote><p>인스턴스를 생성하면서 만든 태그를 통해 배포의 타겟이 될 인스턴스 설정을 한다.</p><blockquote><p>Deployment Configuration</p></blockquote><p>n개의 서버에 한번에 deploy 할 것인지 하나씩 순차적으로 할 것인지에 대한 정책이다. 한대이니까 설정오류가 나지 않도록 <code>CodeDeployDefault.AllAtOnce</code>를 설정한다(배포시에 서빙가능한 서버가 없어도 된다).</p><blockquote><p>Service Role<br>//TODO: codedeploy.[:region name].amazonaws.com 에 대한 설정이 되어 있는 role을 필요로 한다.<br>[1] 에서 생성한 deployment group 에 대한 role을 선택한다.</p></blockquote><h3><span id="ci_-설정">CI_ 설정</span></h3><p>CI가 slack에 알리는 것 외에 배포를 트리거 할 수 있도록 <code>.travis.yml</code> 에 <code>codedeploy</code> 관련 설정을 추가하고 번들링해서 업로드할 경로를 함께 설정한다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">before_deploy:</span></span><br><span class="line"><span class="string">[:</span> <span class="string">여기서</span> <span class="string">build를</span> <span class="string">한다]</span></span><br><span class="line"><span class="attr">before_deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">mkdir</span> <span class="bullet">-p</span> <span class="string">[:업로드할</span> <span class="string">번들링</span> <span class="string">된</span> <span class="string">파일이</span> <span class="string">존재하는</span> <span class="string">디렉토리]</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">cp</span> <span class="string">appspec.yml</span> <span class="string">[:번들링</span> <span class="string">할</span> <span class="string">루트가</span> <span class="string">되는</span> <span class="string">디렉토리]</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">cd</span> <span class="string">[:번들링</span> <span class="string">할</span> <span class="string">루트가</span> <span class="string">되는</span> <span class="string">디렉토리]</span> <span class="string">zip</span> <span class="bullet">-r</span> <span class="string">../[:업로드할</span> <span class="string">번들링</span> <span class="string">된</span> <span class="string">파일이</span> <span class="string">존재하는</span> <span class="string">디렉토리]/[:file</span> <span class="string">key(file</span> <span class="string">name)]</span> <span class="string">.</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">cd</span> <span class="string">..</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">- provider:</span> <span class="string">s3</span></span><br><span class="line"><span class="attr">  access_key_id:</span> <span class="string">[:your</span> <span class="string">access</span> <span class="string">key]</span></span><br><span class="line"><span class="attr">  secret_access_key:</span> <span class="string">[:your</span> <span class="string">secret</span> <span class="string">access</span> <span class="string">key]</span></span><br><span class="line"><span class="attr">  local_dir:</span> <span class="string">[:업로드할</span> <span class="string">번들링</span> <span class="string">된</span> <span class="string">파일이</span> <span class="string">존재하는</span> <span class="string">디렉토리]</span></span><br><span class="line"><span class="attr">  skip_cleanup:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  bucket:</span> <span class="string">[:bucket</span> <span class="string">name]</span></span><br><span class="line"><span class="attr">  on:</span></span><br><span class="line"><span class="attr">    branch:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">- provider:</span> <span class="string">codedeploy</span></span><br><span class="line"><span class="attr">  access_key_id:</span> <span class="string">[:</span> <span class="string">your</span> <span class="string">access</span> <span class="string">key]</span></span><br><span class="line"><span class="attr">  secret_access_key:</span> <span class="string">[:your</span> <span class="string">secret</span> <span class="string">access</span> <span class="string">key]</span></span><br><span class="line"><span class="attr">  region:</span> <span class="string">[:code</span> <span class="string">deploy</span> <span class="string">application이</span> <span class="string">존재하는</span> <span class="string">region]</span></span><br><span class="line"><span class="attr">  bucket:</span> <span class="string">[:bucket</span> <span class="string">name]</span></span><br><span class="line"><span class="attr">  key:</span> <span class="string">[:file</span> <span class="string">key(file</span> <span class="string">name)]</span></span><br><span class="line"><span class="attr">  application:</span> <span class="string">[:code</span> <span class="string">deploy에</span> <span class="string">설정된</span> <span class="string">application]</span></span><br><span class="line"><span class="attr">  deployment_group:</span> <span class="string">[:code</span> <span class="string">deploy에</span> <span class="string">설정된</span> <span class="string">deployment</span> <span class="string">group]</span></span><br></pre></td></tr></table></figure><blockquote><p>[:번들링 할 루트가 되는 디렉토리]</p></blockquote><p>컴파일 된 소스코드만 배포하면 되니 빌드된 바이너리나 코드가 있는 곳을 지정.</p><p>이제 ci가 deploy 전 단계까지 성공한 다음에는 s3에 번들링된 파일을 업로드하게 되고 <code>code deploy</code> 를 트리거하게 된다. 잘 되었는지 확인하기 위해서 aws console의 aws codedeploy로 진입하여 대상 application을 선택하면 배포 상태를 확인 할 수 있다. 실패한 경우에는 로그와 함께 어떤 상태에서 실패했는지를 확인 할 수 있다. download 에서 실패하면다면 s3에 대한 접근 권한 문제일 가능성이 크다.</p>]]></content>
    
    <summary type="html">
    
      aws를 잘 모르는 상태에서 aws code deploy와 travis ci, slack을 통해 배포하기 위해 삽질한 기록.
    
    </summary>
    
      <category term="setup" scheme="http://blog.bglee.me/categories/setup/"/>
    
      <category term="ci" scheme="http://blog.bglee.me/categories/setup/ci/"/>
    
    
      <category term="aws" scheme="http://blog.bglee.me/tags/aws/"/>
    
      <category term="code deploy" scheme="http://blog.bglee.me/tags/code-deploy/"/>
    
      <category term="ci" scheme="http://blog.bglee.me/tags/ci/"/>
    
      <category term="travis ci" scheme="http://blog.bglee.me/tags/travis-ci/"/>
    
      <category term="circle ci" scheme="http://blog.bglee.me/tags/circle-ci/"/>
    
      <category term="slack" scheme="http://blog.bglee.me/tags/slack/"/>
    
  </entry>
  
  <entry>
    <title>github - travis ci - slack</title>
    <link href="http://blog.bglee.me/posts/2016/github-travis-ci/"/>
    <id>http://blog.bglee.me/posts/2016/github-travis-ci/</id>
    <published>2016-08-14T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.625Z</updated>
    
    <content type="html"><![CDATA[<p>코드를 커밋하고 ci가 검증하고 이에 대한 결과를 슬랙으로 받고자 한다.<br>circle ci, travis ci 등 ci cloud service가 많은데 open source 를 지원해주는 <code>travis-ci</code>를 기준으로 해서 작성한다. circle ci도 개인 레포지터리 하나에 대해선 지원을 해준다.</p><h2><span id="travis-ci-github-연결">travis-ci, github 연결</span></h2><p>순서대로 진행을 하면 github과 ci를 연결해야한다. 일단 github에서 travis-ci를 사용하기 위해선 <a href="https://travis-ci.org/" target="_blank" rel="noopener">travis-ci.org</a>에 계정을 만들고 github계정과 싱크를 한다. 그러면 개인 레포지터리가 보이게 되고 여기서 활성화를 하면 된다.</p><p><img src="https://lh3.googleusercontent.com/bmMSu2O9kqUhIogjUduw6f9aaBVA9-JlWt3YLcQhZD8E2FEjw6bw1ez5uxx8O82ZCHpyiG8bjRYushydZVmCMH7SY4KgQKWOBzLe_wfhnPjSzDtGT1DhShhHV8i7ayPsJ_yr5t_Qoh0VA-eC4cK7aWZVe4BrVAXgm4go9IOC2uKns-02b2jeF5y7jB7MYMrA4vA6Tlzc8pRZbiB1EqZCD4_knU3Vm7K7_XSL_tUpNefrqTtCQyvgrMNc3pIfKl12BKgLZacLIVrUmux83RzfzX9JIIiOZHI_qmhTsp8qDVCr0_B3LqkkxLjmErrrEoDF3mCzH6y0A275-Khd1vtO2Hf23J1Nc74mSgkoK_WHxoEZgQXJOIgztkPNlgCWU8v5ci60l1QhjpywB0Al0I3oIT1wt7cpuWG6RPAB5FlEabOqjS_9w2JT1HsO5Ks6teVMR_BfyIZJgtGthuWDPeMxfMZMtM3WGGqD7ov9QdTyFHrIrzbYZQJCugaBaCteGy_q4CMp3p6Z7FepPWR2V3l7ECj83wiNpCwVAuro63jDxPHXQSLmQAsAprH6BYjpHkiJ67FuvejzchghetZhroiC7YCyirshftab=w1366-h558-no" alt="webhooks&amp;services"></p><p>활성화를 하면 다음과 같이 <code>github =&gt; repo =&gt; Settings =&gt; Webhooks &amp; services</code> 에 <code>Travis CI</code> 가 들어 온 것을 확인 할 수 있다.</p><p>소스코드에서는 travis에서 읽어갈 설정 파일을 만든다. travis-ci는 cli를 제공하므로 이를 설치하도록 한다. <code>ruby</code> 종속성이 있으므로 없으면 이를 먼저 설치한다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install travis</span><br></pre></td></tr></table></figure><p>이제 코드가 있는 디렉토리로 가서 <code>.travis.yml</code> 파일을 생성한다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">travis init</span><br></pre></td></tr></table></figure><p>이때 github에서 clone된 폴더로 작업을 하고 있었다면 자동으로 레포 정보를 가져오고 언어는 현재 사용하는 언어를 해주면 알아서 생성해준다.</p><p><code>npm</code>을 사용한 프로젝트라면 ci가 한번 돌 때마다 <code>npm install</code>에서 소요되는 시간이 상당하므로 캐쉬 설정을 해준다. <code>install:</code>에서 <code>npm install</code>을 한 경우에만 캐싱되는 것으로 보인다(또는 다른 곳에서 npm install을 하지 않은 경우)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  directories:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">node_modules</span></span><br></pre></td></tr></table></figure><h2><span id="slack-연결">slack 연결</span></h2><p>slack에 계정이 없다면 가입을 해서 생성을 하고 <a href="https://deptno.slack.com/apps/A0F81FP4N-travis-ci" target="_blank" rel="noopener">travis-ci를 설정하도록 한다</a> 여기서 <code>install</code>을 눌러 설치를 하고 <code>Post to Channel</code>에서 원하는 채널이나 본인(<code>Privately to @deptno (you)</code>)에게 알려주도록 설정한다. <code>token</code> 은 노출되면 안되므로 <code>Encrypting your credentials</code>에 써있는 코드를 복사해서 위에서 생성한 <code>.travis.yml</code> 이 있는 디렉토리에서 실행한다. 그러면 <code>.travis.yml</code>에 slack에 알림 설정이 된다.</p><p>이제 코드를 푸시해서 <code>master</code> 에 들어오게 되면 알림이 뜨게된다.</p><p><img src="https://lh3.googleusercontent.com/gNwGS-5IXSmlS4orWWp8RJozLxZhAYkNYN5EyINcr_5lqYyNQWNkwfXmhkaAHHIXYZog3P_hFSeOdkl7hiGGl1Wy0SP5YCxtSMFhwl_y7U4XgNb7bl1iP7DeBcsbBRlCKk3sd1tjBYvewduDjd4janAVnh51ZFNLgFe8d2j5t7022gjRbgDcMg4YIngKnXuCOSXQE_kPYmKACR78tZfPtLhAeXRADMDf7fqb0f35sGMTR5U6TNzTNTM4Fs4Z9IjvHQVEJJ1j_0IeWSimzPk7KICGLN7jyBPAYtJu9DxZeSUA-c28zF7fCh0n28tKDOG0m-RHShRjg22oVqQY1wvl-ncBnxcdGGldFOoqgTBnAxR5WAOl5RFWkCxDGgUNz-CCJRgmq3vzbljhfzxSiIzQ5B0lGFQrumB7UFFcriq893Xse_vVpFpo_l3_LVLi8GmyeXmgZ3CGAuIfM3KLiusHj029W5wAAwQOWeRJwqTBHvrd5vo6nc6zJTVGORXJVGtcZym1Wc5A_EAg8uO34QMfO6sO8MLAqtN_A2CqpDvLIBxKba1v8LJ1poW140-xo7Qv4GHj41m4dJh5pi73iHX16lmKXddBNzgF=w1050-h456-no" alt="slack-notification"></p><p>배포가 남았는데 배포는 서버 환경에 의해 좌우되므로 나눠서 기약없는 추후에 다루기로 한다.</p>]]></content>
    
    <summary type="html">
    
      코드를 커밋하고 ci가 검증하고 이에 대한 결과를 슬랙으로 받고자 한다. circle ci, travis ci 등 ci cloud service가 많은데 open source 를 지원해주는 `travis-ci`를 기준으로 해서 작성한다. circle ci도 개인 레포지터리 하나에 대해선 지원을 해준다.
    
    </summary>
    
      <category term="dev" scheme="http://blog.bglee.me/categories/dev/"/>
    
      <category term="ci" scheme="http://blog.bglee.me/categories/dev/ci/"/>
    
    
      <category term="ci" scheme="http://blog.bglee.me/tags/ci/"/>
    
      <category term="travis ci" scheme="http://blog.bglee.me/tags/travis-ci/"/>
    
      <category term="circle ci" scheme="http://blog.bglee.me/tags/circle-ci/"/>
    
      <category term="slack" scheme="http://blog.bglee.me/tags/slack/"/>
    
      <category term="github" scheme="http://blog.bglee.me/tags/github/"/>
    
      <category term="devops" scheme="http://blog.bglee.me/tags/devops/"/>
    
      <category term="notification" scheme="http://blog.bglee.me/tags/notification/"/>
    
  </entry>
  
  <entry>
    <title>vim node plugin</title>
    <link href="http://blog.bglee.me/posts/2016/vim-node-plugin/"/>
    <id>http://blog.bglee.me/posts/2016/vim-node-plugin/</id>
    <published>2016-08-02T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.633Z</updated>
    
    <content type="html"><![CDATA[<p>VIM 플러그인을 node로 작성하는 방법에 대해 간단히 리포트한다. 기본적으로 지원하는 플러그인은 vimscript, python정도로 보이는데 작은 기능을 추가하려고하는데 언어까지 배우기는 뭐해서 방법을 찾아봤다. 플러그인의 기능을까지라고 할 수 있을진 모르겠지만 node를 통해 간단한 작업은 할 수 있다.</p><p>OSX를 기준으로 작성되었고 <a href="http://blog.bglee.me/posts/2016/nvim/">neovim</a>을 사용하고 있다. 홈 디렉토리 안에 <code>.vimrc</code>파일이 설정일텐데 <code>neovim</code>에서는 <code>.config/nvim/init.vim</code>파일이 그 역할을 대신한다. 여튼 설정 파일을 열고 다음과 같이 추가해준다.</p><p>코드가 우아하진 않고 공유차원이 그러려니…</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CallNode</span><span class="params">(...)</span> </span></span><br><span class="line">    <span class="keyword">execute</span> <span class="string">'%! node -e "require(\"$HOME/.config/node-connector\")[\"'</span> . <span class="variable">a:1</span> . <span class="string">'\"][\"'</span> . <span class="variable">a:2</span> . <span class="string">'\"]()"'</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CallNodeWithEcho</span><span class="params">(...)</span> </span></span><br><span class="line">    <span class="keyword">echom</span> <span class="built_in">system</span>(<span class="string">'node -e "require(\"$HOME/.config/node-connector\")[\"'</span> . <span class="variable">a:1</span> . <span class="string">'\"][\"'</span> . <span class="variable">a:2</span> . <span class="string">'\"](\"'</span> . <span class="variable">a:3</span> . <span class="string">'\")"'</span>)</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">nmap</span> ,fj :<span class="symbol">&lt;C-U&gt;</span><span class="keyword">call</span> CallNode(<span class="string">"format"</span>, <span class="string">"json"</span>)<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> ,fx :<span class="symbol">&lt;C-U&gt;</span><span class="keyword">call</span> CallNode(<span class="string">"format"</span>, <span class="string">"xml"</span>)<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> ,trk :<span class="symbol">&lt;C-U&gt;</span><span class="keyword">call</span> CallNodeWithEcho(<span class="string">"translate"</span>, <span class="string">"en"</span>, <span class="built_in">getline</span>(<span class="string">"."</span>))<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> ,tre :<span class="symbol">&lt;C-U&gt;</span><span class="keyword">call</span> CallNodeWithEcho(<span class="string">"translate"</span>, <span class="string">"ko"</span>, <span class="built_in">getline</span>(<span class="string">"."</span>))<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> ,trj :<span class="symbol">&lt;C-U&gt;</span><span class="keyword">call</span> CallNodeWithEcho(<span class="string">"translate"</span>, <span class="string">"ja"</span>, <span class="built_in">getline</span>(<span class="string">"."</span>))<span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></table></figure><p><code>CallNode</code> 와 <code>CallNodeWithEcho</code> 함수가 있는데 후자는 결과 값을 VIM의 status bar에 표시해주는 역할을 한다.</p><p>아래 다섯개의 함수를 정의했는데 역할은 순서대로 다음과 같다.</p><ul><li>formating json</li><li>formating xml</li><li>영어로 번역</li><li>한국어로 번역</li><li>일본어로 번역</li></ul><p>함수의 정의를 보면 알겠지만 단순히 node 스크립트를 로딩해서 실행하는 것이다.</p><p><code>$HOME/.config/node-connector</code> node script를 로드하므로 이 파일을 작성해줘야한다.</p><p><code>node-connector.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pd = <span class="built_in">require</span>(<span class="string">'pretty-data'</span>).pd;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    format: &#123;</span><br><span class="line">        json: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> i = process.stdin, d = <span class="string">''</span>;</span><br><span class="line">            i.resume();</span><br><span class="line">            i.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line">            i.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; d += data; &#125;);</span><br><span class="line">            i.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="built_in">JSON</span>.parse(d), <span class="literal">null</span>, <span class="number">4</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span>(ex) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(d);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        xml: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> i = process.stdin, d = <span class="string">''</span>;</span><br><span class="line">            i.resume();</span><br><span class="line">            i.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line">            i.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; d += data; &#125;);</span><br><span class="line">            i.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(pd.xml(d));</span><br><span class="line">                &#125; <span class="keyword">catch</span>(ex) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(d);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    translate: &#123;</span><br><span class="line">        en: <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.tr(<span class="string">'en'</span>, text);</span><br><span class="line">        &#125;,</span><br><span class="line">        ja: <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.tr(<span class="string">'ja'</span>, text);</span><br><span class="line">        &#125;,</span><br><span class="line">        ko: <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.tr(<span class="string">'ko'</span>, text);</span><br><span class="line">        &#125;,</span><br><span class="line">        tr: <span class="function"><span class="keyword">function</span>(<span class="params">source, text</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> client_id = <span class="string">''</span>; <span class="comment">//<span class="doctag">TODO:</span> use yours</span></span><br><span class="line">            <span class="keyword">var</span> client_secret = <span class="string">''</span>; <span class="comment">//<span class="doctag">TODO:</span> use yours</span></span><br><span class="line">            <span class="keyword">var</span> host = <span class="string">'openapi.naver.com'</span>;</span><br><span class="line">            <span class="keyword">var</span> port = <span class="number">443</span>;</span><br><span class="line">            <span class="keyword">var</span> uri = <span class="string">'/v1/language/translate'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> data = <span class="built_in">require</span>(<span class="string">'querystring'</span>).stringify(&#123;</span><br><span class="line">                source: source,</span><br><span class="line">                target: source !== <span class="string">'ko'</span> ? <span class="string">'ko'</span> : <span class="string">'en'</span>,</span><br><span class="line">                text: text</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> options = &#123;</span><br><span class="line">                host: host,</span><br><span class="line">                port: port,</span><br><span class="line">                path: uri,</span><br><span class="line">                method: <span class="string">'POST'</span>,</span><br><span class="line">                headers: &#123;</span><br><span class="line">                    <span class="string">'X-Naver-Client-Id'</span>:client_id,</span><br><span class="line">                    <span class="string">'X-Naver-Client-Secret'</span>: client_secret,</span><br><span class="line">                    <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">                    <span class="string">'Content-Length'</span>: Buffer.byteLength(data)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> req = https.request(options, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">                res.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line">                res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(chunk).message.result.translatedText);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">            req.write(data);</span><br><span class="line">            req.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>번역 api를 서비스로 네이버 개발자용을 쓰고 있어서 이 부분은 각자 발급해서 본인 것을 쓰면 된다.</p><p>이제 문장이 있는 줄에서 영어로 번역을 원한다면 <code>,trk</code>를 누르면 된다. json파일을 포맷팅하고 싶다면 <code>,fj</code> 이런식이다. 오류가 발생하면 그대로 원본글 그대로를 보여주게 해놓았다.</p><p><img src="https://lh3.googleusercontent.com/Fe-tFQizH0CoxQ9FhCGlr5eSMqytEXRVb3WUjeADnxQy_IHY2RDovBceHDmGe3vEFkd0FART-ZiznSvQyyVOjxVXqEtdfMfL7oMD2IKGUHFylzebdqfgox9NKNuufM6WB5kE14MKYCOgIkCTQCWsyGP5lxSXShg0ecsO-D9AHT_ZTQpMjtlAZkxSuXucykq_WAFuiicghMsDFSpTwKmWSt0DQIXJxX6ZpzMmV8jOD_wKwg0kxswsmeYBTAyL51eGAOXzQSHdsJziq6bu3B-8qcEII9UW-isg09QzMMzQVnxiFw1NqsDZQyPryNaZFV5PRQqU-CQxXFchsmQ9KDmTcc1jf2k0tt7DeSXUMaZSILpkPvTd4x6HoTzCM7_ZVQYxo1J3Hz1BhrtzgosJ9imjPbS-B8fz4cpXoNh_UqH_D2d-iEDA1aVg3BiuvgHJqsmHKrXUgt5VEinQri3CJSfctutGGXNB81X1V-e8WF3GM5u2ZsqB6MnAU8RAstE72Q_DqmsEcVqcY_EnZnP1tOu93vdqrByjrdzcnr8snG3tEYM_ozDnhLVesTDiYduND_G6ynoLUHt-AlrjEA3nRsrB0F8LHfsP6oms_QfrjgjT04CBOQ09UA=w191-h176-no" alt=""></p><p>더 참조가 필요하다면 필자의 셋업을 참조하도록한다. 보통 난 노트북을 새로 셋업할때 git을 깔고 처음으로 설정을 클론뜨도록 해두었다. vim은 터미널 환경의 반이니까.</p><p><a href="https://github.com/deptno/.config" target="_blank" rel="noopener">https://github.com/deptno/.config</a></p>]]></content>
    
    <summary type="html">
    
      vim 프러그인으로 node script 호출하는 방법
    
    </summary>
    
      <category term="dev" scheme="http://blog.bglee.me/categories/dev/"/>
    
      <category term="js" scheme="http://blog.bglee.me/categories/dev/js/"/>
    
    
      <category term="neovim" scheme="http://blog.bglee.me/tags/neovim/"/>
    
      <category term="vim" scheme="http://blog.bglee.me/tags/vim/"/>
    
      <category term="vim plugin node" scheme="http://blog.bglee.me/tags/vim-plugin-node/"/>
    
      <category term="vim plugin javascript" scheme="http://blog.bglee.me/tags/vim-plugin-javascript/"/>
    
  </entry>
  
  <entry>
    <title>Neovim</title>
    <link href="http://blog.bglee.me/posts/2016/nvim/"/>
    <id>http://blog.bglee.me/posts/2016/nvim/</id>
    <published>2016-08-02T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.630Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew install neovim/neovim/neovim</span><br><span class="line">curl -fLo ~/.config/nvim/<span class="built_in">autoload</span>/plug.vim --create-dirs \</span><br><span class="line">     https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br><span class="line"><span class="built_in">cd</span> ~ &amp;&amp; git <span class="built_in">clone</span> https://github.com/deptno/.config.git</span><br><span class="line">touch ~/.local.vim</span><br></pre></td></tr></table></figure><p>만약 <code>.config</code> 디렉터리가 있다면 실패하게된다 이때는 레포에 직접 접속해서 <code>.config/nvim/init.vim</code>을 들고와서 넣어준다.</p><p>특정 폰트를 사용해야만 깨짐이 없으므로 패치된 폰트를 아래서 하나 받아 설치하고 iTerm2의 Non-ASCII Font를 설치한 폰트로 설정.<br><a href="https://github.com/ryanoasis/nerd-fonts" target="_blank" rel="noopener">https://github.com/ryanoasis/nerd-fonts</a> 너무 많아서 개인적으로는 그 중에 <a href="https://github.com/ryanoasis/nerd-fonts/blob/master/patched-fonts/DroidSansMono/additional-variations/Droid%20Sans%20Mono%20for%20Powerline%20Nerd%20Font%20Plus%20Font%20Awesome%20Mono%20Windows%20Compatible.otf" target="_blank" rel="noopener">들어본 폰트</a>를 설치했다.</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew unlink vim</span><br><span class="line">cp -f /usr/<span class="built_in">local</span>/bin/nvim /usr/<span class="built_in">local</span>/bin/vi</span><br><span class="line">cp -f /usr/<span class="built_in">local</span>/bin/nvim /usr/<span class="built_in">local</span>/bin/vim</span><br></pre></td></tr></table></figure><p>path문제로 되지 않을 경우 <code>.zshrc</code>의 <code>PATH</code>를 수정하면된다</p><h2><span id="trouble-shooting">trouble shooting</span></h2><blockquote><p>E902: “eslint” is not an executable</p></blockquote><p>js 파일 수정시 eslint 가 실행되야 하는데 없어서 생기는 문제다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -g install eslint</span><br></pre></td></tr></table></figure><blockquote><p>requires Vim compiled with Python (2.6+ or 3.3+) support</p></blockquote><p>YouCompleteMe와 같은 플러그인은 파이썬을 필요로한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install python3</span><br><span class="line">pip3 install --upgrade neovim</span><br></pre></td></tr></table></figure><p>[<a href="https://neovim.io/doc/user/provider.html]" target="_blank" rel="noopener">https://neovim.io/doc/user/provider.html]</a></p>]]></content>
    
    <summary type="html">
    
      neovim 설치
    
    </summary>
    
      <category term="setup" scheme="http://blog.bglee.me/categories/setup/"/>
    
    
      <category term="neovim" scheme="http://blog.bglee.me/tags/neovim/"/>
    
      <category term="vim" scheme="http://blog.bglee.me/tags/vim/"/>
    
      <category term="nvim" scheme="http://blog.bglee.me/tags/nvim/"/>
    
  </entry>
  
  <entry>
    <title>맥북 설정</title>
    <link href="http://blog.bglee.me/posts/2016/osx/"/>
    <id>http://blog.bglee.me/posts/2016/osx/</id>
    <published>2016-07-27T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.631Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>맥북 때문에 겁먹은 동지들을 위해 씀.<br>이 글의 대상은 일반인과 (프론트엔드)개발자를 모두 포함한다.</p></blockquote><p>맥을 받으면 <code>App Store</code>에 가서 OS 부터 업데이트를 시작한다.<br>그 동안 만약에 키보드랑 마우스를 받았는데 <code>Apple</code> 이 안찍혀있으면 어차피 방해되므로 몰래 버리도록 한다.<br>시스템 환경설정에 들어간다. 키보드 부터 설정해야한다.</p><h2><span id="키보드-설정">키보드 설정</span></h2><p>키보드 설정은 시스템 환경설정을 통해 진입하면 된다.</p><blockquote><p><code>^</code> 이건 <code>ctrl</code> <code>\-</code> 이런식으로 생긴건 <code>alt</code> 꽃무니같은 건 <code>command</code> 키다.</p></blockquote><p>캡쳐하기 귀찮아서 키보드로 쳤다…</p><p><img src="https://lh3.googleusercontent.com/So-FYJm3xdz10SDnxpKhrms-eYwNF81RSQVXHHV4AVVXlplEOm9LyYDgeKLgb9rvzzTisExzJuKknZD6Qj4WQGZLgWfjQnYJhEgQw14ZuQUkMskfJ9mrBCw3R2lrVIsCx5IxQPh2kbO7zEoRHJvNf0BBWUNxifwppISFT3EKqGKIRP8UDMn4ebmHqxcRFoUUVm_zN08VKce_G3QVyFXYOJEuCwZIM1TrYCBA_kFmfooStWLKmSiWSvMRb30KQXvObwWCAQOii7bAeMAIpsZWARjf2JBiFOB51ZIrZcyR2R8rauFAb77GMc6IocZ-V1JwA75UcIAA3YRnMuLY4p9OmlrYwB2T7fE93Zvvx6hndY3bnoU3s6SK94mBC5mctwWczq7hulxfOnF1PdEf0kbZ4ios_wuvj0_6dfbAwu_sW_qqCKX78gx5TqVPwgdhlysXazeAYYyf_NlBXg3rj3hLziViTXbVlXxXVkaeyGU-ldgse3p40bYUmkrtZRHfMQVJ34GW2nRoBfVxEZuFns8QMTF16kYxwzjLq_tEYO-_nM3ePUd-2ELlwl-K8ySroRjA_CqdPB8h227wfP8hcX8np-z6aFoLa9RfwhHvcxvI__EKRWdP2w=w666-h294-no" alt=""><br><img src="https://lh3.googleusercontent.com/WV3JTj-_JPHRPLRuEESw6v5WI8dGOQGnpcWFcOqj1nWox1moJ_YGhz9m47-Ke8AYfWDyD1iZLIRurm7EACfVg4NnD6xyKqBvzFACly0eNVrT06bNtlT48MlNcPCTtCHXv3qA2hTcEHFnfkXRYAWWN4N_6PIbHmKCehm3yqoQmwvyLYRq5jRJskBmi-utSri-_1JdG5MKH75hHJrtn6KAQrGBJDk1_RGkKF6NnNGImTFnOrDB_vTiARJA1DRC7Fz4fgUHUFfKE23iOpvKvicNs4q1ZQpaEpzTKJbYN0VFkTw-1sfRAS3ObLeYij91j2AfRfC-vnBupKynrm4uk5aAMNuLFlCys7DHFXhldzsxzFsyBTCCpkSVUz6Vvc9xMEz3WHNmVH01ixVXjtLv7cUVuJhzM1aakYhzj2-HMD8PjXcjCwTbRG3HR3VOGgu57Wl-Uj4sKr6dMqe9j9uduoXu_XJ_vVunU3XTAXLvttuU62EAfGumfG6Z627pdVzcmr8ItKfxIrC6Z4OFUBDdVbibgT0oVbsT6owL1b0p9TVIbvHzalG7Hs5BC-A0MAiZUNtDIq3sg9CcUn3FEc--Qr2X9aPx6si8gQDR1zpVyTp5W1SvJd-5PQ=w663-h181-no" alt=""></p><ul><li><code>키보드</code> <code>모든 F1, F2 등의 키를 표준 기능 키로 사용</code> 설정</li><li><code>단축키</code> <code>입력 소스</code> <code>입력 메뉴에서 다음 소스 선택</code> <strong>*</strong>만** 설정</li><li><code>단축키</code> <code>Spotlight</code> <code>Spotlight 검색 보기</code> <code>^스페이스</code> 로 설정</li></ul><p>이거면 우리는 키보드를 사용할 수 있게 된다.</p><p>다음은 터치패드다.</p><h2><span id="터치-패드-설정">터치 패드 설정</span></h2><p>터치 패드 설정은 시스템 환경설정을 통해 진입하면 된다.</p><p><img src="https://lh3.googleusercontent.com/hRuW7aeOPac5zV0_lGFfw8iPuSL7OmZ29WOVrHQOrXvVrAxcbc4n9PaxsAMSVjIFnCcpE8XRfu7WlFGCRILPh1ogfW6pGvsZ9Qrv7fOMjReo-KESfO5wZzJTXU3jWYG3QE3_a_TyVhKnaG6jML6TUHEt3HbmJ-f3-U5qk6Xq832pWjwrikSeErJVYPU1QkHvUUc_SHRbFYDA9Y5-cF597jr5my3iABV3pyz9WhkeGskOJqScth2-v96isV1oLa7pKlmMV1xQ4QzFy27qAVj8wPQGrjfDcAWn3eurq7KONKD2S5dTUeqADWQc7qsONJ1d66Uiu7h87e4nWLIkwJqgNWi9Qkr7t4jm5jSRxwIqJ1duBwDIXxWK8LOu1btXfgBaUoMlJqUZvZodBswLcHPnNsSAutUXv1aBn_zTOrVnbJ_rny8o4HX9tAQOoKXFw4VU9JclR0volcY9FfnpSQ2PdutWIv7Rc3p90YrE54Aim8ENDxt9lhbcvZ90dUntBtC_Y7oFXYXyjeOx7ENMT948Ays5U8UK-CsKm7K_49KypyHMm-Wxa7ma0KbdKLnMefuyJg5SvAqsjheWbXUkTwwCchYOeGv0LJQP7yFb7xgN7V82xuyauQ=w666-h517-no" alt=""><br><img src="https://lh3.googleusercontent.com/Tg7NUpTwiKcDNX7LncGqJM7smxCku7aWbnDEy6ek1UE2hLDAROy39G4BS-okf4ZdGcc9ZWQrHEx7rcH8IY_xZcJrZBeAVAvbp7QP9UBBajOs3jCkTmmO7C2H6PD06szXMo_bLotnvlPfsCi3kgAKXd68zbwqzem8bmcfjf_qeZHOVAbqXrWlVFU-UoaA7ZpmH0nLXV3RPoe6U7JAZpOk9OHzHrLx4A1W3nvcWIFziHdEpDNB003rgZWns5DqvjBhKFjyGG3BCfU8NeLj82Nqh7OKlABqxBl29JqD4DOTR0fM5PCPj0GLEhU20G9bg99Flr0H1aB0jX8Fi_-qiZXxne-iEIIWUNxsrysyw4EyBD-gQcHnvaPZOLjLsBc1MRBtQaS-Lpo4hXe2-Hmn3_QpjCKcVVIBKno-6dwt9rNJJcBKng6EoxA-epOS3jvcqhwZaUmWowBx2RVwPDXA5f2lT6u9p4WZLBVeeY5HbNFk9eEzjwbSrNoKHYtOLQNkTforpYbhJqrVwausZqttrFe_k-HYpXdCSYEGz7vWon3_R8mhfYpVvz6ax9ST0Zc6MrA-yXno4OzR4_Af8dPC2UzSvKieih_CUzyo1Lgw4-PgbU8RtZshHQ=w667-h514-no" alt=""><br><img src="https://lh3.googleusercontent.com/M-wLIecAqfenmyM1Ag9tvZcKhqGjeOp869O5fO8TWPFUIjtWs_DaKBmxQKfNKo-Cwupcvoz0i64qrrFfRCSghIOlhTx6uHSw-C7r0vLu7rt_xYbG7lYb-nmN_PBiGv-qAhuO5Fi9Vhzbi4796kkUqZNbhvHBqDBrvw2PTW-tOAeujT_Va3pdH2Km4LQW-JlmPmBpL0m9B6hc9ZUdj_5l9dFivEpw-CNal_Nwy7cRc7FImZ2xzgvjCFB_2X7q_6CfWNmF4YQLv3a_L7t0uTf7cTRJjv6sq9O7mg6bbRCSsn3kze9RVpjvIvl-Syt9ngBK6M0i7G-VeqHrc4CqRSwrEynMZgqeQNxT2HgO8C_YFaETHzoOHOoSgiMMiV9xVbPNoi9WZCAZ-HPaiYXxrMlzcJ3_2oaJJmQQkEQjkQNRQ_k_uySUCJ4dj3KsCZVGuyUKMnQQ6RkXnE43a8UK2gfLWWTuHHXcCYbMptI255AdYCQS1MEv2XDL6Y-dc__iqEg2YPtvYBr7x6JPvcmqjXeTpPUC9Sf8_ZeMC09K2hAqO_K1utcYnPeV19SJdd0XMASdm-RRDJJvA8rLxLx1wIdO4idhUPJQxsV7AI45T08OmULZ_RHAzA=w669-h514-no" alt=""></p><p>체크 박스아래에 <code>세 손가락으로 탭하기</code>등도 설정메뉴이므로 동일 하게 설정한다.<br>그럼 클릭이 아닌 탭으로 클릭동작을 수행할 수 있고 두 손가락으로 우클릭이 가능해진다.<br>네 손가락으로 스와이프를 하면 바탕화면간 이동이 가능해진다. 설정 메뉴 자체가 튜토리얼이니 유심히 보도록 한다. 중요하다.</p><h2><span id="손쉬운-사용">손쉬운 사용</span></h2><p>손쉬운 사용도 시스템 환경설정을 통해 진입한다.</p><ul><li><code>마우스와 트랙패드</code> <code>트랙패드 옵션...</code> <code>관성사용</code> 체크 <code>세 손가락으로 드래그하기</code> 체크</li></ul><p>이제는 손가락 3개로 드래그가 가능해져서 마우스가 필요 없어진다.</p><h2><span id="프로그램-설치">프로그램 설치</span></h2><ul><li>일만 하면 우울하니까 <code>카카오톡</code> 설치한다.</li></ul><hr><blockquote><p>여기서 부턴 개발자를 위한 코스다.</p></blockquote><ul><li>요즘은 보통 쓰는 <code>Slack</code> 설치한다.</li><li>개발자니까 터미널은 있어야한다. <a href="https://www.iterm2.com/version3.html" target="_blank" rel="noopener">iTerm</a>을 설치한다.</li><li>FE 개발자니까 <a href="https://www.google.com/chrome/" target="_blank" rel="noopener">Chrome</a>, <a href="https://www.jetbrains.com/webstorm/" target="_blank" rel="noopener">WebStorm</a> 설치한다.</li><li>에디터 하나는 필요하니까 리듬에 맞춰 하나 선택한다.<ul><li>neovim - <a href="http://blog.bglee.me/posts/2016/nvim/">설정 포스트</a></li><li>vs code</li><li>atom</li></ul></li></ul><h2><span id="개발-환경-셋업">개발 환경 셋업</span></h2><p>이제 터미널도 생겼고 개발 프로그램들도 설치했으니 필요한 환경들을 셋업한다.</p><h2><span id="git">Git</span></h2><p>git은 터미널에서 <code>git</code>이라고 치면 라이센스 어쩌고 나오게 된다 그걸 설치하면된다.</p><h2><span id="터미널-환경-설정">터미널 환경 설정</span></h2><p>ohmyzsh - <a href="http://blog.bglee.me/posts/2016/ohmyzsh/">설정 포스트</a> 을 설치하면 터미널에서 git status를 별다른 명령어 없이 바로 설정할 수 있다.</p><h2><span id="패키지-매니저-설치">패키지 매니저 설치</span></h2><p>debian의 <code>apt-get</code>이 있다면 여긴 <a href="http://brew.sh/index_ko.html" target="_blank" rel="noopener">brew</a>가 있다.<br>링크를 타고 가서 설치 스크립트를 복사해서 터미널에 붙이면된다.</p><ul><li>brew search [package name]</li><li>brew install [package name]</li></ul><p>개인적으로는 neovim을 에디터로 쓰므로 그에 따른 플러그인 환경을 셋업하다보면 대충 다음정도는 바로 깔아줘야한다. history에서 발췌한 몇가지는 아래와 같다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br><span class="line">brew install git-flow-avh</span><br><span class="line">brew install tree</span><br><span class="line">brew install python3</span><br></pre></td></tr></table></figure><p>이제 <code>node</code> 설치됐으니 <code>npm</code>을 통해 필요로 하는 셋업을 해주면된다.</p><h2><span id="생활-유틸리티">생활 유틸리티</span></h2><ul><li><a href="https://github.com/fikovnik/ShiftIt" target="_blank" rel="noopener">Shiftit</a> - open source로 키보드로 창 이동을 하게 해준다. <code>Windows</code> 유저였다면 <code>Window + 방향키</code> 느낌이라고 생각하면된다.</li><li>Numbers - 애플 버전 스프레드 시트다. 회사 생활하려면 엑셀은 열얼봐야한다.</li><li><a href="http://www.videolan.org/vlc/download-macosx.html" target="_blank" rel="noopener">vlc</a> - open source movie player. 가끔 개발을 위해 미디어 포맷을 확인한다거나(?) 생각없이 버그 잡으면서 영상 틀어놀때 필요하다.</li><li>yoink - 드래그로 파일 이동시에 워크스페이스(바탕화면 하나)를 넘어가는 경우에 발생하는 짜증을 감소시켜준다. 유료다.</li></ul><hr><p>이제 코드를 짜면 된다.</p>]]></content>
    
    <summary type="html">
    
      맥 북을 처음 쓴다면 꼭 이대로 하길 바라며 쓰는 글
    
    </summary>
    
      <category term="setup" scheme="http://blog.bglee.me/categories/setup/"/>
    
    
      <category term="맥북 셋업" scheme="http://blog.bglee.me/tags/%EB%A7%A5%EB%B6%81-%EC%85%8B%EC%97%85/"/>
    
      <category term="맥북 개발 환경 설정" scheme="http://blog.bglee.me/tags/%EB%A7%A5%EB%B6%81-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95/"/>
    
      <category term="osx 개발 환경" scheme="http://blog.bglee.me/tags/osx-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD/"/>
    
      <category term="맥북 설정" scheme="http://blog.bglee.me/tags/%EB%A7%A5%EB%B6%81-%EC%84%A4%EC%A0%95/"/>
    
  </entry>
  
  <entry>
    <title>React.js 프로 리액트</title>
    <link href="http://blog.bglee.me/posts/2016/book-pro-react/"/>
    <id>http://blog.bglee.me/posts/2016/book-pro-react/</id>
    <published>2016-07-21T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.623Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>React.js를 이용한 모던 프런트엔드 구축</p></blockquote><p>읽으면서 중요하다고 생각하는 것 몇 가지에 대한 정리</p><h3><span id="props-convention">Props convention</span></h3><p><code>onChange</code>등과 같이 camelCase가 사용되며 DOM API의 기준으로 element에 class등을 넣기 위해서는 <code>className</code> 프로퍼티가 대신 사용된다.</p><h3><span id="controlled-component와-un-controlled-component">Controlled Component와 Un Controlled Component</span></h3><p>둘을 나누는 차이는 가볍게 코드 상에서 props.value의 존재 유무라고 생각하면 된다.<br>value가 존재하면 이에 대한 제어를 위해 <code>onChange</code>와 같은 이벤트를 받아 state를 관리하게 된다. 이 말은 <code>Pure Component</code>가 아니라는 말과 의미가 통하는 부분이 있다.</p><h4><span id="controlled-component">Controlled Component</span></h4><p>Controlled Component는 <code>user action(click, typing 등)</code>에 의해서 변하는 상태 값을 <code>Component</code>가 핸들링한다.</p><h4><span id="un-controlled-component">Un Controlled Component</span></h4><p>상태값을 유지하지 않기 때문에 특정 시점에 Un Controlled Component 로 부터 데이터를 가져오는 작업이 필요하다. <code>value</code> prop이 사용되지 않기 때문에 기본 값 등의 셋업을 위해서는 <code>defaultValue</code>가 사용된다.</p><h3><span id="virtual-dom">Virtual DOM</span></h3><p>Virtual DOM을 통해 렌더링을 다시할 부분을 계산하게 되는데 이때 List형식의 DOM에 대해 insert, remove, move 등을 인지 할 수 없으므로 <code>key</code> 프로퍼티가 사용된다. 실무에서 적용할 때는 시간이 없어(?) <code>warning</code>을 지우기 위해 의미없는 index값을 대입했었으나 이 부분이 의미 있기 쓰이려면 List의 각 row가 가지고 있는 데이터의 매칭이 이루어져야 하므로 data의 <code>id</code>값 등을 넣어야한다.</p><h3><span id="shallow-copy">Shallow Copy</span></h3><p>React에서 컴포넌트의 렌더링에 대해 비교할 때 레퍼런스를 비교하게 되는 것으로 예상(?)하고 있는데 이에 대한 처리를 정확히 해서 렌더링을 줄여 퍼포먼스 향상을 위해 Shallow Copy를 이해할 필요가 있다. 이에 대한 처리를 위해 facebook에서 만든 <a href="https://facebook.github.io/immutable-js" target="_blank" rel="noopener">Immutable.js</a>이 있고 순수 자바스크립트처럼 사용이 가능한 <a href="https://github.com/rtfeldman/seamless-immutable" target="_blank" rel="noopener">seamless-immutable</a> 등의 구현체가 있으나 각각이 가지는 단점이 존재하여 단순한 큰 규모의 어플리케이션이 아니라면 얕은 복사에 대한 이해를 바탕으로 해결 할 수 있는 부분이 있을 것으로 보인다.</p><p>Object, Array등 레퍼런스등의 객체를 직접 수정하는 것이 아닌 새로운 객체를 대입하는 케이스가 <code>flux</code> 아키텍쳐에서는 자주 일어나는데 이를 위해 <code>Object.assign</code>, Array의 <code>map</code>, <code>concat</code>등의 메서드를 자주 사용하게 된다. 새로운 레퍼런스를 반환하지만 Array나 Object안에서 다른 Array나 Object를 포함하고 있다면 이에 대한 레퍼런스는 유지되게 된다. 이에 대한 이해가 있으면 될 것 같다.</p><h4><span id="관련-라이브러리">관련 라이브러리</span></h4><p><a href="https://facebook.github.io/react/docs/update.html" target="_blank" rel="noopener">react-addons-update</a></p><h3><span id="test">Test</span></h3><p>React에서는 test framework으로 <a href="https://facebook.github.io/jest/" target="_blank" rel="noopener">jest</a> 를 권장하고 있다.</p><h4><span id="관련-라이브러리">관련 라이브러리</span></h4><p><a href="https://facebook.github.io/react/docs/test-utils.html" target="_blank" rel="noopener">react-addons-test-utils</a></p><hr><h3><span id="etc">ETC</span></h3><p>이 외에도 Router(react router)와 flux(redux가 아닌) 자체, 서버 사이드 렌더링, 퍼포먼스 튜닝등의 내용을 담고 있다.</p>]]></content>
    
    <summary type="html">
    
      React.js 프로 리액트를 읽고 난 후기
    
    </summary>
    
      <category term="summary" scheme="http://blog.bglee.me/categories/summary/"/>
    
    
      <category term="pro react" scheme="http://blog.bglee.me/tags/pro-react/"/>
    
      <category term="프로 리액트" scheme="http://blog.bglee.me/tags/%ED%94%84%EB%A1%9C-%EB%A6%AC%EC%95%A1%ED%8A%B8/"/>
    
  </entry>
  
</feed>
