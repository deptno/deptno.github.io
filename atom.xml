<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>봉로그</title>
  
  <subtitle>봉지니어링</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.bglee.me/"/>
  <updated>2018-09-16T04:45:16.546Z</updated>
  <id>http://blog.bglee.me/</id>
  
  <author>
    <name>deptno@gmail.com</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>서버리스 프레임웍의 관리 이슈</title>
    <link href="http://blog.bglee.me/posts/2018/serverless-management-issue/"/>
    <id>http://blog.bglee.me/posts/2018/serverless-management-issue/</id>
    <published>2018-09-16T04:45:16.000Z</published>
    <updated>2018-09-16T04:45:16.546Z</updated>
    
    <content type="html"><![CDATA[<p><img src="serverless.png" alt="serverless"></p><p><span class="github-emoji" title="information_desk_person" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f481.png?v8">&#x1f481;</span> 서버리스, 정확히는 람다를 접한지도 2년정도가 되어가는 것 같다. 서버리스를 사용하면서 느꼈던 점을 조금은 정리하고자 한다. 서버리스에 대한 설명보다는 이를 활용하기 위한 프레임웍 그리고 문제등에 대해서 언급하고자 한다.</p><p>AWS 람다(Lambda)로 대두된 서버리스가 강점으로 내세우는 것 중 하나는 관리다. 사용한 만큼만 돈을 지불하는 구조도 매우 유리하며 스케일링에 대한 걱정도 없으므로 좋은점이 많다. 그러나 함수 한두개로 서비스가 작성되는 것은 아니니 많은 함수를 어떻게 유연하게 배포하는가는 또 다른 차원의 이슈로 남아있다.</p><h2><span id="서버리스-프레임워크">서버리스 프레임워크</span></h2><p>아쉽지만 개발에 대한 패러다임 변화가 일어났을 때 필요한 프레임워크에는 국산이 없는 것 같다. 시니어 개발자들이 자체 인프라를 가지고 있는 곳에서 일하는 점과 영어가 또 이를 힘들게 하는 한가지 이유이리라.</p><p>몇 가지 서버리스를 관리하기 위한 프레임워크가 존재하며 여기에는 배포가 중심이 된다. 기억이 안나는 이름까지 억지로 적을 생각은 없다. 사용해 온 프레임워크을 기준으로 말하겠다.</p><h3><span id="apex">Apex</span></h3><p>TJ에 의해 Go언어로 작성되었다. 내 첫 서버리스 프로젝트는 <code>apex</code> 를 통해 배포를 하려했다.</p><p><code>apex</code> 는 테라폼(<code>terraform</code>) 을 통해 인프라 스트럭쳐 레벨을 제어한다. 이는 매우 훌륭한 선택이었다고 생각한다. TJ는 스타개발자지만 조직이 아닌 개인 레벨(그것도 바쁜 개인)을 통해 운영되는데 대한 불안함이 있었다.</p><p>결론적으로 나는 빠르게 <code>serverless</code> 라는 서버리스 브랜드 네이밍을 선점한 프레임워크로 이주했다. <code>apex</code> 가 때로는 응답없음 등을 보이는데 이때 인프라스트럭쳐가 어떻게 배포되었는가 등에 정보를 얻기 어려웠기 때문이다.</p><h3><span id="serverless">Serverless</span></h3><p>현재까지 사용하고 있는 프레임워크이다. 서버리스는 클라우드 포메이션(Cloud Formation)을 기반으로 동작하는데 개인적으로 이 부분이 문제가 된다고 느낀다. 유연성이 상당히 떨어지며 생성된 리소스를 가지고 외부에서 수정을 가했을 때 배포환경이 깨진다거나 하는 것이 그 것인데 이는 아래서 충분히 다시 얘기하기로 한다.</p><h4><span id="문제점">문제점</span></h4><h5><span id="최근에-이를-사용하면서-많은-생각이-들었는데-일단-플러그인을-코어-레벨로-가져갈때-생기는-문제점이다">최근에 이를 사용하면서 많은 생각이 들었는데 일단 플러그인을 코어 레벨로 가져갈때 생기는 문제점이다.</span></h5><blockquote><p><span class="github-emoji" title="speech_balloon" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4ac.png?v8">&#x1f4ac;</span> 나는 <code>vim</code> 을 사용하는데 이를 GUI 에디터 수준으로 활용하기 위해서는 많은 플러그인 세팅이 필요하며 엄청난 시간이 소요된다. 때론 많은 플러그인간의 종속성 이슈가 발생하기도 하며 이러한 플러그인 이슈가 코어 기능을 깨버리기도 한다.</p></blockquote><p>무엇을 작성하던 로컬테스트는 필수이기 때문에(서버리스는 배포 자체가 <code>s3</code> 를 사용하기 때문에 비용이다) <code>serverless-offline</code> 그리고 <code>serverless-webpack</code>이 들어가게 될텐데 이들의 실제 서버의 동작을 완벽하게 지원하지 못하는 점은 차치하고 함수가 늘어날 수록 디펜던시가 늘어감에 따라 기하급수적으로 느려지게 된다는 점이다. 게다가 내 로컬 설정 이슈인지는 모르겠으나 무언가를 하다보면 HMR이 일어나는 도중 로컬 서버가 죽어버린다(글을 적다보니 웹스톰의 메모리 이슈일 수도 있겠다는 생각 <span class="github-emoji" title="thinking" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f914.png?v8">&#x1f914;</span>). 오래걸리는 죽으면 다시 켜야하고 키면 오래걸리는 악순환에 빠져버렸다.</p><h5><span id="클라우드-포메이션-기반">클라우드 포메이션 기반</span></h5><p><code>apex</code> 가 테라폼 기반인 것과 달리 <code>serverless</code> 는 클라우드 포메이션을 기반으로 한다.</p><blockquote><p><span class="github-emoji" title="information_desk_person" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f481.png?v8">&#x1f481;</span> 클라우드 포메이션은 AWS에 자체적으로 지원하는 템플릿이다. 잘은 모르지만 스택에 이름을 부여하고 필요한 리소스를 선언한 템플릿 문법을 통해 종속성을 포함하여 서비스에 필요한 구조등을 한번에 배포할 수 있게 해주며 그대로 삭제 또한 가능하다. 때문에 세미나나 튜토리얼 등에서 자주 쓰인다.</p></blockquote><p>여기서 많은 단점들이 생긴다고 생각하는데 이 부분을 우회할 방법등이 있을지 모른다. 그럼 단점들을 나열하고 고통에 대해서 이야기해본다.</p><ul><li><p>리소스가 <code>serverless.yml</code> 을 통해 생성되어야 참조가 가능하다.</p><p>서비스 전체를 서버리스로 캡슐화 할 수 없다. 이 말은 공통으로 사용하는 디비 등도 <code>serverless</code> 등을 통해서 선언 되어야한다는 의미이며 <code>serverless</code> 를 통해서 전체 서비스를 제어하지 않는 한 디비가 이 곳에 있어서는 안된다.</p></li><li><p>생성된 리소스를 외부(웹 콘솔 등)을 통해 변경된 경우 오류를 발생 시킨다.</p><p>이건 클라우드 포메이션 이슈로 보인다. 더러운건 마찬가지나 테라폼은 <code>import</code> 명령등을 통해 변경 내역 흡수가 가능하다. 가능과 불가능에 대한 엄청난 차이가 있다.</p></li><li><p><code>serverless.yml</code> 의 <code>resource</code> 문법은 클라우드 포매이션 문법 그 자체다.</p><p><code>serverless</code> 는 자체 <code>yml</code> 설정 문법을 가지고 있다. 결국 <code>yaml</code> 은 <code>json</code> 이므로 클라우드 문법을 그대로 차용하는데 이는 오히려 러닝커브를 낮출 수 있는 방법이라고도 생각되나 결국 <code>serverless</code> 를 사용하기 위해 뭐하나 피해갈 것이 없다는 느낌이다. 그에 반해 테라폼은 <code>hcl</code> 이라는 <strong>hashcorp</strong> 자체 언어를 사용하지만 이는 <strong>hashcorp</strong> 여러 서비스의 언어에서 공통으로 쓰이며 좀 더 언어 레벨에 가깝다.</p><p><code>hcl</code> 이 구조를 갖춘 언어 레벨이라고 한다면 <code>serverelss.yml</code> 은 설정 파일로 시작했으나 이로는 모두 커버가 안되니 템플릿 엔진과 같이 특수한 토큰이 들어간 불리한 구조다. 여기서 오는 혼란 또한 존재한다.</p></li><li><p>플러그인의 복잡성</p><p>플러그인의 구현 자체는 매우 쉽게 되어 있다. 최근 문서를 보니 플러그인에서 서브 커맨드들이 파라메터를 받는 것을 제한하기 시작한 것으로 보이며 이 때문에 플러그인의 유연성이 희생되고 있다. 이렇한 방향이 설정되는 이유는 이 유연선이 코어에 간섭이 있기 때문이리라 예상한다. <code>serverelss.yml</code> 의 <code>custom</code> 속성을 통해 제어는 가능하다.</p></li><li><p>함수의 재사용 불가</p><p>타 서비스에 동일한 <code>custom authorizer</code> 를 사용한다고 했을 때 이 함수를 다시 복사, 붙여넣기 하는 방법에외는 방법이 없다. 함수가 다르게 배포되서 당연한 얘기인 듯 싶지만 이를 모듈화하여 배포하기에도 어려움이 있다. 그래서 최근에는 <strong>Serverless Component</strong> 는 프로젝트가 4월경에 시작되었다.</p></li></ul><p>또한 많은 플러그인들이 있으나 이 들에 대한 관리 주체 또한 다양하며 수준 또한 다양하다. 플러그인 체제라는 것이 항상 그러하듯.</p><h3><span id="프레임웍은-무엇을-해결해야-하는가">프레임웍은 무엇을 해결해야 하는가</span></h3><p><code>serverless</code>, <code>apex</code> 등은 같은 목적을 가지고 태어나 다른 방식을 취했다.</p><h4><span id="todo">ToDo</span></h4><p>해야할일을 정의해본다면 기본은 어렵지 않다. <code>Lambda</code> 는 어렵게 시작하지 않았다. 람다의 시작은 웹 콘솔에가서 <code>async/await</code> 도 지원하는 <code>node8</code> 기반으로 <code>index.js</code> 파일하나 짜면 돌아가게 되어있다. 물론 서비스 레벨에서 이 것 만으로는 할 수 있는 것이 별로 없으므로 많은 다른 모듈을 포함하게 되며 이를 통해 <code>zip</code> 파일을 <code>s3</code> 에 올리고 배포하는 것이 일반적이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 코드작성 | 빌드 | zip | 배포 | 이전코드 삭제</span></span><br></pre></td></tr></table></figure><p>대충 이런 파이프 라인이다. 여기에는 <code>IAM</code> 설정등에 대한 추가적인 것들이 선언 되어야한다. 한 곳에 모아야 관리가 쉽고 준비가 안된상태에서 한 곳에 모으면 유연성이 파괴된다. 쉽지 않지만 이 문제를 해결해야하는 것이 프레임웍인데 현재는 조금 아쉬운 점이 있다.</p><h4><span id="아쉽다">아쉽다.</span></h4><p>위에서 주로 사용하는 <code>serverless</code> 를 위주로 단점을 나열했지만 <code>serverelss</code> 는 그런 프레임워크들 중에서도 <strong>살아남은</strong> 케이스다. 플러그인을 통해 유연성을 제공했고 플러그인 또한 설정이 필요하기에 <code>serverelss.yml</code> 에서는 <code>custom</code> 속성을 통해 이런 추가적인 설정을 지원하고 있다.</p><h4><span id="잘-생각해보면">잘 생각해보면</span></h4><p>잘 생각해보면 플러그인을 잘 짜서 내가사용하는 TypeScript와 노드에서 더 빛을 발할 수 있고 간단해 보이는 <code>rollup.js</code> 등을 이용해서 최적화를 할 수 있는 것 같기도 하다.</p><p>또한 <code>serverless-offline</code> 에서 웹팩을 구지 먹고 들어가서 빌드 속도를 현저히 다운시켜야하는가에 대한 고민도 어찌보면 <code>serverless</code> 가 아닌 플러그인 종속 이슈로 볼 수도 있다. 어쨋거나 이러한 점은 로컬 개발환경에서의 생산성을 극도로 저하시키며 자바<strong>스크립트</strong> 가 언제부터 이런 긴 컴파일 시간을 필요로하게 되었는가 생각해보게 한다. 코드 자체도 Go한테 밀리는데 생산성까지 밀리면 공부 이슈를 제외하고는 Go로 넘어가지 않을 이유가 무엇인가? <span class="github-emoji" title="thinking" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f914.png?v8">&#x1f914;</span></p><p>하지만 이런 것은 자바스크립트 자체가 아닌 프레임웍과 그 플러그인에 대한 이슈이며 좀 더 최적화를 해볼 생각도 있지만 결국 <strong>클라우드 포메이션</strong> 기반이라는 한계, 즉 디 디비와 종속성 이슈등을 풀어낼 수 있는가? 하면 꽤나 회의적이다.</p><h2><span id="결론없는-마무리">결론없는 마무리</span></h2><p>일단은 앞으로 가야하기 때문에 이 모든 비효율을 감당하고 있다. <code>serverless</code> 에 대한 비난글이 아니다. 덕분에 여기 까지 왔다. 단지 좀 더 큰 규모의 함수들을 제어하기 위해 <code>serverelss</code> 는 그 것을 감당하기 위한 효율성이 있는 토대를 가지고 있는가에 대해 고민하게 된다. 결국 인프라쪽 코드가 섞이면 피해갈 수 없는 영역이 있지만 테라폼 같은 경우는 하나의 <strong>언어</strong> 이기 때문에 코드 어시스트라도 받을 수 있지만 서버리스는 잘 모르겠다. 내가 모르는 것인지.</p><p>시간이 날 떄 좀 더 최적화된 배포환경에 대한 욕심이 난다. <span class="github-emoji" title="speech_balloon" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4ac.png?v8">&#x1f4ac;</span> ?</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;serverless.png&quot; alt=&quot;serverless&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;github-emoji&quot; title=&quot;information_desk_person&quot; data-src=&quot;https://assets-cdn
      
    
    </summary>
    
    
      <category term="lambda" scheme="http://blog.bglee.me/tags/lambda/"/>
    
      <category term="serverless" scheme="http://blog.bglee.me/tags/serverless/"/>
    
      <category term="apex" scheme="http://blog.bglee.me/tags/apex/"/>
    
      <category term="cloud formation" scheme="http://blog.bglee.me/tags/cloud-formation/"/>
    
  </entry>
  
  <entry>
    <title>probot</title>
    <link href="http://blog.bglee.me/posts/2018/probot/"/>
    <id>http://blog.bglee.me/posts/2018/probot/</id>
    <published>2018-08-30T15:31:54.000Z</published>
    <updated>2018-08-30T15:31:54.943Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="프로봇">프로봇</span></h2><p>프로봇은 깃헙 앱을 만들기 위한 프레임워크다. <code>yarn</code>, <code>typescript</code> 세팅을 기준으로 진행한다. 빠르게 튜토리얼을 훑는 것 그 이상도 이하도 아니다. 설치부터 시작하자.</p><h3><span id="설치">설치</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn init -y</span><br><span class="line">yarn add -D create-probot-app</span><br><span class="line">yarn create probot-app --typescript deptno-bot</span><br></pre></td></tr></table></figure><p>프로봇은 타입스크립트로 짜여져 있으며 타입스크립트 템플릿을 지원한다 <code>--typescript</code> 옵션을 주면 타입스크립트로 생성된다.</p><p>잘되면 아래와 같이 결과가 나온다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">yarn create v1.9.4</span><br><span class="line">[1/4] 🔍  Resolving packages...</span><br><span class="line">[2/4] 🚚  Fetching packages...</span><br><span class="line">[-------------------------------------------------------------------------------------------------------------] 0/291(node:30558) [DEP0005] DeprecationWarning: Buffer() is deprecated due to security and usability issues. Please use the Buffer.alloc(), Buffer.allocUnsafe(), or Buffer.from() methods instead.</span><br><span class="line">[3/4] 🔗  Linking dependencies...</span><br><span class="line">[4/4] 📃  Building fresh packages...</span><br><span class="line">success Installed <span class="string">"create-probot-app@2.3.0"</span> with binaries:</span><br><span class="line">      - create-probot-app</span><br><span class="line">[<span class="comment">###########################################################################################################] 296/296Let's create a Probot app!</span></span><br><span class="line">? App name: deptno-bot</span><br><span class="line">? Description of app: A Probot app</span><br><span class="line">? Author<span class="string">'s full name: Bonggyun Lee</span></span><br><span class="line"><span class="string">? Author'</span>s email address: deptno@gmail.com</span><br><span class="line">? Homepage: https://bglee.me</span><br><span class="line">? GitHub user or org name: deptno</span><br><span class="line">? Repository name: deptno-bot</span><br><span class="line">created file: /Users/bglee/tmp/probot/deptno-bot/.env.example</span><br><span class="line">created file: /Users/bglee/tmp/probot/deptno-bot/.gitignore</span><br><span class="line">created file: /Users/bglee/tmp/probot/deptno-bot/.travis.yml</span><br><span class="line">created file: /Users/bglee/tmp/probot/deptno-bot/CODE_OF_CONDUCT.md</span><br><span class="line">created file: /Users/bglee/tmp/probot/deptno-bot/CONTRIBUTING.md</span><br><span class="line">created file: /Users/bglee/tmp/probot/deptno-bot/LICENSE</span><br><span class="line">created file: /Users/bglee/tmp/probot/deptno-bot/README.md</span><br><span class="line">created file: /Users/bglee/tmp/probot/deptno-bot/jest.config.js</span><br><span class="line">created file: /Users/bglee/tmp/probot/deptno-bot/package.json</span><br><span class="line">created file: /Users/bglee/tmp/probot/deptno-bot/tsconfig.json</span><br><span class="line">created file: /Users/bglee/tmp/probot/deptno-bot/.github/CODEOWNERS</span><br><span class="line">created file: /Users/bglee/tmp/probot/deptno-bot/src/index.ts</span><br><span class="line">created file: /Users/bglee/tmp/probot/deptno-bot/<span class="built_in">test</span>/index.test.ts</span><br><span class="line">Finished scaffolding files!</span><br><span class="line"></span><br><span class="line">Installing Node dependencies!</span><br><span class="line">npm WARN deprecated istanbul-lib-hook@1.2.1: 1.2.0 should have been a major version bump</span><br><span class="line"></span><br><span class="line">&gt; dtrace-provider@0.8.7 install /Users/bglee/tmp/probot/deptno-bot/node_modules/dtrace-provider</span><br><span class="line">&gt; node-gyp rebuild || node suppress-error.js</span><br><span class="line"></span><br><span class="line">  ACTION binding_gyp_ndtp_target_build_ndtp .</span><br><span class="line">  TOUCH Release/obj.target/ndtp.stamp</span><br><span class="line"></span><br><span class="line">&gt; fsevents@1.2.4 install /Users/bglee/tmp/probot/deptno-bot/node_modules/fsevents</span><br><span class="line">&gt; node install</span><br><span class="line"></span><br><span class="line">[fsevents] Success: <span class="string">"/Users/bglee/tmp/probot/deptno-bot/node_modules/fsevents/lib/binding/Release/node-v64-darwin-x64/fse.node"</span> already installed</span><br><span class="line">Pass --update-binary to reinstall or --build-from-source to recompile</span><br><span class="line"></span><br><span class="line">&gt; nodemon@1.18.4 postinstall /Users/bglee/tmp/probot/deptno-bot/node_modules/nodemon</span><br><span class="line">&gt; node bin/postinstall || <span class="built_in">exit</span> 0</span><br><span class="line"></span><br><span class="line">npm notice created a lockfile as package-lock.json. You should commit this file.</span><br><span class="line">added 994 packages from 638 contributors and audited 19455 packages <span class="keyword">in</span> 17.196s</span><br><span class="line">found 0 vulnerabilities</span><br><span class="line"></span><br><span class="line">Done! Enjoy building your Probot app!</span><br><span class="line">✨  Done <span class="keyword">in</span> 35.46s.</span><br></pre></td></tr></table></figure><p>이제 디렉토리로 진입해보자. <code>yarn create</code> 를 통해 생성했는데도 불구하고 왠 <code>package-lock.json</code> 이.. <span class="github-emoji" title="thinking" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f914.png?v8">&#x1f914;</span></p><h3><span id="smeeio-설정">smee.io 설정</span></h3><p>웹훅을 받으려면 외부에서 접근 가능한 <code>url</code> 이 필요한데 공식 문서에 <code>smee.io</code> 가 언급되어있다. <code>ngrok</code>, <code>localtunnel.me</code> 등도 있는데 레코딩 기능과 그를 기반으로 이전 이벤트를 다시 쏴주는등 편리한 기능을 제공해주는 것 같다. 매우 좋다. <span class="github-emoji" title="laughing" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f606.png?v8">&#x1f606;</span></p><p><a href="https://smee.io" target="_blank" rel="noopener">https://smee.io</a> 에 접속해서 채널을 생성하면 <code>url</code> 이 나오는데 이 <code>url</code> 을 <code>.env</code> 파일에 넣어준다. 아래와 같은 모습이된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WEBHOOK_PROXY_URL=https://smee.io/vqI8f2rWzvqAef</span><br></pre></td></tr></table></figure><h4><span id="프록시-연결">프록시 연결</span></h4><p>프록시는 방금 생성했으니 이 곳에 접속해서 훅을 로컬로 돌려야한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --global smee-client</span><br><span class="line">smee -u https://smee.io/vqI8f2rWzvqAef</span><br></pre></td></tr></table></figure><p>글로벌 인스톨은 <code>npm</code> 을 통해서 하고 있어서 <code>npm</code> 을 통해 설치했다.</p><p><code>smee -u {PROXY_URL}</code> 을 실행해서 프록시에 연결한다. <code>PROXY_URL</code> 은 당연히 생성한 채널의 <code>url</code> 이다.</p><h3><span id="깃헙-앱-생성">깃헙 앱 생성</span></h3><p><a href="https://github.com/settings/apps/new" target="_blank" rel="noopener">https://github.com/settings/apps/new</a> 에 들어가서 이제 새 <code>Github App</code> 을 생성해보자.</p><p><code>Webhook URL</code> 에는 <code>smee.io</code> 를 통해 생성한 <code>URL</code> 을 들고와야한다.</p><p><span class="github-emoji" title="warning" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/26a0.png?v8">&#x26a0;</span> <code>Webhook secret</code> 이 옵셔널로 되어 있지만 반드시 줘야한다. <code>.env</code> 파일과 짝을 이뤄야하므로 <code>development</code> 를 넣어준다.</p><p><img src="github-app-setting.png" alt="github-app-setting"></p><p>퍼미션이나 받고자 하는 훅은 본인이 선택하면 된다. <code>Watch</code> 를 통해 스타를 받는 것이 테스트하기 편해 보여 아래와 같이 설정했다. 또 타인이 설치할 수도 있도록 <code>Any acount</code> 를 선택했다.</p><p><span class="github-emoji" title="information_desk_person" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f481.png?v8">&#x1f481;</span> 이 부분은 원하는 이벤트에 따라 달라지니 필요한 이벤트는 선택해두자.</p><p><img src="permission.png" alt="permission"></p><p>그럼 상단에 키를 생성하라고 배너가 뜬다. 링크를 눌러 생성하자</p><p><img src="generate-key-banner.png" alt="generate-key-banner"></p><p><code>Generate a private key</code> 를 누르면 바로 <code>pem</code> 파일이 다운로드 되는데 이를 프로젝트 루트(<code>/</code>) 에 넣어두자 이름은 상관없이 인식하겠다고 문서에 적혀있다.</p><p><img src="generate-a-private-key.png" alt="generate-a-private-key-5640212"></p><h3><span id="깃헙-앱-설치">깃헙 앱 설치</span></h3><p>그럼 메뉴에서 <code>Install</code> 을 할 수 있게 되며 해보자.</p><p><img src="install-bot.png" alt="install-bot"></p><p>아까 설정한 대로 퍼미션을 요구한다 <code>All repositories</code> 는 부담스러운으므로 테스트하기 편한 레포지터리를 넣었다.</p><p><img src="install-bot-permission.png" alt="generate-a-private-key"></p><p>블로그 글을 쓰면서 함께 테스트하고자 <code>deptno/blog</code> 레포를 추가적으로 선택하고 <code>Save</code> 했다.</p><p><img src="select-repo.png" alt="select-repo"></p><p>앱 생성후 나오는 ID는 <code>.env</code> 파일의 <code>APP_ID</code> 에 넣어줘야한다.</p><h2><span id="개발">개발</span></h2><p>이제 깃헙 앱도 생성하고 했으니 실제 코드를 작성해보자. 일단 모든 이벤트에대해서 로그를 찍는다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">  app.on(<span class="string">`*`</span>, <span class="keyword">async</span> context =&gt; &#123;</span><br><span class="line">    context.log(&#123;event: context.event, action: context.payload.action&#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>타입스크립트의 경우 <code>yarn build</code> 를 통해 빌드를 실행해야만 <code>yarn dev</code> 가 성공한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn build</span><br><span class="line">yarn dev</span><br></pre></td></tr></table></figure><p>문서를 따라가다가 아차했는데 서버를 켜보니 <code>smee.io</code> 쪽에서 이벤트를 킵하고 있다가 순차적으로 보내주는 것으로 보인다. 때문에 이전에 앱을 설치하면서 했던 이벤트는 모두 기록되어 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ nodemon --<span class="built_in">exec</span> <span class="string">"npm start"</span></span><br><span class="line">[nodemon] 1.18.4</span><br><span class="line">[nodemon] to restart at any time, enter `rs`</span><br><span class="line">[nodemon] watching: *.*</span><br><span class="line">[nodemon] starting `npm start`</span><br><span class="line"></span><br><span class="line">&gt; deptno-bot@1.0.0 start /Users/bglee/workspace/src/github.com/deptno/probots/packages/deptno-bot</span><br><span class="line">&gt; probot run ./lib/index.js</span><br><span class="line"></span><br><span class="line">14:37:55.588Z  INFO probot: Yay, the app was loaded!</span><br><span class="line">14:37:55.693Z  INFO probot: Forwarding https://smee.io/vqI8f2rWzvqAef to http://localhost:3000/</span><br><span class="line">14:37:55.695Z  INFO probot: Listening on http://localhost:3000</span><br><span class="line">14:37:56.411Z DEBUG github: GitHub request: GET /app/installations - 200 OK (installation=undefined)</span><br><span class="line">  params: &#123;</span><br><span class="line">    <span class="string">"per_page"</span>: 100,</span><br><span class="line">    <span class="string">"baseUrl"</span>: <span class="string">"https://api.github.com"</span>,</span><br><span class="line">    <span class="string">"request"</span>: &#123;</span><br><span class="line">      <span class="string">"timeout"</span>: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">14:37:56.641Z  INFO probot: Connected https://smee.io/vqI8f2rWzvqAef</span><br><span class="line">14:37:56.981Z DEBUG github: GitHub request: POST /installations/:installation_id/access_tokens - 201 Created (installation=312381)</span><br><span class="line">  params: &#123;</span><br><span class="line">    <span class="string">"installation_id"</span>: <span class="string">"312381"</span>,</span><br><span class="line">    <span class="string">"baseUrl"</span>: <span class="string">"https://api.github.com"</span>,</span><br><span class="line">    <span class="string">"request"</span>: &#123;</span><br><span class="line">      <span class="string">"timeout"</span>: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">14:37:57.896Z DEBUG github: GitHub request: GET /installation/repositories - 200 OK (installation=312381)</span><br><span class="line">  params: &#123;</span><br><span class="line">    <span class="string">"per_page"</span>: 100,</span><br><span class="line">    <span class="string">"baseUrl"</span>: <span class="string">"https://api.github.com"</span>,</span><br><span class="line">    <span class="string">"request"</span>: &#123;</span><br><span class="line">      <span class="string">"timeout"</span>: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>이제 선택했던 레포에 스타를 줘보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">14:57:26.636Z DEBUG probot: Webhook received</span><br><span class="line">  event: &#123;</span><br><span class="line">    <span class="string">"event"</span>: <span class="string">"watch.started"</span>,</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"02398ac0-ac65-11e8-9164-6e525ac149cd"</span>,</span><br><span class="line">    <span class="string">"installation"</span>: 312381,</span><br><span class="line">    <span class="string">"repository"</span>: <span class="string">"deptno/readi.sh"</span></span><br><span class="line">  &#125;</span><br><span class="line">14:57:26.643Z  INFO event:  (id=02398ac0-ac65-11e8-9164-6e525ac149cd, event=watch, action=started)</span><br><span class="line">14:57:26.644Z  INFO http: POST / 200 - 8.38 ms (id=160f481c-e579-4c1a-a3e9-6dc3dd61d266)</span><br><span class="line">14:57:26.644Z  INFO probot: POST http://localhost:3000/ - 200</span><br><span class="line">14:57:26.645Z DEBUG probot: Webhook received</span><br><span class="line">  event: &#123;</span><br><span class="line">    <span class="string">"event"</span>: <span class="string">"watch.started"</span>,</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"02398ac0-ac65-11e8-9164-6e525ac149cd"</span>,</span><br><span class="line">    <span class="string">"installation"</span>: 312381,</span><br><span class="line">    <span class="string">"repository"</span>: <span class="string">"deptno/readi.sh"</span></span><br><span class="line">  &#125;</span><br><span class="line">14:57:26.648Z  INFO event:  (id=02398ac0-ac65-11e8-9164-6e525ac149cd, event=watch, action=started)</span><br><span class="line">14:57:26.649Z  INFO http: POST / 200 - 3.96 ms (id=160f481c-e579-4c1a-a3e9-6dc3dd61d266)</span><br></pre></td></tr></table></figure><p><span class="github-emoji" title="thinking" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f914.png?v8">&#x1f914;</span> 왜 이벤트가 중복으로 오는지는 모른다. <code>smee.io</code> 문제이리라… 일단 확인했다.</p><p><span class="github-emoji" title="information_desk_person" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f481.png?v8">&#x1f481;</span> 이벤트를 로깅하려고 <code>context.log(JSON.stringify(context))</code> 등을 사용했으나 <code>smee.io</code>가 친절하게 다 보여준다.</p><p><img src="json-view.png" alt="json-view"></p><p>반갑게도 <a href="https://github.com/deptno/dynamon" target="_blank" rel="noopener">다이나몬</a> 만들때 그 <code>JSON view</code> 다. <span class="github-emoji" title="slightly_smiling_face" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f642.png?v8">&#x1f642;</span></p><p>여기서 기약은 없지만 1차를 마친다. 개인적인 정리중에 가장 기억안나는게 셋업이라 이 부분을 정리했다. 첨언하자면 <code>context</code> 객체에 <code>github</code> 을 통해 인증된 권한을 가지고 이슈등을 생성할 수 있다.(맞는 퍼미션에 맞게)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;프로봇&quot;&gt;프로봇&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;프로봇은 깃헙 앱을 만들기 위한 프레임워크다. &lt;code&gt;yarn&lt;/code&gt;, &lt;code&gt;typescript&lt;/code&gt; 세팅을 기준으로 진행한다. 빠르게 튜토리얼을 훑는 것 그 이상
      
    
    </summary>
    
    
      <category term="github" scheme="http://blog.bglee.me/tags/github/"/>
    
      <category term="probot" scheme="http://blog.bglee.me/tags/probot/"/>
    
      <category term="app" scheme="http://blog.bglee.me/tags/app/"/>
    
      <category term="github app" scheme="http://blog.bglee.me/tags/github-app/"/>
    
      <category term="oauth app" scheme="http://blog.bglee.me/tags/oauth-app/"/>
    
      <category term="github webhook" scheme="http://blog.bglee.me/tags/github-webhook/"/>
    
  </entry>
  
  <entry>
    <title>AWS 다이나모디비 정렬</title>
    <link href="http://blog.bglee.me/posts/2018/dynamodb-query-order/"/>
    <id>http://blog.bglee.me/posts/2018/dynamodb-query-order/</id>
    <published>2018-08-28T10:15:38.000Z</published>
    <updated>2018-08-28T10:15:38.856Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="aws-dynamodb-query-order">AWS DynamoDB query order</span></h2><blockquote><p><strong>미션</strong> 전체 데이터를 최근순으로 가져온다. <span class="github-emoji" title="ram" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f40f.png?v8">&#x1f40f;</span></p></blockquote><h4><span id="다이나모디비의-키-구성">다이나모디비의 키 구성</span></h4><p>다이나모디비는 필수적인 해시키와 추가적으로 정렬키를 할당해서 기본키를 이룰 수 있다.</p><h4><span id="scan-vs-query">Scan vs Query</span></h4><p>스캔은 모든 항목을 읽어온다. 그 중간에 필터를 걸어서 원하는 것 만을 뽑아 올 수 있지만 기본적으로 모든 다큐먼트(레코드)를 검색하기에 그만큼의 비용이 소모된다.</p><p>필터는 가능하지만 <strong>정렬</strong>은 가능하지 않ㄴ다.</p><h3><span id="query">Query</span></h3><p>때문에 정렬을 위해서는 Query를 통해서 데이터를 가져와한다. 쿼리는 기본인자로 해시키를 받는다. 정렬은 정렬키를 통해서 이루어지는데 해시키를 주게되면 데이터셋이 한정되므로 <strong>데이터 전체</strong>에 대한 정렬을 원하는 내게 원하는 동작은 아니다.</p><p>때문에 이를 위해선 꽤 번거로운 작업을 필요로 한다. 내가 찾은 방법은 <strong>GSI</strong>를 이용하는 방법이다. 인덱스의 형식에는 GSI와 LSI가 존재한다.</p><h4><span id="global-secondary-indexgsi-vs-local-secondary-indexlsi">Global Secondary Index(GSI) vs Local Secondary Index(LSI)</span></h4><p>GSI와 LSI의 차이는 기본적으로 해시키를 테이블 정의시의 해시키를 그대로 활용하고 정렬키만 바꾸는가 아니면 해시키까지 다시 정의하는 가에 대한 차이가 있다.</p><h3><span id="query-x1f46d-gsi">Query <span class="github-emoji" title="two_women_holding_hands" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f46d.png?v8">&#x1f46d;</span> GSI</span></h3><p>다시 쿼리로 돌아와서 미션을 해결하고자 GSI를 생성했다. 쿼리에서는 기본적으로 해쉬키를 건내야한다. 쿼리를 날리기 위한 데이터셋을 정의하는 행동인데 전체로하므로 어글리하게도 상수 값을 속성하나에 할당하기로 한다. 예를들어 <code>sort</code> 라는 속성을 해시키로 할당하고 모든 도큐먼트(record)에 대해서 동일한 값을 줘서 전체를 데이터셋으로 만드는 내용이다.</p><h4><span id="gsi-생성">GSI 생성</span></h4><p><img src="create-gsi.png" alt="create-gsi"></p><p>그럼 GSI를 생성하기 위해 다이나모 테이블에서 <strong>인덱스</strong>를 선택하고 GSI를 생성한다. 해쉬값에는 위에서 얘기한데로 <code>sort</code>라는 이름을 주고 타입을 <code>번호</code>로 설정했다. 바이너리로 설정하니 <code>aws-sdk</code>의 <code>DynamoDBClient</code> 에서 접근하기가 어려웠다.</p><p>정렬키에는 정렬의 기준이 되고자 하는 속성을 선택해야한다. <code>createAt</code> 등등 사용하고 있는 이름이 있을거다. 난 <code>date</code> 였다. 때문에 <code>date</code> 를 넣고 그에 맞는 속성을 줬다. 난 <code>번호</code> 였다.</p><p>생성에는 5분정도 시간이 걸렸던 것 같다. 기존 데이터의 양과 프로비저닝된 용량에 따라 시간이 더 소모될 수 있다.</p><p>인덱스의 이름은 편할 걸 넣어주면된다. 아래서 작성 할 코드에서는 <strong>PascalCase</strong> 형식으로 이름을 작성했다.</p><h4><span id="데이터를-추가">데이터를 추가</span></h4><p>데이터를 추가할때 <code>sort: 0</code> 이 반드시 추가되야한다. 그래야지만 인덱싱이 가능하다. <code>0</code>은 우리가 <code>번호</code> 타입을 설정했고 모든 데이터를 묶기 위해 동일한 숫자로 선택했을 뿐 다른 의미는 없다.</p><p>기존 데이터들이 있다라면 모두 업데이트를 쳐줘야한다. <span class="github-emoji" title="cloud_with_lightning_and_rain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/26c8.png?v8">&#x26c8;</span></p><h4><span id="code">Code</span></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> AWS <span class="keyword">from</span> <span class="string">'aws-sdk'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> EDyanmoDBTable &#123;</span><br><span class="line">  User    = <span class="string">'User'</span>,</span><br><span class="line">  Post    = <span class="string">'Post'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> EDyanmoDBGSI &#123;</span><br><span class="line">  SortDate = <span class="string">'SortDate'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ddbClient = <span class="keyword">new</span> AWS.DynamoDB.DocumentClient()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> queryPosts = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ddbClient</span><br><span class="line">    .query(&#123;</span><br><span class="line">      TableName: EDyanmoDBTable.Post,</span><br><span class="line">      IndexName: EDyanmoDBGSI.SortDate,</span><br><span class="line">      ScanIndexForward: <span class="literal">false</span>,</span><br><span class="line">      KeyConditionExpression: <span class="string">"#sort = :sort"</span>,</span><br><span class="line">      ExpressionAttributeNames: &#123;</span><br><span class="line">        <span class="string">"#sort"</span>: <span class="string">"sort"</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      ExpressionAttributeValues: &#123;</span><br><span class="line">        <span class="string">":sort"</span>: <span class="number">0</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    .promise()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="scanindexforward">ScanIndexForward</span></h5><p>이 파라메터를 통해 오름차순(<code>true</code> default)과 내림차순(<code>false</code>)이 결정된다. 정렬은 정렬키를 통해서 이루어지므로 코드에는 명시되지 않았지만 <code>IndexName</code> 을 통해 <code>date</code> 정렬키를 보유한 인덱스를 가리키고 있다.</p><h3><span id="x26a0-주의할-점"><span class="github-emoji" title="warning" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/26a0.png?v8">&#x26a0;</span> 주의할 점</span></h3><p>테이블이 생성되었고 GSI를 생성하기 전에 <code>sort: number</code> 형식으로 데이터를 이미 생성했다고 가정해보자. 아무래도 <code>DynamoDBClient</code> 의 <code>put</code>을 통하면 <code>Binary</code> 형식 입력이 되지 않는 것으로 보이는데 때문에 <code>sort: number</code> 가 도큐먼트에 들어간 상태에서 GSI를 <code>sort: binary</code> 형식으로 생성하게 되면 이 데이터들이 인덱싱이 되지 않는다.</p><p>또한 더 골때리는 것은 애매 모호한 에러를 내면서 <code>query</code> 도 동작하지 않으니 주의하자.</p><hr><p><span class="github-emoji" title="information_desk_person" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f481.png?v8">&#x1f481;</span> 말을 다소 혼용해서 했는데 <code>number</code> 는 번호, <code>binary</code> 는 이진수를 의미한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;aws-dynamodb-query-order&quot;&gt;AWS DynamoDB query order&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;미션&lt;/strong&gt; 전체 데이터를 최근순으로 가져온다. &lt;span cla
      
    
    </summary>
    
    
      <category term="aws" scheme="http://blog.bglee.me/tags/aws/"/>
    
      <category term="dynamodb" scheme="http://blog.bglee.me/tags/dynamodb/"/>
    
      <category term="query" scheme="http://blog.bglee.me/tags/query/"/>
    
      <category term="orderby" scheme="http://blog.bglee.me/tags/orderby/"/>
    
      <category term="order" scheme="http://blog.bglee.me/tags/order/"/>
    
  </entry>
  
  <entry>
    <title>웹스톰 서버리스 디버깅 설정</title>
    <link href="http://blog.bglee.me/posts/2018/webstorm-debug-serverless/"/>
    <id>http://blog.bglee.me/posts/2018/webstorm-debug-serverless/</id>
    <published>2018-08-19T09:05:11.000Z</published>
    <updated>2018-08-19T09:05:11.338Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="웹스톰webstorm">웹스톰(Webstorm)</span></h2><p>IDE로 웹스톰을 사용하고 있다. 대단히 만족하는 프로그램 중에 하나로 딱히 세팅할게 없는게 장점 중 하나다. 그런데 디버깅에선 그렇지 않다.</p><h2><span id="디버깅-세팅">디버깅 세팅</span></h2><p>서버리스를 디버깅함에 있어 <code>npm scripts</code> 를 주로 사용하게 되는데 서버리스 오프라인에서는 디버그 모드가 동작하지 않는다. 세팅하기가 귀찮아서 그러려니 하고 살고 있었는데 반복적인 작업을 하게 되어 이 부분을 세팅하고 기록으로 남긴다.</p><h4><span id="npm-스크립트">NPM 스크립트</span></h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"serverless offline --port 3001"</span>,</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>package.json</code> 은 보통 위와 같이 설정한데 풀 스택으로 작업을 할때는 3000 포트가 겹치기 때문에 포트 인자를 줘서 바꾼다.</p><blockquote><p><span class="github-emoji" title="information_desk_person" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f481.png?v8">&#x1f481;</span> <code>-p 3001</code> 하면 <code>this.options.prefix.startsWith is not a function</code> 이 따위 에러가 나게 되니 조심하자. <code>-p</code> 옵션은 포트가 아닌 프리픽스에 대한 옵션이다.</p></blockquote><h3><span id="npm-스크립트에서는-디버그가-동작하지-않는다">NPM 스크립트에서는 디버그가 동작하지 않는다.</span></h3><p>이 부분이 살짝 놀라웠는데 여튼 안되는거다. <code>npm scripts</code> 대신 직접 환경을 구성해야한다. 구성 자체는 간단하니 따라서 세팅하도록 한다.</p><h4><span id="디버그-메뉴-진입">디버그 메뉴 진입</span></h4><p>메뉴 진입은 우상단의 툴바나 메뉴바에서 찾아 들어가면된다.</p><p><img src="debug-toolbar.png" alt="debug-toolbar"></p><p><img src="debug-menu.png" alt="debug-menu"></p><h4><span id="설정">설정</span></h4><p><img src="debug-settings.png" alt="debug-settings"></p><p>메뉴에 진입하면 나오는 화면이다. 왼쪽에서 <code>+</code> 를 눌러 <code>Node.js</code> 를 선택한뒤 이미지와 같이 설정을 해주면된다. 이름은 알아보기 편한 놈으로 정한다.</p><ul><li><strong>Working directory:</strong> <code>package.json</code> 이 존재하는 루트 프로젝트에 있으면된다.</li><li><strong>JavaScript file: </strong>실행은 <code>serverless</code> 를 통해서 진행되므로 이에 대한 경로를 설정하면 된다. 난 로컬 설치를 했기 때문에 <code>node_modules/.bin/serverless</code> 를 참조한다. 글로벌을 통해서 관리하는 사람은 터미널에서 <code>which serverless</code> 를 통해 나오는 경로를 넣어주면된다.</li><li><strong>Application parameters:</strong> <code>offline</code> 이면 충분하다. 포트를 변경하기 위해 난 <code>--port 3001</code> 을 추가적으로 입력했다.</li></ul><h2><span id="디버깅">디버깅</span></h2><p><img src="debug-toolbar.png" alt="debug-toolbar"></p><p>버전업이 되면서 아이콘이 좀 플랫하게 바꼈는데 여튼 맨 오른쪽이 디버그 아이콘이다.</p><p><img src="breakpoint.png" alt="breakpoint"></p><p>웹에서 디버깅과 마찬가지로 <code>debugger</code> 와 브레이크 포인트가 둘다 작동한다 브레이크 포인트는 <code>CMD + F8</code> 를 통해 라인에 대해서 토글이 가능하다.</p><h3><span id="http-request">HTTP Request</span></h3><blockquote><p><span class="github-emoji" title="information_desk_person" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f481.png?v8">&#x1f481;</span>웹스톰은 <strong>Restful API Client</strong> 를 자체적으로 가지고 있지만 개인적으론 불편해서 다른 클라이언트도 잘 안쓴다. <code>.http</code> 파일을 이용하면 편하게 HTTP 요청을 <strong>코드로 관리</strong> 가 가능하다.</p></blockquote><p>프로젝트(디렉토리) 뷰에 <code>HTTP Request</code> 파일을 추가하자.</p><p><img src="create-http.png" alt="create-http"></p><p>그럼 친절하게 스니펫 까지 적힌 파일이 생성된다.</p><p><img src="webstorm-debugging.gif" alt="webstorm-debugging"></p><p>보는 바와 같이 결과도 신택스 하이라이팅을 해준다. <span class="github-emoji" title="hand" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/270b.png?v8">&#x270b;</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;웹스톰webstorm&quot;&gt;웹스톰(Webstorm)&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;IDE로 웹스톰을 사용하고 있다. 대단히 만족하는 프로그램 중에 하나로 딱히 세팅할게 없는게 장점 중 하나다. 그런데 디버깅에선 그렇지 않다.&lt;/p&gt;&lt;h
      
    
    </summary>
    
    
      <category term="serverless" scheme="http://blog.bglee.me/tags/serverless/"/>
    
      <category term="webstorm" scheme="http://blog.bglee.me/tags/webstorm/"/>
    
      <category term="debug" scheme="http://blog.bglee.me/tags/debug/"/>
    
      <category term="debugging" scheme="http://blog.bglee.me/tags/debugging/"/>
    
      <category term="serverless-offline" scheme="http://blog.bglee.me/tags/serverless-offline/"/>
    
  </entry>
  
  <entry>
    <title>AWS AppSync, Amplify를 이용한 IAM 롤 기반의 풀스택 GraphQL 프로젝트 구현</title>
    <link href="http://blog.bglee.me/posts/2018/aws-appsync-iam/"/>
    <id>http://blog.bglee.me/posts/2018/aws-appsync-iam/</id>
    <published>2018-08-18T04:13:02.000Z</published>
    <updated>2018-08-18T04:23:19.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><span class="github-emoji" title="speaker" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f508.png?v8">&#x1f508;</span> 진행 과정의 원할함을 위해 프로젝트 명은 <code>deptno</code> 로 가정한다.</p></blockquote><blockquote><p><span class="github-emoji" title="speaker" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f508.png?v8">&#x1f508;</span> IAM 을 통한 비인증 유저의 AppSync GraphQL 접근을 목표로 한다.</p></blockquote><h2><span id="서론">서론</span></h2><blockquote><p>😭 이 글은 눈물로 작성되었다. 눈물없이 가능하지 않았던 처절한 삽질을 말끔히 정리하고자 한다.</p></blockquote><p>인증은 매우 복잡하면서도 중요한 파트로 여러가지 방식이 존재하고 일단 설정하면 바꾸기 어렵다. 때문에 시행착오를 통합 삽질을 하기에도 매우 두려운 부분이다. 그래서 명확히 이해 해야만 했고 거의 그럴뻔 했으나 만들어진 코드나 매우 소중이 다루자는 결론에 이르렀다?</p><p><strong>react-apollo</strong> 와 같이 표준에 가까운 라이브러리 들이 있지만 여기선 <code>aws-amplify</code> 에서 제공하는 최소한만을 사용했다. AWS의 코드 샘플 자체가 <strong>react-apollo</strong> 기준이라 이 편이 더 도움이 될 거라 생각했다. 타 서비스도 GraphQL 를 사용해서 엔드포인트가 두개가 될 경우 골치아파지는데 그런 경우에 대응하기 위한 점도 고려됐다.</p><p>글은 프로젝트와 함께 진행된다. 이 프로젝트는 <strong>AWS AppSync, Cognito, Amplify, DynamoDB</strong> 를 통해 <strong>비인증</strong> 유저에게 <strong>Graph QL</strong> API 콜을 통한 데이터를 제공한다. 추가적으로 인증 유저에게 다른 권한을 부여하기 위함이다. 이 부분은 나중에 풀어보겠다. 아마도 이 길인 것 같아서 선택했다. <span class="github-emoji" title="cherry_blossom" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f338.png?v8">&#x1f338;</span></p><p>프론트엔드 프로젝트와 함께 설정값을 넣으면서 그때 그때 필요한 AWS 리소스를 생성해가면서 진행하도록 한다. 때문에 진행은 프론트엔드와 AWS가 함께 진행된다. <code>configure.js</code> 파일을 채워나가면서 진행해보자.</p><p>동작에 대한 궁금증은 마지막 프론트엔드 프로젝트를 구현하면서 우리가 해왔던 것들이 어떤 영향을 갖는지 최대한 설명 해보겠다.</p><h2><span id="aws-amplify-설정">AWS Amplify 설정</span></h2><h3><span id="설치">설치</span></h3><p>프로젝트 디렉토리에 진입해서 <code>aws-amplify</code>패키지를 설치한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add aws-amplify</span><br></pre></td></tr></table></figure><p>프로젝트의 원활한 진행을 위해 내가 자주쓰는 <strong>Next.jS</strong> 를 기준으로 작성하겠다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add next</span><br></pre></td></tr></table></figure><h3><span id="설정">설정</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch configure.js</span><br></pre></td></tr></table></figure><p>설정 파일을 만들고 다음과 같은 코드를 삽입한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// configure.js</span></span><br><span class="line"><span class="keyword">import</span> Amplify <span class="keyword">from</span> <span class="string">'aws-amplify'</span></span><br><span class="line"></span><br><span class="line">Amplify.configure(&#123;</span><br><span class="line">    Auth: &#123;</span><br><span class="line">        identityPoolId: <span class="string">'XX-XXXX-X:XXXXXXXX-XXXX-1234-abcd-1234567890ab'</span>, </span><br><span class="line">        region: <span class="string">'XX-XXXX-X'</span>, </span><br><span class="line">        userPoolId: <span class="string">'XX-XXXX-X_abcd1234'</span>,</span><br><span class="line">        userPoolWebClientId: <span class="string">'XX-XXXX-X_abcd1234'</span>, </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>설정에 입력된 바와 같이 4가지 필요하다.</p><ul><li>identityPoolId - <strong>코그니토 연동 자격</strong> 증명에 대한 풀 ID</li><li>region - 서울이라면 <strong>‘ap-northeast-2’</strong></li><li>userPoolId: - <strong>코그니토 유저 풀</strong> ID</li><li>userPoolWebClientId - 코그니토 유저 풀 생성 후 <strong>앱 클라이언트 설정</strong> 에서 <strong>시크릿 키 체크 해제</strong> 후 생성된 ID</li></ul><h3><span id="cognito-설정">Cognito 설정</span></h3><p>먼저 유저풀을 생성한다.</p><h4><span id="코그니토-유저-풀-생성optional">코그니토 유저 풀 생성(Optional)</span></h4><p><a href="https://ap-northeast-2.console.aws.amazon.com/cognito/users" target="_blank" rel="noopener">https://ap-northeast-2.console.aws.amazon.com/cognito/users</a> 에 접속 후 <strong>사용자 풀 생성</strong> 버튼을 클릭한다.</p><p><code>Dev Deptno User Pool</code> 를 입력하고 기본값 검토를 누른다.</p><p>정책 &gt; 암호 강도에서 체크박스를 모두 해제하고 자릿수를 6으로 설정한다.</p><p><img src="password-policy.png" alt="password-policy"></p><p>앱 클라이언트 &gt; 클라이언트를 추가하되 <strong>클라이언트 보안키 생성</strong> 을 해제한다. 이름은 <code>Dev Deptno Web Client</code> 로 했다.<img src="aws-appsync-iam/create-app-client.png" alt="create-app-client"></p><p>다시 <strong>검토</strong> 로 이동해서 <strong>풀 생성</strong> 버튼을 누른다.</p><p>이전 <strong>설정</strong> 에서 만들었던 <code>configure.js</code> 에서 <code>userPoolId</code> 를 풀 생성 후 나오는 <strong>풀 ID</strong> 로 교체한다. <strong>앱 클라이언트 설정</strong> 으로 이동해서 클라이언트 ID 를 <code>userPoolWebClientId</code> 에 입력한다.</p><h4><span id="코그니토-자격-증명-풀-생성required">코그니토 자격 증명 풀 생성(Required)</span></h4><p><code>Dev Deptno Identity Pool</code> 이름을 지정하고 <strong>인증되지 않은 자격 증명에 대한 액세스 활성화</strong> 를 <strong>체크</strong> 한다.</p><p>인증 공급자에서 <code>Cognito</code> 탭에 <code>configure</code> 에 입력한 <code>userPoolId</code> 와 <code>userPoolWebClientId</code> 를 순서대로 입력한다.</p><p><strong>풀 생성</strong> 버튼을 눌러 풀을 생성한다. IAM 설정이 나오는데 <strong>허용 </strong>을 눌러서 인증, 비인증 유저에 대한 롤을 생성한다. 추가 후 나오는 자격 증명 풀 ID 를 <code>configure.js</code> 의 <code>identityPoolId</code> 에 넣는다.</p><h5><span id="iam-role-설정">IAM Role 설정</span></h5><p>코그니토 자격 증명 풀을 생성할 때 인증되지 않은 자격 증명에 대한 액세스를 활성화 했다. 이때 미인증에 대한 <code>IAM ROLE</code> 도 함께 생성했는데 <strong>Cognito Sync</strong> 가 <strong>AppSync</strong> 로 대체되면서 정책 설정이 제대로 않아 <code>401</code> 에러가 발생한다.</p><p>이를 해결하기 위해 <strong>IAM &gt; 역할</strong> 로 가면 역할을 이름을 변경하지 않고 그대로 갔다라면 <code>Cognito_DevDeptnoIdentityPoolUnauth_Role</code> 형식의 이름으로 역할이 존재한다. 이를 선택하고 <strong>인라인 정책 &gt; JSON</strong> 을 선택하고 아래 데이터를 붙여넣는다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"Version"</span>: <span class="string">"2012-10-17"</span>,</span><br><span class="line">    <span class="attr">"Statement"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"Effect"</span>: <span class="string">"Allow"</span>,</span><br><span class="line">            <span class="attr">"Action"</span>: [</span><br><span class="line">                <span class="string">"appsync:GraphQL"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"Resource"</span>: <span class="string">"*"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 역할을 생성한다. 아래와 같은 형식으로 이름을 넣어주면 보기 편하겠다.</p><p><img src="create-policy.png" alt="create-policy"></p><p>역할을 생성하고 정책이 연결됬으면 미인증 유저의 GraphQL 엔드포인트에 대한 접근이 허가된다.</p><hr><h2><span id="appsync">AppSync</span></h2><p><strong>AppSync</strong> 는 아직 서울 리전이 지원되지 않는다. 때문에 우린 도쿄로 간다.</p><blockquote><p><span class="github-emoji" title="cloud_with_lightning_and_rain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/26c8.png?v8">&#x26c8;</span> awsmobile cli 커맨드를 통해 생성하면 GraphQL 엔드포인트가 ap-northeast-2(서울) 로 설정파일이 생성되지만 서울 리전에는 아직 <strong>AppSync</strong> 가 존재 하지 않는다. 템플릿 예외 처리 오류로 보인다.</p></blockquote><p><a href="https://ap-northeast-1.console.aws.amazon.com/appsync/home?region=ap-northeast-1#/create" target="_blank" rel="noopener">https://ap-northeast-1.console.aws.amazon.com/appsync/home?region=ap-northeast-1#/create</a> AWS 콘솔에서 <strong>AppSync</strong> 를 선택하고 <strong>Create API</strong> 를 누른다. 템플릿이 몇개 주어지는데 <strong>Author from scratch</strong> 를 선택해서 깔끔하게 시작한다.</p><p><img src="appsync-create-api.png" alt="appsync-create-api"></p><p>이름은 <code>Dev Deptno GraphQL</code> 정도면 멋진것 같다.</p><p><strong>Settings</strong> 섹션으로 이동하면 인증 타입을 선택할 수 있다.<img src="aws-appsync-iam/appsync-api-type.png" alt="appsync-api-type"></p><p>기본은 <strong>API key</strong> 다 헤더에 추가만 해주면 동작하므로 매우 간편한 방식이다. 우리는 <strong>AWS Identity and Access Management</strong> 를 선택한다.</p><p>이제 클라이언트에서 콜을 할때 가지고 있는 인증 권한에 따라 API 가 제한되게된다.</p><h3><span id="dynamodb-설정">DynamoDB 설정</span></h3><blockquote><p><span class="github-emoji" title="speaker" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f508.png?v8">&#x1f508;</span> <strong>AppSync</strong> 가 서울에서 지원이 안되다보니 서비스를 이동하다보면 리전이 꼬일 수 있다. 나머지 리소스는 서울임을 계속 확인하는 것이 좋다.</p></blockquote><p><strong>AppSync</strong> 가 데이터를 퍼다 나르기 위해서 데이터 소스를 연결해야하는데 이 프로젝트에서는 다이나모디비를 이용한다. AWS 콘솔에서 <strong>DynamoDB</strong> 를 선택한다.</p><p><strong>테이블</strong> 섹션에서 <strong>테이블 만들기</strong> 를 누르고 이름이랑 키만 설정하면 바로 테이블이 생성된다.(어썸..👍)</p><p><img src="dynamodb-create-table.png" alt="dynamodb-create-table"></p><p>파티션 키는 <strong>email</strong> 이라고 쓰고 대충 생성을 하자. 테이블 이름은 <code>Dev Deptno User</code> 로 한다.</p><blockquote><p><span class="github-emoji" title="thinking" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f914.png?v8">&#x1f914;</span> 테이블 이름은 단수로 해야 GraphQL 스키마 자동생성을 할 때 깔끔하게 맞는 느낌이 있다..</p></blockquote><h3><span id="data-source-추가">Data Source 추가</span></h3><p>다시 AWS 콘솔에서 <strong>AppSync</strong> 로 돌아온 뒤 <strong>Data Source</strong> 섹션을 선택하고 새로운 소스를 추가하기 위해 <strong>New</strong> 를 누른다.</p><p><strong>Data source name</strong> 을 설정하는데 여기선 공백이 먹지 않으므로 다이나모디비 프리픽스를 붙이고 파스칼 케이스로 이름을 정했다.</p><p><code>DDB_DevDeptnoUser</code></p><p><strong>Data source type</strong> 에서는 <code>Amazon DynamoDB Table</code> 을 선택한다.</p><p><strong>Region</strong> 은 서울이므로 <code>AP-NORTHEAST-2</code> 를 선택한다.</p><p><strong>Table name</strong> 은 아까 생성한 <code>Dev Deptno User</code> 를 선택하거나 입력한다.</p><blockquote><p><span class="github-emoji" title="thinking" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f914.png?v8">&#x1f914;</span> 가끔 테이블을 제대로 불러오지 못하니 그럴경우 그냥 입력한다.</p></blockquote><p><strong>Create or use an existing role</strong> 에서는 <code>New role</code> 을 선택한다.</p><p><strong>Automatically generate GraphQL</strong> 를 활성화하면 친절하게도 스키마를 바로 뽑아준다. 활성화 하자.</p><p><img src="appsync-datasource-setting.png" alt="appsync-datasource-setting"></p><p><strong>Create</strong> 를 눌러 데이터 소스를 생성하자. 생성이 완료되면 <strong>Schema</strong> 섹션으로 이동해서 스키마가 잘 생성됐는지 확인한다. 생성된 스키마에 대한 테스트는 바로 아래 섹션인 <strong>Queries</strong> 에 <strong>Graphiql</strong> 느낌의 클라이언트가 들어가있어 바로 확인이 가능하다.</p><p>이제 생성된 <strong>AppSync API</strong> 정보를 바탕으로 <code>configure.js</code> 파일을 업데이트 하자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//configure.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;AUTH_TYPE&#125; <span class="keyword">from</span> <span class="string">'aws-appsync/lib'</span></span><br><span class="line"><span class="keyword">const</span> configuration = &#123;</span><br><span class="line">  Auth: &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  aws_appsync_graphqlEndpoint: <span class="string">'https://xxx.appsync-api.xx-xxxxx.amazonaws.com/graphql'</span>,</span><br><span class="line">  aws_appsync_region: <span class="string">'xx-xxxx-x'</span>,</span><br><span class="line">  aws_appsync_authenticationType: AUTH_TYPE.AWS_IAM,</span><br><span class="line">  graphql_endpoint_iam_region: <span class="string">'xx-xxxx-x'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>API Details</strong> 에 있는 <strong>API URL</strong> 이 <code>aws_appsync_graphqlEndpoint</code> 다. <code>aws_appsync_region</code>, <code>graphql_endpoint_iam_region</code> 은 모두 도쿄에서 생성했으므로 <code>ap-northeast-1</code> 을 넣어주면 된다. <code>aws_appsync_authenticationType</code> 은 <code>&quot;AWS_IAM&quot;</code> 인데 상수가 정의되어 있으므로 그를 이용한다.</p><blockquote><p><span class="github-emoji" title="information_desk_person" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f481.png?v8">&#x1f481;</span> AUTH_TYPE</p></blockquote><p><code>AUTH_TYPE</code> 에 따른 추가적인 데이터가 반드시 필요하다.</p><ul><li>AWS_IAM - <code>graphql_endpoint_iam_region</code></li><li>AWS_API - <code>aws_appsync_apiKey</code></li><li>AMAZON_COGNITO_USER_POOLS -</li></ul><h2><span id="front-end">Front-end</span></h2><p>드디어 프론트엔드다. 그럼 이제 설정만 있는 프론트엔드 프로젝트를 고도화해보자.</p><h3><span id="nextjs">Next.js</span></h3><p><strong>Next.js</strong> 기반이므로 그에 대한 구조를 갖춰주자. <strong>Next.js</strong> 는 <code>pages</code> 디렉토리 밑을 통해 라우팅이 된다는 점이 특징이니 따로 라우터 설정은 하지 않아도 된다. CRA(<code>create-react-app</code>) 의 컨벤션 룰이 내겐 너무 갑갑해서 사용하는 것일 뿐 어려운 점은 없다. 그냥 파일 두개를 만들면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir pages</span><br><span class="line">touch pages/index.jsx</span><br><span class="line">touch graphql.js</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pages/index.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'../configure'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createUser, getUsers&#125; <span class="keyword">from</span> <span class="string">'../graphql'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  readonly state = &#123;</span><br><span class="line">    users: <span class="literal">null</span>,</span><br><span class="line">    email: <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Hello world!&lt;br/&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.users &amp;&amp; &lt;pre&gt;&#123;JSON.stringify(this.state.users, null, 2)&#125;&lt;/pre&gt;&#125;</span><br><span class="line">        &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleOnSubmit&#125;&gt;</span><br><span class="line">          &lt;input</span><br><span class="line">type=<span class="string">"text"</span></span><br><span class="line">value=&#123;<span class="keyword">this</span>.state.email&#125;</span><br><span class="line">onChange=&#123;<span class="keyword">this</span>.handleOnChangeEmail&#125;</span><br><span class="line">/&gt;</span><br><span class="line">          &lt;button&gt;추가&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>form&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  async componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">    this.users()</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  async users() &#123;</span></span><br><span class="line"><span class="regexp">    this.setState(&#123;users: await getUsers()&#125;)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  handleOnChangeEmail = (e) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    this.setState(&#123;email: e.target.value&#125;)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  handleOnSubmit = async (e) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    e.preventDefault()</span></span><br><span class="line"><span class="regexp">    await createUser(this.state.email)</span></span><br><span class="line"><span class="regexp">    this.users()</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//graphql.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;API, graphqlOperation&#125; <span class="keyword">from</span> <span class="string">'aws-amplify'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getUsers = <span class="function"><span class="params">()</span> =&gt;</span> API</span><br><span class="line">  .graphql(graphqlOperation(queryUsers))</span><br><span class="line">  .catch(<span class="function"><span class="params">_</span> =&gt;</span> [])</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createUser = <span class="function">(<span class="params">email: string</span>) =&gt;</span> API</span><br><span class="line">  .graphql(graphqlOperation(mutationCreateUser, &#123;email&#125;))</span><br><span class="line">  .catch(<span class="function"><span class="params">_</span> =&gt;</span> <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queryUsers = <span class="string">`query DeptnoUsers &#123;</span></span><br><span class="line"><span class="string">  listDeptnoUsers &#123;</span></span><br><span class="line"><span class="string">    items &#123;</span></span><br><span class="line"><span class="string">      email</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    nextToken</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutationCreateUser = <span class="string">`mutation CreateDeptnoUser($email: String!) &#123;</span></span><br><span class="line"><span class="string">  createDeptnoUser(input: &#123;email: $email&#125;) &#123;</span></span><br><span class="line"><span class="string">    email</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;`</span></span><br></pre></td></tr></table></figure><p>코드에 대한 설명은 따로 필요 없을 것 같다. <strong>React</strong> 와 <strong>GraphQL</strong> 에 대한 지식이 조금 있으면 된다. <strong>query</strong> 는 AWS 콘솔에서 <strong>AppSync</strong>, 생성한 API를 선택한후 <strong>Schema</strong> 누르면 참조할 수 있다.</p><h3><span id="실행">실행</span></h3><p>이제 코드를 만들었으니 실행을 하면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx next</span><br></pre></td></tr></table></figure><hr><h2><span id="연관-링크">연관 링크</span></h2><p>깃허브에 코드가 공개되어 있으며 코드는 타입스크립트를 기준으로 짜여졌으나 이해하기에 다르지 않다.</p><p><a href="https://github.com/deptno/aws-appsync-iam-example" target="_blank" rel="noopener">https://github.com/deptno/aws-appsync-iam-example</a> 예제 코드 깃허브 저장소.</p><p><a href="https://blog.bglee.me/posts/2018/aws-appsync-iam">https://blog.bglee.me/posts/2018/aws-appsync-iam</a> 본 글의 블로그 포스트.</p><hr><h2><span id="부록">부록</span></h2><blockquote><p><span class="github-emoji" title="information_desk_person" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f481.png?v8">&#x1f481;</span> <code>aws-amplify-react</code> 를 사용하면 인증에 대한 처리 분기를 리액트에서 보다 쉽게 할 수 있다. <a href="https://aws-amplify.github.io/amplify-js/media/quick_start#add-user-authentication-to-your-app" target="_blank" rel="noopener">공식 문서</a></p></blockquote><blockquote><p><span class="github-emoji" title="information_desk_person" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f481.png?v8">&#x1f481;</span> <code>aws-appsync-react</code> 패키지는 <code>apollo-react</code> 를 사용할때 오프라인 제어 및 로컬 캐싱을 위한 지원이 있는 것으로 보인다. <code>apollo-react</code> 의 사용 유저라면 반드시 문서를 참조해보도록 한다. <a href="https://github.com/awslabs/aws-mobile-appsync-sdk-js#readme" target="_blank" rel="noopener">깃허브</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;&lt;span class=&quot;github-emoji&quot; title=&quot;speaker&quot; data-src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f508.png?v8&quot;&gt;&amp;
      
    
    </summary>
    
    
      <category term="aws" scheme="http://blog.bglee.me/tags/aws/"/>
    
      <category term="cognito" scheme="http://blog.bglee.me/tags/cognito/"/>
    
      <category term="dynamodb" scheme="http://blog.bglee.me/tags/dynamodb/"/>
    
      <category term="amplify" scheme="http://blog.bglee.me/tags/amplify/"/>
    
      <category term="unauthenticated" scheme="http://blog.bglee.me/tags/unauthenticated/"/>
    
      <category term="iam" scheme="http://blog.bglee.me/tags/iam/"/>
    
      <category term="role" scheme="http://blog.bglee.me/tags/role/"/>
    
      <category term="graphql" scheme="http://blog.bglee.me/tags/graphql/"/>
    
  </entry>
  
  <entry>
    <title>타입스크립트 모노레포</title>
    <link href="http://blog.bglee.me/posts/2018/typescript-monorepo/"/>
    <id>http://blog.bglee.me/posts/2018/typescript-monorepo/</id>
    <published>2018-08-15T09:45:58.000Z</published>
    <updated>2018-09-05T07:38:40.371Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="typescript-monorepo">TypeScript, Monorepo</span></h2><p>타입스크립트와 모노레포 셋업은 매우 지난한 싸움이다. 맞지 않는 부분도 상당히 많다. 내가 일전에 무엇을 남겼는지 기억은 나지 않으나 비슷한 글을 남겼었다.</p><p><a href="https://medium.com/@deptno/monorepo-yarn-workspace-e81e3e078100" target="_blank" rel="noopener">🌸 모노레포. Lerna? Yarn Worksapce!</a></p><p>위 글에 모노레포가 왜 필요지에 대해서는 남겨 놨을 것이라 생각한다. 어떻게 셋업을 하는지 글을 남겼었지만 그럼에도 불구하고 타입스크립트를 마주하면 쉽지않은 상황이 발생한다. 특히 <strong>프론트엔드</strong>에서 그러하다.</p><p>프로젝트를 가볍게 생성한다고 해보자. 내가 자주 쓰는 Next.js 의 <a href="https://github.com/deptno/next.js-typescript-starter-kit" target="_blank" rel="noopener">빵판</a> 이나 아니면 그냥 <code>create-react-app</code> 에 <code>react-scripts-ts</code> 를 먹여서 TypeScript 로 프로젝트를 셋업하면 작업하는 내내 <code>.js</code> , <code>.map</code> 등은 더이상 밖으로 노출되지 않고 메모리안에서 처리된다. 때문에 우리는 <code>.gitignore</code> 를 따로 처리하면서 파일 IO에 대한 성능 이슈등으로 부터 자유롭다. 바람직하다.</p><h2><span id="그럼-무엇이-문제인가">그럼 무엇이 문제인가?</span></h2><p>모노레포의 구성은 아래 사진과 유사하다.</p><p><img src="1*thsoeHGmHzCeaPWOCBlQUg.png" alt="img"></p><p>이 이미지는 이전에 쓴 글에서 가져온 것인데 프론트엔드가 없는 라이브러리의 구현 구조다. 구조를 보면 <code>feed</code>, <code>html</code>, <code>readme</code>, <code>speech</code> 의 패키지가 존재한다. 편의상 <code>readme</code> 를 <code>create-react-app</code> 등으로 생성한 메인 <strong>클라이언트 앱</strong> 이라고 생각하자. 그럼 여기서 <code>packages/readme/index.js</code> 는 지워진다. 프로젝트 셋업에 따라 <code>.js</code>는 관리하지도 보여지지도 않는다.</p><p>나머지 패키지들은 컴파일의 결과로써 <code>.js</code> 을 유지해야한다. 각 패키지를 <strong>리엑트 컴포넌트</strong> 라고 생각하고 메인인 <code>readme</code> 에서 참조를 하게 되면 모노레포의 구성 이유와 같이 외부 모듈로 처리하므로 <code>import</code> 구문을 통해 로드시에 <code>.js</code> 가 로드되므로 반드시 <code>.js</code> 가 필요하다.</p><p>그럼 메인 프로젝트인 <code>readme</code> 는 컴파일을 따로 돌려서 <code>.js</code> 를 생성하면 안되고 나머지 패키지들에 대해서는 컴파일을 통해 <code>.js</code> 를 생성해야한다. 이 부분이 타입스크립트와 모노레포의 조합을 매우 어렵게 만든다. 부분마다 따로 컴파일을 돌리고 IDE 셋업에 매이는등 많은 삽질을 하다가 아마 그만뒀던 경험을 가진 개발자들도 여럿(나만? <span class="github-emoji" title="eyes" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f440.png?v8">&#x1f440;</span>)있을지 모르겠다.</p><h2><span id="typescript-3">TypeScript 3</span></h2><p>섹션이 하나 더 들어가야하는데 <strong>시행착오</strong>에 대해서 적을까 하다가 그에 대한 잘 씌여진 글로 대체한다. TypeScript 공식 사이트의 프로젝트 레퍼런스 핸드북과 후이서울에서 작성한 글이다.</p><ul><li><a href="https://engineering.huiseoul.com/타입스크립트-3-0-99e5d45ec439" target="_blank" rel="noopener">https://engineering.huiseoul.com/타입스크립트-3-0-99e5d45ec439</a></li><li><a href="https://www.typescriptlang.org/docs/handbook/project-references.html" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/project-references.html</a></li></ul><p>모노레포에 관련된 글은 아니다. 그러나 프로젝트 빌드와 관련해서 인상적인 발전이 있었다. <code>--build</code> 명령어와 프로젝트 참조를 통해 순차적으로 효율적인 빌드를 적용한다 뭐 이런 내용인데 자세한 내용은 문서에 있다.</p><h2><span id="monorepo">Monorepo</span></h2><p>그럼 다시 모노레포로 돌아오자. <code>next</code> 나 <code>create-react-app</code> 의 개발환경이 돌면서 추가적으로 나머지 패키지들에서 빌드가 같이 돌아줘야한다. 나머지 패키지들은 컴파일을 통해서 <code>.js</code> 를 생산해 낼 것이고 메인 앱에서는 이들이 <code>.js</code> 를 가지고 있으므로 개발환경에서 바로바로 <code>import</code> 를 할 수 있게 된다.</p><p>드디어 추가된 타입스크립트@3 의 프로젝트 레퍼런스와 <code>--build</code> 를 통해 더러운 <strong>프론트엔드 + 타입스크립트 + 모노레포</strong> 가능해진다.</p><p>이에 대한 설명은 글보다 코드로 대신한다.</p><ul><li><a href="https://github.com/deptno/typescript-monorepo-next-example" target="_blank" rel="noopener">Next.js 버전</a></li><li><a href="https://github.com/deptno/typescript-monorepo-cra-example" target="_blank" rel="noopener">create-react-app 버전</a></li></ul><hr><p>등아파서 글을 길게 못쓰겠다…</p><blockquote><p>💁 2018-09-05 추가 내용</p></blockquote><h3><span id="x1f4a9-package-간의-상호-참조-의존성"><span class="github-emoji" title="shit" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a9.png?v8">&#x1f4a9;</span> Package 간의 상호 참조 의존성</span></h3><p>패키지간에 상호 참조가 필요한 경우 기존의 모노레포에서 하듯이 <code>package.json</code> 에 <code>[packageName]: &quot;*&quot;</code>이 동작하지 않았다. 대충 아래와 같은 에러가 난다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx tsc -b packages</span><br><span class="line">error TS6307: File <span class="string">'경로/packages/패키지명/index.ts'</span> is not <span class="keyword">in</span> project file list. Projects must list all files or use an <span class="string">'include'</span> pattern.</span><br></pre></td></tr></table></figure><p><code>include</code> 라는 말에 휘둘려서 시간을 쫌 뺏겼는데 의존성이 없는 <code>pakcages/b</code> 는 컴파일이 되는 것을 보고 이것 저것 테스트를 해봤다.</p><p><code>packages/a</code> 가 <code>packages/b</code> 에 대한 의존성을 지니고 있을 때 <code>packages/a</code> 의 <code>tsconfig.json</code> 에 레퍼런스를 추가해줘야지만 컴파일이 가능하다.</p><p><code>packages/a/tsconfig.json</code> 에 <code>reference</code> 구문을 추가해주자</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"references": [</span><br><span class="line">  &#123; <span class="attr">"path"</span>: <span class="string">"../b"</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>그리고 다시 빌드한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsx tsc -b packages</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;typescript-monorepo&quot;&gt;TypeScript, Monorepo&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;타입스크립트와 모노레포 셋업은 매우 지난한 싸움이다. 맞지 않는 부분도 상당히 많다. 내가 일전에 무엇을 남겼는지 기억은 나지
      
    
    </summary>
    
    
      <category term="react" scheme="http://blog.bglee.me/tags/react/"/>
    
      <category term="typescript" scheme="http://blog.bglee.me/tags/typescript/"/>
    
      <category term="monorepo" scheme="http://blog.bglee.me/tags/monorepo/"/>
    
      <category term="next" scheme="http://blog.bglee.me/tags/next/"/>
    
      <category term="create-react-app" scheme="http://blog.bglee.me/tags/create-react-app/"/>
    
      <category term="cra" scheme="http://blog.bglee.me/tags/cra/"/>
    
  </entry>
  
  <entry>
    <title>RxJS 에 대한 고민과 Quick start RxJS 서평</title>
    <link href="http://blog.bglee.me/posts/2018/rxjs/"/>
    <id>http://blog.bglee.me/posts/2018/rxjs/</id>
    <published>2018-08-15T09:09:17.000Z</published>
    <updated>2018-08-15T09:09:17.567Z</updated>
    
    <content type="html"><![CDATA[<p>책도 읽은 겸<code>rxjs</code> 의 도입에 대한 고민과, 책에 대한 후기를 남긴다.</p><h2><span id="rxjs-도입의-어려움">RxJS 도입의 어려움</span></h2><p>대부분의 작업을 혼자 함에도 불구하고유독 <code>rxjs</code> 만이 더욱 도입하기가 어려웠다. 공식 문서를 통해 메서드들을 영어 단어 외우는 느낌으로 출, 퇴근 길에 보면서 다니기도 했으나 역시 코드를 작성하는 것이 아니면 기억이 나지 않는다.</p><p><code>rxjs</code> 는 접근하기도 사용하기도 어려웠다. <code>rxjs</code> 의 도입 허들에는 3가지 정도의 이슈가 있을 것이라 생각됐다.</p><ul><li>필요성</li><li>러닝 커브</li><li>감염적 코드</li></ul><h3><span id="필요성">필요성</span></h3><p>일단 필요성이다. <code>rxjs</code> 가 없이도 잘 구현할 수 있으며 오히려 도입했는데도 불구하고 지식이 모자라면 유지 보수에서 어려움을 겪는다. 편리한 메서드들이 많이 있지만 <code>lodash</code> 에서도 충분히 지원되며 <code>EventEmitter</code> 클래스등을 이용하면 독립성을 가지는 코드를 가질 수 있다. 코드가 길어지는 경향이 있지만 충분했고, 익숙했다.</p><p>하지만 <code>ramda</code> 의 도입 필요성과 마찬가지로 <code>rxjs</code> 를 통해 많은 비동기 처리를 독립적으로 처리하고, 직관적이면서도 더 적은 코드를 통해 생산성에 니즈는 언제나 있다.</p><h3><span id="러닝-커브">러닝 커브</span></h3><p>일단 홈페이지를 열면 너무 많은 메서드들이 나온다. <code>rxjs</code> 의 도입 이슈는 <strong>FP</strong>(<code>ramda.js</code>) 를 도입할 때와 같다. 코드가 줄어들고 가독성이 확보되며 직관적이다. 반면 이를 위한 많은 메서드들도 방대해서 도입이 쉽지않다.</p><p>그러나 <code>ramda</code> 를 통해 꽤나 익숙해진 메서드들이 있었고, <strong>FRP</strong> 라이브러리로 불리는 <code>rxjs</code> 에서도 많이 쓰였다.</p><blockquote><p><code>pluck</code>, <code>map</code>, <code>tap</code>, <code>take</code>, <code>first</code> 등등</p></blockquote><h3><span id="감염적-코드">감염적 코드</span></h3><p>어쩌다 보니 영문을 번역한 듯한 문구가 됐는데, 비동기 처리는 관련 코드를 시작하면 상용하는 측에서도 패턴이 강제되는 연속성이 있다. 이에 대한 가장 유명한 예가 <strong>Callback hell</strong> 이다.</p><h4><span id="callback-hell-promise-async-await">Callback hell, Promise, Async-Await</span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">asyncWork(_, (err, data) =&gt; &#123;</span><br><span class="line">  asyncWork(data, (err, data) =&gt; &#123;</span><br><span class="line">    asyncWork(data, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="comment">// Callback hell</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>Promise</code> 도 다르지 않다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asyncWork</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> asyncWork(data))</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> asyncWork(data))</span><br></pre></td></tr></table></figure><p><code>async-await</code> 을 보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncWork</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  data = <span class="keyword">await</span> asyncWork(data)</span><br><span class="line">  data = <span class="keyword">await</span> asyncWork(data)</span><br><span class="line">  <span class="keyword">return</span> data <span class="comment">// Promise 반환</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드가 보기 좋은가, 안좋은가 대한 이야기가 아니라 패턴의 강제성에 대한 이야기다. 가독성은 좋아지고 있다. 그럴드 수 밖에 없지만 어쨋건 <code>Promise</code> 에 한번 발을 들이면 <code>Promise</code> 체인 패턴에 묶인다.</p><h4><span id="rxjs-는">RxJS 는?</span></h4><p>이 부분에 있어서 오히려 <code>rxjs</code> 는 <code>Promise</code> 체인의 형태와 유사한데 뭐 워낙 익숙해서 이제 이런 감염성은 문제가 되지 않는 것 같기도하다.</p><h2><span id="quick-start-rxjs">Quick start RxJS</span></h2><p><img src="rxjs.png" alt="rxjs"></p><p>출근 버스에서 3일 봤다. 3장은 다 보지 못했으나 버스내에서 주어진 시간이 45분 정도인데 그 시간에 한장을 다 읽을 수 있었다(3장으로 구성 되어 있다).</p><p>책 읽는 속도가 느린 편임에도 불구하고 잘씌여진 책은 잘 읽히는구나 라고 생각했다. 아는 개념들에 대해서는 패스하고 RxJS 자체에 집중에서 책을 읽었을 때의 얘기다.</p><p>1장은 RxJS 가 나오게 된 배경, 2장은 RxJS 자체에 대해 작은 프로젝트를 진행해가며 그때마다 필요한 메서드를 추가하면서 설명이 진행된다. 3장은 배운 것을 바탕으로 실제 RxJS를 사용하는 프로젝트를 구현하는데 초점을 맞춘다.</p><p>또 좋았던 점은 책이 최신을 반영하기 위해 RxJS 6.x 를 반영했다는 점이다. 잘은 모르지만 큰 변화중 하나는 체인형태의 메서드 콜 방식에서 파이프라인 형태로 사용 방식이 변경됬다는 점이라고 생각되며 코어의 가벼움을 유지하면서 순수함수인 오퍼레이터를 프로토타입 체인에 유지할 필요가 없다고 생각했던 것 같다. 개인적으로 매우 바람직한 방향이라고 생각된다.</p><h3><span id="독서의-순서">독서의 순서</span></h3><p>책을 읽을때도 프로젝트를 진행할때도 에너지가 있어서 에너지가 많은 초반을 서론에서 빼고싶지 않았다. 대충 훑어보고 바로 2장으로 들어갔다. 1장은 깃헙에 공개되어 꽤나 읽은 내용이 있는 것도 한 몫했다.</p><p><code>Observable</code> 이 무엇인지, <code>Subject</code> 와는 어떻게 다른지 잘 설명해주고 있다. <code>rxjs</code> 를 이해함에 있어서 대단히 중요한 개념이고 이를 가지고 여러 메소드 들이 파생된다. 책에서 진행하는 프로젝트가 진행됨에 따라 필요한 메서드들을 적시 설명하며 지루하지 않으면서도 필요한 설명은 모두 하고 있다.</p><p>2장 -&gt; 1장 -&gt; 3장 순서로 읽었는데 메인은 2장이다. 3장은 실제 프로젝트인데 2장에서 배운 범위를 넘어가지 않는 점이 정말 좋았다. 공부와 프로젝트와 완전히 분리되어있다. 부록들도 훌륭하다 이해를 높일 수 있는 결코 가볍지 않은 주제를 표로 잘 풀어준다. 꼭필요한 메소드는 설명하고간다.</p><p>2장은 두번 읽어야한다.</p><p><a href="https://www.youtube.com/watch?v=3LKMwkuK0ZE" target="_blank" rel="noopener">https://www.youtube.com/watch?v=3LKMwkuK0ZE</a> 추가적으로 벤 아저씨의 영상을 보면 이해에 더 많은 도움이 된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;책도 읽은 겸&lt;code&gt;rxjs&lt;/code&gt; 의 도입에 대한 고민과, 책에 대한 후기를 남긴다.&lt;/p&gt;&lt;h2&gt;&lt;span id=&quot;rxjs-도입의-어려움&quot;&gt;RxJS 도입의 어려움&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;대부분의 작업을 혼자 함에도 불구하고유독 &lt;c
      
    
    </summary>
    
    
      <category term="rxjs" scheme="http://blog.bglee.me/tags/rxjs/"/>
    
      <category term="reactive" scheme="http://blog.bglee.me/tags/reactive/"/>
    
  </entry>
  
  <entry>
    <title>Github OAuth 404, 그리고 헤더의 중요성</title>
    <link href="http://blog.bglee.me/posts/2018/Github-OAuth-404/"/>
    <id>http://blog.bglee.me/posts/2018/Github-OAuth-404/</id>
    <published>2018-08-07T11:32:50.000Z</published>
    <updated>2018-08-07T12:14:31.970Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>이 것도 한 3번인가 삽질을 한 것 같은데.. 기록을 해두지 않아 매번 삽질을 한다. 오늘도 4시간 정도 날린거같다…</p></blockquote><h2><span id="3-티어-인증-프로세스">3 티어 인증 프로세스</span></h2><ul><li>클라이언트(웹)에서 깃헙로 리다이렉션을 시도한다.</li><li>깃헙에서는 스코프랑 유저 허락 받고 허락 되면 어플리케이션 정보 저장시에 사용했던 콜백(서버)로 <strong>code</strong> 를 전송한다.</li><li>서버는 <strong>code</strong> 를 <strong>token</strong> 으로 교환한다.</li><li>교환 후에는 <strong>token</strong> 을 가지고 다시 클라이언트로 돌아갈 수 있도록 <strong>302</strong> 리턴을 하면서 쿼리 파라메터로 <strong>token</strong> 을 넘긴다.</li></ul><h2><span id="이슈">이슈</span></h2><p>코드에서 토큰으로 교환하는 과정에서 깃헙이 <strong>404</strong> 를 내뱉는다. 무엇이 문제인가 <span class="github-emoji" title="eyes" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f440.png?v8">&#x1f440;</span></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">`https://github.com/login/oauth/access_token`</span>, &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  body: &#123;</span><br><span class="line">    client_id    : GITHUB_CLIENT_ID,</span><br><span class="line">    client_secret: GITHUB_CLIENT_SECRET,</span><br><span class="line">    code,</span><br><span class="line">    <span class="comment">// state,</span></span><br><span class="line">    <span class="comment">// redirect_uri</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3><span id="content-type-헤더의-중요성">Content-Type 헤더의 중요성</span></h3><p>문제는 이것 저것 해보다가 설마 헤더 때문인가? 라는 생각에 이르렀다. 코드는 다음과 같이 수정해봤다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">`https://github.com/login/oauth/access_token`</span>, &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  body: &#123;</span><br><span class="line">    client_id    : GITHUB_CLIENT_ID,</span><br><span class="line">    client_secret: GITHUB_CLIENT_SECRET,</span><br><span class="line">    code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>바로 <strong>200 OK</strong> 가 떨어진다. <span class="github-emoji" title="fist_raised" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/270a.png?v8">&#x270a;</span></p><h3><span id="서버는-서버-엔지니어-마음">서버는 서버 엔지니어 마음</span></h3><p>언젠가는 URL에 뒤에 <code>/</code> 를 붙이냐 마느냐로, <code>200</code> vs <code>201</code>, <code>200</code> vs <code>404</code> 등등 피곤하고 시나리오적인 흐름과 주관이 섞일 수 밖에 없는 문제가 있다.</p><p>소 제목은 <strong>서버는 서버 엔지니어 마음이다.</strong> 라고 달았지만 흥분을 가라 앉히고 보면 내가 잘못한게 맞다. 이런 날들을 위해 준비되어있는 스펙을 무시했다. 최근 근무한 직장도 그렇고 기본적으로 <code>JSON</code> 이 일반화 된 세상에서 살고 있다보니 기본이 <code>JSON</code> 일 것이라 예단했다. 깃헙도 꽤나 오랜 시간을 버텨왔고 매우 많은 유저가 사용하는 만큼 바꾸지 못하는 레거시가 있기 마련이다.</p><h2><span id="리턴-값">리턴 값</span></h2><p>자성을 하고 리턴 값을 확인하려고 코드를 짜니 또 에러가 난다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> json = <span class="keyword">await</span> response.json()</span><br></pre></td></tr></table></figure><p>고통을 교훈으로 헤더를 확인했다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'content-type'</span>: [ <span class="string">'application/x-www-form-urlencoded; charset=utf-8'</span> ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>두번 반성한다. 리턴값도 당연히 <code>JSON</code> 일리가 없었다. <code>response.text()</code> 도 가능하지만 요청 헤더에 <code>Accept</code> 를 추가했다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">    <span class="string">'Accept'</span>: <span class="string">'application/json'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 잘 날아온다. <span class="github-emoji" title="boxing_glove" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f94a.png?v8">&#x1f94a;</span></p><h2><span id="다시-한번-헤더의-중요성-다시-한번-서버는-서버-엔지니어의-마음">다시 한번 헤더의 중요성, 다시 한번 서버는 서버 엔지니어의 마음</span></h2><p><strong>API</strong> 를 사용하다보면 헤더도 마음데로 들어온다. 서버리스의 <strong>serverless offline</strong> 플러그인을 통하면 <code>event.headers.referer</code> 가 들어오는데 반해 실제 서버에 디플로이되면 <code>event.headers.Referer</code> 가 들어온다. 이 경우는 플러그인 버그라 할 수 있겠지만 대소문자도 예단해선 안된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;이 것도 한 3번인가 삽질을 한 것 같은데.. 기록을 해두지 않아 매번 삽질을 한다. 오늘도 4시간 정도 날린거같다…&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;span id=&quot;3-티어-인증-프로세스&quot;&gt;3 티어 인증 프로세스&lt;/s
      
    
    </summary>
    
    
      <category term="github" scheme="http://blog.bglee.me/tags/github/"/>
    
      <category term="OAuth" scheme="http://blog.bglee.me/tags/OAuth/"/>
    
      <category term="login" scheme="http://blog.bglee.me/tags/login/"/>
    
      <category term="깃허브" scheme="http://blog.bglee.me/tags/%EA%B9%83%ED%97%88%EB%B8%8C/"/>
    
      <category term="로그인" scheme="http://blog.bglee.me/tags/%EB%A1%9C%EA%B7%B8%EC%9D%B8/"/>
    
      <category term="404" scheme="http://blog.bglee.me/tags/404/"/>
    
  </entry>
  
  <entry>
    <title>서평. 진화된 마케팅 그로스 해킹</title>
    <link href="http://blog.bglee.me/posts/2018/review-%E1%84%8C%E1%85%B5%E1%86%AB%E1%84%92%E1%85%AA%E1%84%83%E1%85%AC%E1%86%AB-%E1%84%86%E1%85%A1%E1%84%8F%E1%85%A6%E1%84%90%E1%85%B5%E1%86%BC-%E1%84%80%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%B3-%E1%84%92%E1%85%A2%E1%84%8F%E1%85%B5%E1%86%BC/"/>
    <id>http://blog.bglee.me/posts/2018/review-진화된-마케팅-그로스-해킹/</id>
    <published>2018-08-02T09:38:38.506Z</published>
    <updated>2018-08-02T09:59:28.304Z</updated>
    
    <content type="html"><![CDATA[<p><img src="growth-hacking.png" alt="growth-hacking"></p><p>초반을 제외하고는 읽는 내내 상당히 괴로웠다. <strong>그로스 해킹</strong> 이었구나 라고 충분히 이해할 수 있었음에도 불구하고 너무나도 반복적이라 읽은 글이 5초 이후에 기억이 안나 같은 부분을 계속 읽은 것 같다. 책 자체는 그로스 해킹이 적용되지 않은 것 같아 아쉽다.</p><p><strong>그로스 해킹</strong> 은 용어 자체가 마케팅적으로 훌륭하게 정립됐다. 용어 자체만으로 관심을 끌기에 충분하다.</p><h2><span id="그로스-해킹">그로스 해킹</span></h2><p>그로스 해킹은 정의를 한번에 내리기에는 너무 광범위 하다. 추적 데이터를 기반으로한 분석, 실험 설계, 적용, 수정 정도의 서클이라고 생각하면 쉬울 것 같다. 누군가는 이미 너무 많이 가지고 있는 지식과 직관을 기반으로 이런 실험으로 도출 할 수 있는 단계를 건너 띌 수도 있다 생각한다.</p><p>그럼에도 불구하고 모든 면을 다 분석하기에는 무리며 일반적인 사람들로 이루어진 집단은 이런 그로스 해킹 싸이클을 통해 검증된 데이터를 얻고 이를 통해 설득의 커뮤니케이션을 비용을 낮추고 성장에 다가갈 수 있다.</p><p>그로스 해킹은 심리적인 영역부터 시작하여 상당히 많은 영역을 포괄하며 실험할 수 있는 모든 분야에 적용된다.</p><h2><span id="아쉬운-점">아쉬운 점</span></h2><p>아마도 저자가 마케터로 생각되는데 책이 후반부로 갈 수록 이메일, 설문조사 영역으로 치우치는 점은 아쉽다. 아마도 책에서 그로스 해킹, 깔데기 분석 등 몇 가지 단어만 줄여도 분량이 대폭 줄 것 같다. 특히 깔데기 분석같은 건 100번을 읽어도 직관적으로 다가오지 않아 역자분께 아쉬운 느낌이 있다. 왜 이렇게 안읽히나 계속 읽어보면 문장은 정상인데 접속사가 많아서 그런지 잘 읽히지 않는다.</p><p>내 문제인지, 아님 너무 직역이라 어색한 것인지, 아님 안읽히는 문장을 매우 천천히 계속 적으로 시도해도 읽는다 하더라도 이미 초반 챕터에서 설명한 부분과 다르지 않을거라는 이미 실망이 마음에 반영됐을지 모른다.</p><h2><span id="그럼에도">그럼에도</span></h2><p>책 그로스 해킹이란 개념을 심어주기에는 충분하다 중간까지 읽으면 충분하지 않을까 한다. 너무 두껍다. 좀 더 얇았어야 했다.</p><p>그로스 해킹은 광범위 함에도 불구하고 데이터에 기반하여 개인화 단계까지 추적한다는 개념 자체는 직관적이면서도 누구나 공감 할, 그러나 이름이 붙어 있지 않았던 영역이라고 생각되기 때문에 이해가 된다. 정책이 명확하다랄까?</p><p>어렵지 않은 내용을 너무 많은 예를 들어 접속사가 많은 문장으로 설명하다보니 결국 책을 끝까지 읽지 못했다. 시간도 오래걸리고 10번은 더 잠든거 같다. 의무가 된거같아 2챕터를 남기고 접었다. 평가는 좋은거 보니 나한테만 지루했을 지 모르겠다.</p><p>이미 책을 읽는 순간에 데이터레이크 구성에 대해 관심이 고정됐다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;growth-hacking.png&quot; alt=&quot;growth-hacking&quot;&gt;&lt;/p&gt;&lt;p&gt;초반을 제외하고는 읽는 내내 상당히 괴로웠다. &lt;strong&gt;그로스 해킹&lt;/strong&gt; 이었구나 라고 충분히 이해할 수 있었음에도 불구하고 
      
    
    </summary>
    
    
      <category term="서평" scheme="http://blog.bglee.me/tags/%EC%84%9C%ED%8F%89/"/>
    
      <category term="창업" scheme="http://blog.bglee.me/tags/%EC%B0%BD%EC%97%85/"/>
    
      <category term="스타트업" scheme="http://blog.bglee.me/tags/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85/"/>
    
      <category term="마케팅" scheme="http://blog.bglee.me/tags/%EB%A7%88%EC%BC%80%ED%8C%85/"/>
    
      <category term="그로스 해킹" scheme="http://blog.bglee.me/tags/%EA%B7%B8%EB%A1%9C%EC%8A%A4-%ED%95%B4%ED%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>세미나, 스타트업의 노무인사관리</title>
    <link href="http://blog.bglee.me/posts/2018/seminar-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85%EC%9D%98-%EB%85%B8%EB%AC%B4%EC%9D%B8%EC%82%AC%EA%B4%80%EB%A6%AC/"/>
    <id>http://blog.bglee.me/posts/2018/seminar-스타트업의-노무인사관리/</id>
    <published>2018-07-28T13:00:23.000Z</published>
    <updated>2018-07-28T13:00:23.199Z</updated>
    
    <content type="html"><![CDATA[<p>어제(2018-07-27) <strong>스타트업의 노무 인사관리</strong> 라는 세미나(주최측에선 아카데미라 부른다)에 참석했다. 저번엔 <strong>팀 빌딩</strong> 에 들으러 참석을 했었는데 생각보다 좋은 내용이 많다.</p><p>마침 집하고도 가까워서 좋은 내용이 있으면 자주 가려고하는데 노무인사관리에 대해 들은 감상은 민방위를 다녀왔을때와 비슷하다.</p><p>강사님도 매우 열정적이셔서 많은걸 배울 수 있었다. 2시간을 초과해서 2시간 반이나 진행됐다.</p><h3><span id="민방위">민방위</span></h3><p>민방위는 주방에서 불났을 때 대응 방법, 지진시 대피, 아파트 화재시 완강기 사용법, 소화기 사용법, 심폐소생술 등 매우 살아가는 필요한 것들을 알려준다. 민방위라는게 예비군의 연장선이라서 남자만 듣는지 모르겠으나 모두에게 필요한 매우 중요한 내용들을 가르친다고 생각이 들었었다.</p><h3><span id="인사노무관리">인사노무관리</span></h3><p>인사노무관리도 다르지 않다. 창업 아카데미라는 이름의 커리큘럼이지만 노동자와 사용자 모두에게 중요하다. 아무래도 예전에 노동 집약적 산업을 기준으로 설계된 감이 없지 않다. 그 만큼 노동자의 권리가 매우 강한 느낌인데 때문에 사용자 측에선 채용에 더 신중해 질 수 밖에 없을 것 같다.</p><p>IT 분야에서는 일반 노동자가 아닌 지식 노동자고, 계속 적으로 성장하며 그에 따라 대체 불가능해진다. 때문에 스스로도 회사가 더러우면 다른데가면 그만이라는 인식과, 이직의 일상화, 당연히 평생직장은 같은 것 생각 안함으로 생각했는데 내 생각일 수 있으니 채용은 매우 신중해야한다고 느껴진다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;어제(2018-07-27) &lt;strong&gt;스타트업의 노무 인사관리&lt;/strong&gt; 라는 세미나(주최측에선 아카데미라 부른다)에 참석했다. 저번엔 &lt;strong&gt;팀 빌딩&lt;/strong&gt; 에 들으러 참석을 했었는데 생각보다 좋은 내용이 많다.&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="창업" scheme="http://blog.bglee.me/tags/%EC%B0%BD%EC%97%85/"/>
    
      <category term="스타트업" scheme="http://blog.bglee.me/tags/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85/"/>
    
      <category term="노무" scheme="http://blog.bglee.me/tags/%EB%85%B8%EB%AC%B4/"/>
    
      <category term="인사" scheme="http://blog.bglee.me/tags/%EC%9D%B8%EC%82%AC/"/>
    
  </entry>
  
  <entry>
    <title>서평, 권도균의 스타트업 경영 수업</title>
    <link href="http://blog.bglee.me/posts/2018/review-%EA%B6%8C%EB%8F%84%EA%B7%A0%EC%9D%98-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85-%EA%B2%BD%EC%98%81-%EC%88%98%EC%97%85/"/>
    <id>http://blog.bglee.me/posts/2018/review-권도균의-스타트업-경영-수업/</id>
    <published>2018-07-26T16:20:01.000Z</published>
    <updated>2018-07-28T05:12:35.925Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="서평-권도균의-스타트업-경영-수업">서평, 권도균의 스타트업 경영 수업</span></h1><p><img src="cover.jpg" alt="xxlarge"></p><blockquote><p>이번엔 스타트업의 경영에 대해 알고 싶어 이 책을 선택했다.</p></blockquote><p><strong>경영</strong> 에 대해 무지하기 때문에 사기전에 경영이 문과인지 이과인지 부터 검색했다. <span class="github-emoji" title="ram" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f40f.png?v8">&#x1f40f;</span> 그냥 말로 풀어진 책이었다. 수치나 이런게 나올 수도 있겠다 했었는데 그냥 읽을 수 있는 책이었다. <span class="github-emoji" title="laughing" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f606.png?v8">&#x1f606;</span> 역시 좋은 책이고 뭐라도 읽어야하는 나에게 또 지식과 경험을 줬다.</p><h3><span id="구성">구성</span></h3><p>무려 12챕터에 챕터당 10개정도의 소 주제를 가지고 이루어져있다. 필요한 부분만 찾아보기에 좋을 것 같고 저자의 경험을 위주로 씌여져있다.</p><h3><span id="내용">내용</span></h3><p>원론적이고 바른 얘기가 많이 쓰여져 있다.</p><h3><span id="공감">공감</span></h3><p>아래는 주인공이 나구나 (하아…)🍶 하면서 읽은 부분들 중 몇가지다.</p><h4><span id="기업가-정신의-네가지-특징">기업가 정신의 네가지 특징</span></h4><p>저자는 보통 기업가 정신이라 하면 <strong>피상적이고 모호하며 사람마다 다르게 해석되는</strong> 말로 정의 하고 있다고 말하며 자신이 본 네가지를 말한다.</p><blockquote><p>낙관주의</p></blockquote><p>낙관주의에 대해 저자는 미래 지향성을 이야기한다. 현재보다 미래에 배팅하고 움직인다. 저자의 생각에 첨언을 하자면 공무원이 안정적이라 하여 지금 공무원을 준비하는 것은 사람에 따라서 미래에도 그 일이 가장 안정적이라 생각하기 배팅하는 것일 수 있다. 그런데 여기서 이미 안정적을 추구한다는 모순이 있다. 이경우는 미래 지향적이지 않다. 현재에서 발전하지 않을 것이라 생각하는 것이므로, 보다 나은 내일에 낙관한다.</p><blockquote><p>주도성</p></blockquote><p>주도성이라 한다면 누구나 <strong>“나는 주도적인데?”</strong> 할 수 있다. 저자는 예를 들어 설명한다. 금융 기관보다 자신이 직접 돈을 관리하는 것. <span class="github-emoji" title="smile" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f604.png?v8">&#x1f604;</span> 직접 경기에 뛰어 들어 흐름을 바꾸고자 하는 사람들이다.</p><blockquote><p>책임감</p></blockquote><p>주도성과 연관성이 깊어 보인다. 주어진 상황을 타박하지 않고 경기를 뛰는 선수처럼 심판의 오심도 경기의 일부인 것을 받아들인다. 저자는 일본 경영 컨설턴트 <strong>하마구치 다카노리</strong> 의 말을 인용한다.</p><p>“경영자는 눈이 내리는 것도 내 책임이라고 말해야한다.”</p><blockquote><p>결과중심적 사고</p></blockquote><p>기업가는 행동하는 사람이다. 경영을 통해 <strong>경제적 성과</strong> 를 실체화 한다. 몽상가가 아니다. 수필가도 아니다.</p><h4><span id="시작은">시작은</span></h4><p>가능한 부담 없는 상태를 유지해야한다. 매출과 자본이 없는 상태에서의 고용, 사업자 등록, 의리와 팀의 오해등이다.</p><h4><span id="채용">채용</span></h4><p>채용은 너무도 중요하다. 저자는 <strong>사람은 변하지 않는다</strong> 라는 가정을 여러 인용을 통해 말하며 그만큼 중요하다 이야기한다. 채용은 <strong>일을 얼마나 잘 하느냐</strong> 보다 내가 만드려는 문화를 <strong>보존할 수 있는가?</strong> 에 더 초점을 맞춰야한다고 말한다. 특히 초반엔</p><hr><h4><span id="비즈니스의-터">비즈니스의 터</span></h4><p>나는 돈이 내게 잠깐 흐르게 하는 것이라 생각하고 그 돈의 물줄기가 나에게도 오도록 강 근처에 땅을 파서 내 근처에도 흐르게 한다는 생각을 주로했었는데 저자도 비슷한 표현을 했다. 아이디어에서도 비슷한 생각을 볼 수 있었는데 대충 이런 거다.</p><p>뭔가 자신이 대단한 아이디어를 생각해냈다고 생각하고 취할 수 있지만 그 아이디어의 작동 여부는 고객에 의해서 판단된다는 것이다. 저자는 <strong>흐르는 강물에 배를 띄워라</strong> 라고 말을 한다.</p><p>사업 아이템은 고객들이 필요로하는 그 곳에 생성하는 것이지 자신이 시장을 만들고나면 사람이 오는 그런게 아니라는 뜻이다. 비슷한 생각을 가지고 있다. 난 이런 생각을 <strong>니즈의 자연 발생</strong> 이라고 말하곤 한다. 예를 들면 이런거다.</p><blockquote><p>뭘 지원하려고 하면 주민등록등본을 스캔해서 보내란다.</p></blockquote><p>그럼 이걸 주민센터가서 발급하고 스캔해서 메일로 보내는데 왜이렇게 불편하게 하는건가? 한참 이전에 발전된 인증 기술을 이용해서, 서비스에 접속해서 회사에서 받을 수 있도록 인가해주면 회사에서 직접 출력하게 하면 누구에게 제출되었는지까지 추적되고, 더 투명하고, 더 편하지 않은가?</p><p>많은 사람들이 고통받고 있는 것, 필요로 하는 곳에 사업을 트면된다. 하고자 하는 것을 하고 사람들이 사용하길 바라는 것이 아니다.</p><h4><span id="지표">지표</span></h4><p>책에서 <strong>지표</strong> 의 중요성을 설명한다. 근데 포커스는 측정이 아닌 선택이다. 무엇을 지표로 선택하는지는 고객의 반응을 어떻게 해석할지, 이해할지에 대한 것이기 때문에 매우 중요하며 경영자 본인이 판단해야한다.</p><p>이 부분이 “호오?” 하면서 봤는데, 서비스를 하면서 중요한 데이터를 뽑아내고 수치화하고 이걸 다시 적용하는 사이클을 갖는 시스템(자동화)을 만드는 것, 이 부분이 엔지니어로써 매우 탐나면서도 수긍이 가능 부분이었다. 사실 대부분의 회사에서 이미 하고 있을텐데 생각없이 애널리틱스 하나 뿌려놓고 있는게 아니라 지표 자체도 비즈니스마다 필요한 것을 제대로 설정해서 그를 달성하는 것, 이것은 중요하고 재밌을 것 같다.</p><h4><span id="팀">팀</span></h4><p>저자는 다른 사람의 글도 많이 인용하는데 이 부분이 사실 궁금했다. 현실적이면서도 초기 팀을 구성하며 지분을 어떻게 할지, 지금 두권째 읽는 것인데 이에 대한 디테일한 수치는 나오지 않는다. 초기에 창업멤버끼리 C레벨을 구성하는데 실력이 거기에 미치지 못한다는 걸 깨달았는데 어떻게 행동해야 할 것인지, 그런일이 벌어지게 둘 것인가 등 창업을 해보곤 알수 없는 베일을 안을 잠시 들여다 볼 수 있었다.</p><h4><span id="계약">계약</span></h4><p>계약도 창업 경험이 없는 사람에게는 블랙박스인데 이 부분에 대해서도 꽤나 갈증을 풀어준다. 연봉 협상이랑 다를바가 없어보인다. 역시 최고의 협상카드는 <strong>“안할래요”</strong> 인가 ㅋㅋ</p><h3><span id="요약">요약</span></h3><p>개인 정리라 두서가 없다. 한번읽고 서머리 할 분량은 아니었다. 좋은 책이고 궁금한 걸 말해준다. 내용이 꽤 되는데다가 같은 류의 생각을 가진 것 같아 멍한 상태로 읽으면 기억에 남지 않는다. 공감을 많이해서 당연한말이 많아서 그런 것 같은데, 난 옳은 말이기 때문에 당연한 말이라고 생각한다, 다시 한번 되새길 수 있는 시간을 갖게 하고, 경험에서 나오는 실질적인 조언을 해준다.</p><p>저자를 조금 찾아보니 최근 인터뷰에 왜 한국에선 유니콘이 안나오느냐 묻자. 경영이 문제라 한다.</p><p>저자가 책에서 쉽게 풀어쓴 것인지 모르겠으나 경영은 특별한 학문 같은게 아니었다. 뭐랄까 회사 생활 하는 방법처럼 회사 굴리는 타이쿤 게임 공략본 같은…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;서평-권도균의-스타트업-경영-수업&quot;&gt;서평, 권도균의 스타트업 경영 수업&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;cover.jpg&quot; alt=&quot;xxlarge&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;이번엔 스타트업의 경영에 대해 알
      
    
    </summary>
    
    
      <category term="서평" scheme="http://blog.bglee.me/tags/%EC%84%9C%ED%8F%89/"/>
    
      <category term="스타트업" scheme="http://blog.bglee.me/tags/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85/"/>
    
      <category term="권도균의 스타트업 경영 수업" scheme="http://blog.bglee.me/tags/%EA%B6%8C%EB%8F%84%EA%B7%A0%EC%9D%98-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85-%EA%B2%BD%EC%98%81-%EC%88%98%EC%97%85/"/>
    
      <category term="경영" scheme="http://blog.bglee.me/tags/%EA%B2%BD%EC%98%81/"/>
    
  </entry>
  
  <entry>
    <title>서평, 장병규의 스타트업 한국</title>
    <link href="http://blog.bglee.me/posts/2018/review-%EC%9E%A5%EB%B3%91%EA%B7%9C%EC%9D%98-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85-%ED%95%9C%EA%B5%AD/"/>
    <id>http://blog.bglee.me/posts/2018/review-장병규의-스타트업-한국/</id>
    <published>2018-07-20T15:05:26.000Z</published>
    <updated>2018-07-20T15:07:40.428Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="서평-장병규의-스타트업-한국">서평, 장병규의 스타트업 한국</span></h1><blockquote><p>읽은지 4-5일 됐다고 벌써 기억이 가물거리는걸 보니 역시 정리는 빠르면 빠를 수록 좋다.</p></blockquote><p><img src="cover.jpg" alt="File"></p><h2><span id="궁금했다">궁금했다.</span></h2><ul><li>스타트업은 어떻게 운영되는가?</li><li>스타트업은 어떻게 시작할 수 있는가?</li><li>시작을 하게 되면 지분등은 어떻게 분배되는가?</li></ul><h3><span id="이-책을-고른-이유">이 책을 고른 이유</span></h3><p>목차에 지분 얘기가 있는 책을 이 것 밖에 못 찾아서 이 책을 구매했다. 가격은 고려 대상은 아니었다. 가격도 쌌다. IT 창업자다.</p><h2><span id="결론적으로">결론적으로</span></h2><p>이 책은 훌륭한 책이다. 가격도 싸다. 군더더기 없다. 경험담이다. 솔직히다. 케이스 스터디도 있다.</p><h3><span id="책의-저자">책의 저자</span></h3><p>이 책의 저자인 장병규 대표에 대해 구두로는 많이 들어봤는데 얼굴은 책 표지를 통해 처음 알았다. 배틀그라운드의 성공, 블루홀 스튜디오 정도는 알았는데 호랑이 담배피던 시절의 <strong>원 클릭</strong> 으로 시작했다는 건 알지 못했다. 또 <strong>네오위즈</strong> 의 창업자다. 내 이전 직장 <strong>부동산 다이렉트</strong>의 투자자다.</p><h3><span id="공감">공감</span></h3><p>책을 읽으면서 초반에는 장병규 대표가 생각하는 스타트업, 뭐 그런 것들에 대해 상당히 <strong>공감</strong>을 많이 했다. 기술 서적외에는 사실 거의 읽질 않기 때문에 책 이란게 원래 이런 느낌을 받으면서 읽는 것인지는 모르겠으나 일전에 읽은 <strong>소프트웨어 장인 정신</strong> 이란 책도 상당히 공감을 많이 했다.</p><p>합리화의 귀신 같은 존재인 난 <strong>소프트웨어 장인 정신</strong> 을 읽는 순간 장인이었는데, 이번엔 인맥 없고 끈 없는 장병규 대표였다. <span class="github-emoji" title="thinking" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f914.png?v8">&#x1f914;</span> 일단 생각의 방향성을 느낄 수 있는데 그 점이 와 닿아서 좋았다.</p><p>책의 중간 중간, 해서 4개 정도의 창업자 케이스 소개가 있다. 모두 장병규 대표와 연관성이 있는 사람들로 지금 장병규 대표가 있는 본엔젤스의 투자를 받은 회사라던가, 하여 창업에 대한 스토리텔링이 있다. 재밌는건 여기서 3인칭 화법을 사용하는데… 나쁘지 않았다.</p><h4><span id="케이스-소개">케이스 소개</span></h4><p>이 부분이 꽤나 좋은데 교과서 마냥 케이스를 상당히 다른 것들로 구성해놔서 궁금했던 얘기를 예를 들어 전해 듣는 느낌이랄까? 이런 예에는 성공한 케이스도 있는 반면 망한 케이스도 있다. 이런 것들이 도움이 되려면 공감이 되야하는데 여기서 창업하는 사람들은 창업에 대해 아무 것도 모른체 창업하는 케이스도 포함되어 있었기에 더 도움이 됐다.(유명한 우아한형제들의 이야기도 있다.)</p><h3><span id="조언">조언</span></h3><p>조언에 내 감상은 필요 없을 것 같다. 굳이 조금 말하자면 창업자와 투자자, 그리고 예비(?) 선배로써의 경험에서 나오는 실질적인 충고가 있다. 굳이 책에 거짓을 이야기할 이유도 없겠지만 이러한 충고들에 신뢰성을 더 하는 몇가지 양념 <span class="github-emoji" title="hot_pepper" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f336.png?v8">&#x1f336;</span> 들이있다. 이 글은 주관적인 글이지만 이 부분은 매우 주관적이다.</p><ul><li>배틀그라운드의 성공 이후 성공에 대한 분배를 이토록 하는 기업을 본적이 없다.</li><li>책 가격이 싸다(책으로 돈벌 생각은 없어보인다.)</li></ul><p>공동 창업, 스타트 업의 성장 뭐 이런 내용은 책을 보는게 빠르겠다.</p><h2><span id="추천">추천</span></h2><p>값도 싸고 필요한 말만 들어있는 그런 책이다. 그냥 해주고 싶은 얘기를 하는 것 같은데, 듣는 입장에서 궁금한 것들을 많이 얘기해준다. 저자가 독자를 공감해주는, 그렇게 씌여진 느낌을 받았다. 좋은 책이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;서평-장병규의-스타트업-한국&quot;&gt;서평, 장병규의 스타트업 한국&lt;/span&gt;&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;읽은지 4-5일 됐다고 벌써 기억이 가물거리는걸 보니 역시 정리는 빠르면 빠를 수록 좋다.&lt;/p&gt;&lt;/blockquote
      
    
    </summary>
    
    
      <category term="서평" scheme="http://blog.bglee.me/tags/%EC%84%9C%ED%8F%89/"/>
    
      <category term="창업" scheme="http://blog.bglee.me/tags/%EC%B0%BD%EC%97%85/"/>
    
      <category term="스타트업" scheme="http://blog.bglee.me/tags/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85/"/>
    
      <category term="장병규의 스타트업 한국" scheme="http://blog.bglee.me/tags/%EC%9E%A5%EB%B3%91%EA%B7%9C%EC%9D%98-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85-%ED%95%9C%EA%B5%AD/"/>
    
  </entry>
  
  <entry>
    <title>Typora ♥️  Hexo</title>
    <link href="http://blog.bglee.me/posts/2018/typora-hexo/"/>
    <id>http://blog.bglee.me/posts/2018/typora-hexo/</id>
    <published>2018-07-18T06:15:02.000Z</published>
    <updated>2018-07-20T13:33:23.610Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="typora-hexo-이미지-설정">Typora, Hexo 이미지 설정</span></h1><blockquote><p>⚠️ Typora와 Hexo의 소개는 이 글의 주제가 아니다. Typora 에 대한 소개는 <a href="http://blog.bglee.me/posts/2018/typora/">이전 글</a> 을 참조한다.</p></blockquote><blockquote><p>마크다운 글 작성, 블로그 포스트, <strong>Typora</strong> 하나로 끝을 내자.</p></blockquote><h2><span id="서문">서문</span></h2><p>생산성 때문에 <strong>미디움</strong> 으로 옮겨서 글을 작성한 것이었는데, 미디움의 웹 에디터가 그 다지 성능이 좋지가 않아서 다시 고민중이다.</p><p>대표적인 문제는 두가지다.</p><ul><li>글 작성중 저장이 꼬였다고 리로드하라고 한다.</li><li>코드 하이라이팅이 매우 취약하다.</li></ul><p>반면 여기서 쓰고 있는 Hexo는 지킬과 달리 쓸만한 테마가 그리 많지 않았다. 그렇다고 만들자니… “내가 그런 것 까지?” 하는 생각이 들고, 그나마 마음에 드는 테마를 골라도 시간이 지나면 질리기 마련이니, 여기서 또 시간이 소모된다. 글 생산에 집중하고자 했고 그래서 <strong>미디움</strong> 으로 옮기게 되었다.</p><p>그런데 여기서 가볍게 글을 쓰고자 하는 나의 마음과는 달리 <strong>팔로우</strong> 라는 시스템이 붙어 버리니 조금 부담스럽게 된 것도 사실이다. 많은 사람이 글을 읽으면 더 좋으니까 라는 마음도 있었지만,</p><p>그래서 좀 더 정리 안되면서도 개인적인 쏟아낼 공간이 필요해서 다시 이 곳을 활용하기로 했다.</p><h1><span id="typora-x1f91d-hexo">Typora <span class="github-emoji" title="handshake" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f91d.png?v8">&#x1f91d;</span> Hexo</span></h1><p>Typora 라는 내가 써본 마크다운 에디터중 가장 강력하며 안정화되어 있다. Hexo 는 작성된 마크다운을 가지고 포스팅을 만들어준다.</p><p>그럼 여기서 소개하고자 하는, 해결하고자 하는 문제는 무엇인가?</p><h3><span id="이미지-첨부">이미지 첨부</span></h3><p>이미지 첨부를 하게 되면 Typora 라는 친절하게도 몇가지 옵션을 제시한다. Hexo는 포스팅의 파일 명을 기반으로 동일 명의 디렉토리를 참조하여 이미지를 업로드하고 이를 참조한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── cognito</span><br><span class="line">│   └── federated_identities_logins.png</span><br><span class="line">├── cognito.md</span><br></pre></td></tr></table></figure><p>이런 형태다. 즉, <code>cognito.md</code> 는 <code>cognito</code> 의 참조를 통해야 디플로이시에 문제가 발생하지 않는다.</p><p>문제는 이 설정이 Hexo 의 설정과 맞지 않는다는데 있다.</p><p><img src="typora-config.png" alt="typora-config"></p><p>현재 폴더로 복사와 몇가지 프리셋이 준비되어 있는데 동일 폴더명을 선택할 수 없다. 그래서 플러그인을 작성하려다가 잠시 멈추고 몇 가지 문서를 검색해서 참조하니 간단한 해결책이 있었다.</p><h3><span id="typora-copy-images-to">typora-copy-images-to:</span></h3><p>포스팅 글에는 마크다운 문서 상단부에 <strong>YAML</strong> 포맷으로 메타 정보를 기입할 수 있는데 이 메타 정보는 <strong>HTML</strong> 을 생성하는데 관여하고 글 자체에 영향을 주지는 않는다.</p><p>이런 방식이 블로그 포스팅에 관련해서는 일반적이기 때문인지 이를 활용해서 Typora 에 설정을 주입할 수 있다. 플러그인도 아니고 기존 환경을 이용하는, 이건 뭐 매우 신박한 방식이다.</p><p>결론적으로는 <code>typeora-copy-images-to</code> 속성을 주입놓으면 Typora 강 이를 읽고 설정보다 우선시하여 적용한다. 확인은 드래고 이미지를 넣게 되면 <code>typora-copy-images-to</code> 에 의해 설정된 디렉토리를 읽어 자동으로 복사가 이루어지고 그에 따른 경로도 수정되어진다. :+1:</p><h3><span id="scaffolds">scaffolds</span></h3><p>Hexo 의 디렉토리 구조에 <code>scaffolds</code> 라는 디렉토리가 존재한다. 이 곳을 열어보면 일반적으로 <code>draft.md</code>, <code>page.md</code>, <code>post.md</code> 가 들어있다. 이를 레이아웃이라고 하는데 <strong>cli</strong> 를 통해 포스트(파일)를 기본 구조와 함께 생성할 수 있다.</p><p>문서를 참조하면 기본 레이아웃은 <strong>post</strong> 다. 즉 <code>hexo new &lt;filename&gt;</code> 은 <strong>post</strong>, <code>post.md</code> 파일을 참조해서 생성된다.</p><h4><span id="postmd"><code>post.md</code></span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat scaffolds/post.md</span><br><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">typora-copy-images-to: &#123;&#123; title &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>파일을 열어 보면 위와 같이 되어 있다. <code>typora-copy-images-to</code> 속성을 눈 여겨 보자. 그럼 아까 포스트를 생성하고자 했던 명령어에 실질적으로 파일 이름을 부여해보자. 파일 이름은 타이틀도 함께 매칭된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new typora-hexo</span><br><span class="line">INFO  Created: ~/workspace/src/github.com/deptno/blog/<span class="built_in">source</span>/_posts/typora-hexo.md</span><br><span class="line">✨  Done <span class="keyword">in</span> 1.30s.</span><br></pre></td></tr></table></figure><p>파일이 생성되었다.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: typora-hexo</span><br><span class="line">date: 2018-07-17 14:48:06</span><br><span class="line">typora-copy-images-to: typora-hexo</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>파일을 열어보면 위와 같다. 우리가 주목해야할 것은 <code>typora-copy-images-to</code> 속성이다. 뒤에는 <code></code> 을 매칭해 뒀기 때문에 값은 파일명과 같이 <code>typora-hexo</code> 다.</p><p>때문에 이제 그냥 글을 작성하면서 이미지를 드래그해서 넣으면 알아서 <code>typora-hexo/&lt;image-file&gt;</code> 형식으로 삽입되게 되며 복사 또한 자동으로 이루어져 이미지에 대한 고민에서 해방된다.</p><h2><span id="generate-후-html에서-이미지가-깨지는-문제">Generate 후 HTML에서 이미지가 깨지는 문제</span></h2><p>Hexo 의 설정 파일인 <code>_config.yml</code> 에서 <code>post_asset_folder: true</code> 를 설정하게 되면 `hexo new<filename>을 통해 파일을 생성할때 파일이름과 동일한 어셋 폴더가 자동으로 생성된다.</filename></p><p>우리는 위에서 <code>typora-copy-images-to:</code> 메타 속성의 주입을 통해 이미지 드래그시 파일명과 동일한 디렉토리에 이미지를 복사하게 설정을 해둬서 글을 작성할 때는 이미지 잘 보인다. 문제는 Hexo 가 <code>hexo generate</code> 를 할 때는 이미지를 알아서 어셋 디렉토리를 참조하게 되어어서 발생하는데 이 때문에 생성된 HTML 에서는 이미지가 깨지게 된다.</p><p><code>hexo generate</code> 시 경로를 중복 참조하지 않도록 플러그인을 작성했으니 동일한 이슈로 고통받는 이가 있으면 플러그인을 사용하자.</p><p><a href="https://github.com/deptno/hexo-typora-plugins/tree/master/packages/hexo-typora-image" target="_blank" rel="noopener">https://github.com/deptno/hexo-typora-plugins/tree/master/packages/hexo-typora-image</a></p><p><code>hexo generate</code> 전에 플러그인을 인스톨하면 자동으로 적용된다.</p><h3><span id="터미널에서-typora-를-통해-markdown-열기">터미널에서 Typora 를 통해 markdown 열기</span></h3><p>Hexo 에서 템플릿(scffold)을 통해 파일을 생성하기 위해서는 <strong>terminal</strong> 을 이용해야하므로 Typora 또한 터미널에서 열 수 있어야 작은 스트레스를 면할 수 있다.</p><h4><span id="alias">alias</span></h4><p>Typora 의 공식 문서에 칠절하게 나와있어서 한줄 복사해서 사용하는 쉘의 설정파일에 추가하면된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> typora=<span class="string">"open -a typora"</span></span><br></pre></td></tr></table></figure><p>난는 개인적으로 <strong>zsh</strong> 을 이용하고 있으므로 <code>~/.zshrc</code> 파일이다. 이렇게 하면 쉘에서 파일을 생성한후 타이포라를 통해 바로 열 수 있다. <code>typora typora-hexo.md</code> <span class="github-emoji" title="ram" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f40f.png?v8">&#x1f40f;</span></p><hr><h2><span id="참조">참조</span></h2><ul><li><p><a href="https://hexo.io/ko/docs/writing.html" target="_blank" rel="noopener">https://hexo.io/ko/docs/writing.html</a></p></li><li><p><a href="https://support.typora.io/Use-Typora-From-Shell-or-cmd/" target="_blank" rel="noopener">https://support.typora.io/Use-Typora-From-Shell-or-cmd/</a></p></li><li><a href="https://support.typora.io/Images/#when-insert-local-image" target="_blank" rel="noopener">https://support.typora.io/Images/#when-insert-local-image</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;typora-hexo-이미지-설정&quot;&gt;Typora, Hexo 이미지 설정&lt;/span&gt;&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;⚠️ Typora와 Hexo의 소개는 이 글의 주제가 아니다. Typora 에 대한 소개는 &lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="typora" scheme="http://blog.bglee.me/tags/typora/"/>
    
      <category term="hexo" scheme="http://blog.bglee.me/tags/hexo/"/>
    
      <category term="typora image" scheme="http://blog.bglee.me/tags/typora-image/"/>
    
  </entry>
  
  <entry>
    <title>Cognito, Multi IDP Login 분석</title>
    <link href="http://blog.bglee.me/posts/2018/cognito/"/>
    <id>http://blog.bglee.me/posts/2018/cognito/</id>
    <published>2018-07-16T18:00:00.000Z</published>
    <updated>2018-07-17T16:43:30.661Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><span class="github-emoji" title="warning" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/26a0.png?v8">&#x26a0;</span> 작성 중</p></blockquote><blockquote><p><span class="github-emoji" title="warning" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/26a0.png?v8">&#x26a0;</span> 개인적인 정리라 확실성을 띄는 단어를 사용하지만 실제론 그렇지 않을 수 있다.</p></blockquote><blockquote><p>이 글은 목적이 존재하며 Cognito 의 소개 글이 아니다. Cognito 는 AWS 문서를 참조 바란다.</p></blockquote><blockquote><p>현재라는 문구가 사용되면 작성 시점인 2018년 7월 17일이다.</p></blockquote><p><code>사용자 풀</code> 과 <code>연동 자격 증명 풀</code> 두 가지가 존재하며 각각 따로 생성이 가능하며 연동도 가능하다. 궁극적으로 알고자 하는 것은 아래 와 같다.</p><ol><li>여러 IDP의 로그인을 통해 정보를 취합하는 앱을 만들경우 이 로그인 정보들을 어떻게 취합해서 어떻게 관리할 것인가?</li><li>사용자 풀 에서도 IDP 를 연동할 수 있고, 연동 자격 증명에서도 사용자 풀과 여타 IDP 연결이 가능한데, 무엇이 다른가?</li></ol><p>특별히 궁금한 부분은 AWS 문서에도 <a href="https://docs.aws.amazon.com/ko_kr/cognito/latest/developerguide/cognito-user-pools-identity-federation.html" target="_blank" rel="noopener">노트</a>로도 표시되어 있다.</p><blockquote><p>참고</p><p>타사(연동)를 통한 로그인을 Amazon Cognito 사용자 풀에서 사용할 수 있습니다. 이 기능은 Amazon Cognito 자격 증명 풀(연동 자격 증명)을 통한 연동과 무관합니다.</p></blockquote><p>결국 두 방식은 다르다는 뜻으로 해석되며 <strong>2 번과 관련해서는 예상 되는 결과</strong> 는 아래와 같다.</p><ul><li><p>사용자 풀 베이스</p><p>회원가입 후 로그인 이후에 IDP 로그인을 지원하며 이에 따라 정보가 자연스럽게 취합이 가능.</p></li><li><p>연동 자격 증명 베이스</p><p>로그인 퍼스트 전략으로 인증된 IDP와 앱이라면 일단 로그인이 가능하며 그에 따른 인가가 이루어짐.</p></li></ul><h2><span id="사용자-풀">사용자 풀</span></h2><p>사용자 풀은 자체 DB를 갖는 일반적인 구현 형태와 같다. 때문에 회원 가입, 회원 정보, 로그인 방식(MFA 와 같은), SMS, Email 인증등을 전반적으로 제어 할 수 있다.</p><h3><span id="연동-gt-자격-증명-공급자">연동 &gt; 자격 증명 공급자</span></h3><p>일단 연동 자격 증명과는 달리 입력 요구사항이 다르다.</p><blockquote><p>ID(Client ID) 외에 앱 보안(Secret Key)를 요구하고 인증 범위(Scope)에 대한 지정이 가능하다. 명시적(explicit) 또는 3-way 로그인 방식에서 쓰이는 요구 사항과 같으며 이에 대한 뒷 작업을 Cognito가 해주는 것으로 예상 된다.</p></blockquote><h4><span id="현재-지원되는-idp">현재 지원되는 IDP</span></h4><ul><li>Facebook</li><li>Google</li><li>Login with Amazon</li><li>SAML</li><li>OpenID Connect</li></ul><h3><span id="연동-gt-속성">연동 &gt; 속성</span></h3><blockquote><p>IDP 로그인을 통해 들어온 정보와 가입시의 정보가 다른 경우 어떤 정보가 저장되는가?</p></blockquote><hr><h2><span id="연동-자격-증명federated-identities">연동 자격 증명(Federated Identities)</span></h2><p>기본적으로는 <strong>사용자 풀</strong> 없이도 단지 인증된 <strong>IDP</strong>와 <strong>앱 정보</strong>를 통해 유저를 인증하고 <strong>롤</strong>(IAM)에 따라 인가할 수 있다. 간단한 어플리케이션에서 유용할 것으로 보인다.</p><h3><span id="자격-증명-풀-편집">자격 증명 풀 편집</span></h3><p><strong>인증되지 않은 역할</strong>, <strong>인증된 역할</strong>에 IAM을 할당하여 권한을 지정 함</p><h3><span id="인증-공급자">인증 공급자</span></h3><p><strong>인증 공급자(Identity Provider - IDP)</strong>를 등록한다. 인증 공급자는 OAuth를 지원 업체로 생각 할 수 있다.</p><p><strong>IDP</strong> 등록을 위해서는 각 <strong>IDP</strong> 에서 생성한 App ID 가 필요하며 여기서 등록해 둔다.</p><blockquote><p><code>예제 0</code> 페이스북을 통해 얻은 토큰 등록</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AWS.config.credentials = <span class="keyword">new</span> AWS.CognitoIdentityCredentials(&#123;</span><br><span class="line">    IdentityPoolId: &lt;연동 자격 증명 풀 ID&gt;,</span><br><span class="line">    Logins        : &#123;</span><br><span class="line">        'graph.facebook.com': response.authResponse.accessToken&lt;Facebook access token&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>이렇게 <code>credentials</code> 를 등록함으로써 로그인이 된 것으로 간주하고 <strong>인증된 역할</strong> 의 권한을 얻는다.</p><h4><span id="여러-idp를-통해-로그인이-필요한-경우">여러 IDP를 통해 로그인이 필요한 경우</span></h4><p>여러 IDP를 통해서 로그인이 필요한 경우에는 각 로그인마다 다른 유저로 인식 되므로 이전 로그인 정보를 취합하여 다시 저장할 필요가 있다. 즉, <code>Logins</code> 의 오브젝트를 확장해야한다. 코드로 표현하면 다음과 같을 것으로 보인다.</p><blockquote><p><code>예제 1</code> 여러 IDP 토콘을 저장하는 경우</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AWS.config.credentials = <span class="keyword">new</span> AWS.CognitoIdentityCredentials(&#123;</span><br><span class="line">    IdentityPoolId: &lt;연동 자격 증명 풀 ID&gt;,</span><br><span class="line">    Logins        : &#123;</span><br><span class="line">        'graph.facebook.com': response.authResponse.accessToken&lt;Facebook 억세스 토큰&gt;,</span><br><span class="line">    'cognito-idp.&lt;리전&gt;.amazonaws.com/&lt;유저풀 ID&gt;': result.getIdToken().getJwtToken()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p><code>예제 2</code> 순서가 정의되고 이미 <code>credentials</code> 이 이미 등록어 있어 이를 확장하는 경우</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AWS.config.credentials = <span class="keyword">new</span> AWS.CognitoIdentityCredentials(&#123;</span><br><span class="line">    IdentityPoolId: &lt;연동 자격 증명 풀 ID&gt;,</span><br><span class="line">    Logins        : &#123;</span><br><span class="line">        ...AWS.config.credentials,</span><br><span class="line">    'cognito-idp.&lt;리전&gt;.amazonaws.com/&lt;유저풀 ID&gt;': result.getIdToken().getJwtToken()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4><span id="현재-지원되는-idp-목록">현재 지원되는 <strong>IDP</strong> 목록</span></h4><ul><li>Cognito</li><li>Amazon</li><li>Facebook</li><li>Google+</li><li>Twitter / Digits</li><li>OpenID</li><li>SAML</li><li>사용자 지정</li></ul><h4><span id="use-case">Use Case</span></h4><h5><span id="두개의-idp-facebook-으로-로그인-후-cognito-로-다시-인증하는-경우">두개의 IDP: Facebook 으로 로그인 후, Cognito 로 다시 인증하는 경우</span></h5><p><code>예제 0</code> 의 코드와 같은 방식으로 두번 각기 등록하는 경우는 유저가 2명으로 인식되나 <code>Logins</code> 에 두 정보를 함께 등록하는 경우 이 정보가 취합되어 한명의 유저로 인식된다.</p><p><code>Logins</code> 에 한번이라도 함께 등록되면 각기 다른 <strong>IDP</strong>에 의해 발급된 두개의 토큰은 함께 연결되는 것으로 보인다. 때문에 함께 저장하는 순간 유저 수 인식이 2 에서 1명으로 변경된다.</p><p><img src="federated_identities_logins.png" alt="federated_identities_logins"></p><p>위 이미지는 <code>Logins</code> 에 함께 저장 후 대쉬보드의 화면이며 <strong>Facebook</strong> 로그인(파란색)과 <strong>Cognito</strong> 로그인(녹색)이 각각 카운트가 1이나 총 자격 증명이 1 로 인식되는 걸 확인 할 수 있다. 함께 저장하기 전에는 총 자격 증명이 2 였다.</p>]]></content>
    
    <summary type="html">
    
      Cognito, multi IDP login
    
    </summary>
    
    
      <category term="cognito" scheme="http://blog.bglee.me/tags/cognito/"/>
    
      <category term="multi idp" scheme="http://blog.bglee.me/tags/multi-idp/"/>
    
      <category term="idp" scheme="http://blog.bglee.me/tags/idp/"/>
    
      <category term="user pool" scheme="http://blog.bglee.me/tags/user-pool/"/>
    
      <category term="federated Identities" scheme="http://blog.bglee.me/tags/federated-Identities/"/>
    
  </entry>
  
  <entry>
    <title>✒️  Typora, 마크다운 에디터</title>
    <link href="http://blog.bglee.me/posts/2018/typora/"/>
    <id>http://blog.bglee.me/posts/2018/typora/</id>
    <published>2018-07-16T04:48:06.000Z</published>
    <updated>2018-07-19T09:31:34.616Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="typora-마크다운-에디터-소개">Typora, 마크다운 에디터 소개.</span></h1><blockquote><p>Typora 를 주제로 Typora 를 사용하여 글 작성을 테스트 중이다. <span class="github-emoji" title="cat2" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f408.png?v8">&#x1f408;</span> 때문에 글 자체 보다는 이를 통해서 블로그 포스팅에 대한 생산성 검증 목적이 있다.</p></blockquote><h2><span id="마크다운-에디터-연대기">마크다운 에디터 연대기</span></h2><p>사용하는 혹은 사용했었던 에디터들이다.</p><table><thead><tr><th>에디터</th><th>평</th></tr></thead><tbody><tr><td><a href="http://www.vim.org" target="_blank" rel="noopener">ViM</a></td><td><a href="https://github.com/vim/vim" target="_blank" rel="noopener">오픈소스</a>, 지금도 간혹 쓴다. 한글 사용시 ViM 커맨드에 대한 고질적인 문제, 외부 프리뷰 이슈, 플러그인 설정 필요.</td></tr><tr><td><a href="https://bywordapp.com" target="_blank" rel="noopener">Byword</a></td><td>앱스토어 추천, 할인에 샀으나 특이점 없음.</td></tr><tr><td><a href="http://pad.haroopress.com" target="_blank" rel="noopener">하루패드</a></td><td><a href="https://github.com/rhiokim/haroopad" target="_blank" rel="noopener">오픈소스</a>, 독립 프로개름으로는 아마도 ViM을 지원하는 유일한 에디터가 아닐까한다. 국내 개발자이신 <a href="https://github.com/rhiokim" target="_blank" rel="noopener">Rhio</a> 님이 개발했다.</td></tr><tr><td><a href="https://code.visualstudio.com" target="_blank" rel="noopener">VSCode</a></td><td><a href="https://github.com/Microsoft/vscode/" target="_blank" rel="noopener">오픈소스</a>, 마소의 오픈소스 에디터, 마크다운을 기본적으로 지원.</td></tr><tr><td><a href="http://jetbrains.com/webstorm" target="_blank" rel="noopener">Webstorm</a></td><td>개발 툴인데 붙어 있으니 가끔 <code>README.md</code> 작성용으로 사용</td></tr><tr><td><a href="https://marktext.github.io/website/" target="_blank" rel="noopener">MarkText</a></td><td><a href="https://github.com/marktext/marktext" target="_blank" rel="noopener">오픈소스</a>, 가장 최근에 사용했던 에디터, 테이블 삽입, 에디팅과 프리뷰가 함께 어우러진 것이 인상적.</td></tr></tbody></table><p>한동안 미디움에서 글을 쓰고 있었는데 <a href="https://typora.io" target="_blank" rel="noopener">Typora</a> 라는 끝내주는 마크다운 에디터를 발견했다. 사실 본지는 좀 오래되었는데 최근에 쓰고 있던 마크다운 에디터가 만족스러워서 시도는 하지 않고 있다가 한글 타이핑시 문장 마지막에 <code>Tab</code> 입력시 글자가 사라지는 버그로 인해 고생해서 옮겨타게 되었다.</p><h2><span id="typora">Typora</span></h2><p>타이포라는 아직 베타 버전이며 곧 상용화 될 것으로 보인다. 안정적이며 별 버그가 없다. 테마도 다양하게 지원되고 있으며 마크다운을 통해 작성되며 글은 바로 테마가 입혀진 모습으로 보여진다. 프리뷰와 에디터가 빌트인 된 것으로 생각하면 된다.</p><h3><span id="이모지emoji">이모지(emoji)</span></h3><p>이모지를 훌륭하게 지원한다. 찾아볼 필요없이 <code>:</code> 를 입력하는 순간 자동 완성이 이미지와 함께 지원된다.</p><h3><span id="테이블">테이블</span></h3><p>일반적인 에디터를 이용할 때 가장 문제가 되는 것은 테이블 작성이다. 테이블 작성 문법이 시간이 오래걸려 여기서 생산성에 대한 이슈가 생기는데 커맨드를 통해 빠르고 직관적으로 테이블 생성이 가능하다.</p><h3><span id="이미지">이미지</span></h3><p>이미지 지원도 다소 짜증이 나는 영역인데, 블로그 글을 포스팅 할 때 이미지를 그냥 드래그해서 붙일 수 있다. 또한 그 것을 같은 폴더에 저장할 것인지 등도 정할 수 있으므로 사용성이 꽤나 최적화 되어있다.</p><h2><span id="모자란-점">모자란 점</span></h2><p>정말로 쓸 수 있는 프로그램이 되려면 몇 가지를 개선한다. 아직은 만족하고 있으나, 사업 계획서와 같은 방대한 문서를 작성할때 이슈가 되는 것 들이 몇가지 있었다.</p><h3><span id="실행-취소-다시-실행undo-redo">실행 취소, 다시 실행(Undo, Redo)</span></h3><p>이 부분이 다소 불안정적이다. 한글 작성과 함께 꼬이는 이슈일 수 있다. 많은 글을 작성하면서 당연히 신뢰하고 있는 실행 취소와 같은 기능들이 방금 전 타이핑이 아닌 그 전에 타이핑한 글을 취소한다던지 하는 이슈가 있었다. 난 글을 작성할 때 단락의 위치를 괘나 바꾸는데 그래서 생기는 문제인지는 모르겟으나 실행 취소가 바로 전 타이핑에 대한 것이 아닌 경우가 존재했다.</p><p>이는 꽤 치명적인 글로 그 취소를 내가 인지하지 못하는 경우가 있으면 글이 틀어져 버린다.</p><hr><blockquote><p>일단 여기까지 작성후 퍼블리싱 테스트 <span class="github-emoji" title="cat2" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f408.png?v8">&#x1f408;</span></p></blockquote>]]></content>
    
    <summary type="html">
    
      Typora, 마크다운 에디터
    
    </summary>
    
    
      <category term="typora" scheme="http://blog.bglee.me/tags/typora/"/>
    
      <category term="markdown" scheme="http://blog.bglee.me/tags/markdown/"/>
    
      <category term="editor" scheme="http://blog.bglee.me/tags/editor/"/>
    
  </entry>
  
  <entry>
    <title>미디움으로 이사합니다.</title>
    <link href="http://blog.bglee.me/posts/2018/move-to-medium/"/>
    <id>http://blog.bglee.me/posts/2018/move-to-medium/</id>
    <published>2018-03-28T15:00:00.000Z</published>
    <updated>2018-03-29T06:41:17.921Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://medium.com/@deptno" target="_blank" rel="noopener">https://medium.com/@deptno</a>으로 이사합니다.</p><p>RSS: <a href="https://medium.com/feed/@deptno" target="_blank" rel="noopener">https://medium.com/feed/@deptno</a></p><p>이 곳엔 가끔 업데이트나 더 개인적인 주제들을 담고자 합니다.</p>]]></content>
    
    <summary type="html">
    
      RSS 구독자 분들을 위한 안내
    
    </summary>
    
      <category term="service" scheme="http://blog.bglee.me/categories/service/"/>
    
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="http://blog.bglee.me/posts/2017/python/"/>
    <id>http://blog.bglee.me/posts/2017/python/</id>
    <published>2017-11-10T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.631Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>macOS 기반으로 작성되었다.</p></blockquote><p>ml(머신러닝) 공부를 하기 위해 파이썬을 환경을 설정했다.</p><h2><span id="installation">installation</span></h2><p>brew는 기본적으로 설치되어 있어야 한다. <a href="http://deptno.github.io/posts/2016/osx" target="_blank" rel="noopener">참조</a></p><p>설치 각각에 종속성이 있을 수 있으므로 패키지 설치시마다 터미널을 재시작하면서 하도록 한다.</p><p>아나콘다라는 파이썬 배포판으로 데이터 사이언스 관련 패키지들을 포함하고 있다. 보통 책들에서 강력히 추천하므로 설치한다. 파이썬 배포판이므로 글을 쓰는 현재 python 3.6.3을 포함하여 설치된다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install anaconda</span><br></pre></td></tr></table></figure><p>프로젝트별 독립된 개발 환경을 만들어주는 <code>virtualenv</code>와 이를 편하게 사용하도록 해주는 <code>virtualenvwrapper</code>를 설치한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install virtualenv virtualenvwrapper</span><br></pre></td></tr></table></figure><p>사용하는 쉘의 설정 파일을 열어 다음을 추가한다. 설정 파일을 쉘에 따라 다르다.</p><p>~/.zshrc or ~/.bashrc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python virtualenv settings</span></span><br><span class="line"><span class="built_in">export</span> WORKON_HOME=~/workspace/virtualenvs</span><br><span class="line"><span class="built_in">export</span> VIRTUALENVWRAPPER_PYTHON=/usr/<span class="built_in">local</span>/anaconda3/bin/python</span><br><span class="line"><span class="built_in">source</span> /usr/<span class="built_in">local</span>/anaconda3/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure><p><code>~/workspace/virtualenvs</code> 이 부분은 사람마다 다른 경로를 사용하므로 사용하고자 하는 경로를 쓰면된다. 설정파일이 적용되기 전에(터미널 재시작 전) 폴더를 만들어준다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/workspace/virtualenvs</span><br></pre></td></tr></table></figure><p>터미널을 재시작하면 스크립트가 돌고 아래와 같은 명령어를 사용할 수 있게된다.</p><ul><li>mkvirtualenv 프로젝트명</li><li>rmvirtualenv 프로젝트명</li><li>workon 프로젝트명</li><li>deactivate</li></ul><p><code>ml</code>이라는 가상황경을 위한 라이프 사이클은 아래와 같다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 가상환경를 생성한다.</span></span><br><span class="line">bglee@since-20171107  mkvirtualenv ml</span><br><span class="line"><span class="comment"># 가상환경를 종료한다.</span></span><br><span class="line">(ml)  bglee@since-20171107  deactivate</span><br><span class="line"><span class="comment"># 가상환경에 진입한다.</span></span><br><span class="line">bglee@since-20171107  workon ml</span><br><span class="line"><span class="comment"># 가상환경를 종료한다.</span></span><br><span class="line">(ml)  bglee@since-20171107  deactivate</span><br><span class="line"><span class="comment"># 가상환경를 삭제한다.</span></span><br><span class="line">bglee@since-20171107  rmvirtualenv ml</span><br></pre></td></tr></table></figure><p>이제 가상환경은 설정이 되었고 프로젝트를 활성화(진입)한 상태로 <code>pip install package_name</code>을 할 경우 가상환경에 패키지가 포함되게 된다.</p>]]></content>
    
    <summary type="html">
    
      머신러닝을 위한 macOS 파이썬 환경설정
    
    </summary>
    
      <category term="service" scheme="http://blog.bglee.me/categories/service/"/>
    
    
      <category term="python" scheme="http://blog.bglee.me/tags/python/"/>
    
      <category term="파이썬" scheme="http://blog.bglee.me/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"/>
    
      <category term="ml" scheme="http://blog.bglee.me/tags/ml/"/>
    
      <category term="머신러닝" scheme="http://blog.bglee.me/tags/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D/"/>
    
      <category term="anaconda" scheme="http://blog.bglee.me/tags/anaconda/"/>
    
      <category term="아나콘다" scheme="http://blog.bglee.me/tags/%EC%95%84%EB%82%98%EC%BD%98%EB%8B%A4/"/>
    
      <category term="virtualenv" scheme="http://blog.bglee.me/tags/virtualenv/"/>
    
      <category term="virtualenvwrapper" scheme="http://blog.bglee.me/tags/virtualenvwrapper/"/>
    
  </entry>
  
  <entry>
    <title>Netlify</title>
    <link href="http://blog.bglee.me/posts/2017/netlify/"/>
    <id>http://blog.bglee.me/posts/2017/netlify/</id>
    <published>2017-10-03T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.627Z</updated>
    
    <content type="html"><![CDATA[<p>Netlify 는 스태틱 웹을 위한 CMS다. Git 서비스들을 통해 제공되며 레포지터리에 푸시를 할 경우 이를 자동으로 감지하고 빌드하며 재 배포한다. 여기에 본인이 도메인을 가진게 있다라면 본인의 도메인을 연결하여 서비스 할 수 있다.</p><blockquote><p>스태틱웹은 동적으로 URL을 생성하는 것이 아닌 그냥 실제 html파일 자체로 서빙을 한다고 생각하면 단순하다.</p></blockquote><p>Netlify 는 추가적으로 Let’s encrypt 를 서비스 안으로 포함시켜서 SSL(https://) 을 지원하며 이를 위해 DNS를 품고 있다. 자동으로 지원되지만 자신만의 도메인이 있어 이를 사용할 때는 Netlify DNS를 사용해야한다.</p><p>이번 &lt;bglee.me&gt;의 DNS를 Netlify 로 옮기면서 모든 페이지에 SSL을 적용하고 기존 블로그는 <a href="https://deptno.github.io" target="_blank" rel="noopener">https://deptno.github.io</a>로 되돌려 하나의 루트로 접근 경로를 통일했으며 기존 <a href="https://blog.bglee.me">https://blog.bglee.me</a>는 이제 SSL을 적용하고 기존 패스 그대로 <a href="https://deptno.github.io" target="_blank" rel="noopener">https://deptno.github.io</a>로 리다이렉트 시키도록 세팅했다. 이를 세팅 과정은 로컬 환경이 아닌 깃헙 레포지터리를 이용할 정도로 단순했고 Netlify 에서 지원하는 리다이렉트 옵션도 매우 직관적이었다.<a href="https://github.com/deptno/blog.bglee.me" title="적용 레포지터리" target="_blank" rel="noopener">1</a></p><h2><span id="배포">배포</span></h2><p>글을 작성하고 있는 현재 Netlify 에서 지원하고 있는 Git 클라우드 서비스는 아래와 같다.</p><ul><li>Gitub</li><li>Gitlab</li><li>Bitbucket</li></ul><p>잠깐 부연하자면 비공개 레포지터리를 만들기 위해서 Github은 유로 플랜을 써야하지만 나머지 둘은 기본적으로 비공개 레포지터리를 개인에게 무료로 허용한다.</p><p>로그인하면 바로 사용을 위한 화면이 시작되며 순서는 아래와 같다.</p><p><img src="netlify-sequence.png" alt="순서"></p><ul><li>사용하고 있는 레포지터리 서비스를 선택한다.(Git 클라우드 서비스들)</li><li>배포에 사용될 레포지터리를 선택한다.</li><li>배포에 사용될 브랜치, 빌드시 명령어, 그리고 빌드 명령어를 통해 생성된 배포될 파일들을 가리키는 디렉토리를 작성한다.</li></ul><p><img src="netlify-deploy.png" alt="배포"></p><p>그럼 바로 배포가 시작되며 앞으로 레포지터리에 푸시를 할 때마다 자동으로 빌드 =&gt; 배포가 진행된다.</p><h2><span id="커스텀-도메인과-dns">커스텀 도메인과 DNS</span></h2><p>커스텀 도메인을 을 사용하기 위해서는 <code>domain settings</code>에 들어가서 <code>custom domain</code>을 누르고 본인의 도메인을 입력해야한다. 도메인 셋업은 <code>www.YOUR_DOMAIN</code>을 통해야 SSL서비스를 받을 수 있다.</p><p>예를 들어 필자는 <code>www.bglee.me</code>를 입력하고 <code>HTTPS</code> 에서 주소를 확인한뒤에 <code>Force TLS connections</code>를 활성화 시켜 http접속을 https로 강제 리다이렉트 시켰다.</p><p>Netflify 에서는 <code>bglee.me</code>가 아닌 <code>www.bglee.me</code>를 등록하라고 권고하고 있으며 <code>www.bglee.me</code>를 등록시에 <code>bglee.me</code>도 자동으로 Netlify에 의해 등록되며 &lt;bglee.me&gt; 접속시 &lt;<a href="http://www.bglee.me&gt;로" target="_blank" rel="noopener">www.bglee.me&gt;로</a> 강제 리다이렉트된다.</p><h2><span id="추가적인-기능">추가적인 기능</span></h2><p><strong>와…</strong> 한 기능들을 몇개 지원한다.</p><h3><span id="브랜치를-통한-ab-테스트-지원">브랜치를 통한 A/B 테스트 지원</span></h3><p>브랜치를 추가적으로 등록할 수 있는데(A/B테스트 메뉴) 자동으로 로드밸런싱을 해서 A/B테스트를 하게 해준다.</p><h3><span id="pr시-스테이지-url">PR시, 스테이지 URL</span></h3><p>PR이 왔을시 이에대한 Preview URL을 생성할 수 있으며 이를 스테이지로 활용할 수 있다.</p><hr><h2><span id="next">next</span></h2><p>이제 스태틱 사이트를 작성하고 배포해보자.</p><hr>]]></content>
    
    <summary type="html">
    
      Git 레포지터리 Push 만으로 https까지 적용된 사이트를 지속적으로 빌드하고 배포할 수 있다.
    
    </summary>
    
      <category term="service" scheme="http://blog.bglee.me/categories/service/"/>
    
    
      <category term="netlify" scheme="http://blog.bglee.me/tags/netlify/"/>
    
      <category term="https" scheme="http://blog.bglee.me/tags/https/"/>
    
      <category term="ssl" scheme="http://blog.bglee.me/tags/ssl/"/>
    
      <category term="스태틱 웹" scheme="http://blog.bglee.me/tags/%EC%8A%A4%ED%83%9C%ED%8B%B1-%EC%9B%B9/"/>
    
      <category term="static web" scheme="http://blog.bglee.me/tags/static-web/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript와 Redux connect</title>
    <link href="http://blog.bglee.me/posts/2017/typescript-redux-connect/"/>
    <id>http://blog.bglee.me/posts/2017/typescript-redux-connect/</id>
    <published>2017-10-02T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.633Z</updated>
    
    <content type="html"><![CDATA[<p>타입스크립트와 리덕스로 SPA를 구현하는데 있어 기본적인 셋업이 아닌 문법적인 측면에 포커싱된 글로 타입스크립트를 활용하는데 도움이 되었으면한다.</p><p>필자는 하드 타이핑을 하지 않으며 추가적으로 린트를 쓰지 않는다. 리덕스는 자체적으로 타입스크립트 데피니션 파일(d.ts)을 가지고 있으므로 따로 타입 관련 패키지를 설치하지 않아도 된다.</p><h2><span id="설치">설치</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev typescript</span><br><span class="line">npm install redux</span><br></pre></td></tr></table></figure><h2><span id="redux">redux</span></h2><p>리덕스에 대한 설명을 돕기 위해 루트 스토어가 가지는 스테이트의 타입을 아래와 같이 정의하기로한다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.d.ts</span></span><br><span class="line"><span class="keyword">interface</span> RootState &#123;</span><br><span class="line">bglee: User</span><br><span class="line">deptno: User</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">name: <span class="built_in">string</span></span><br><span class="line">email: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="connectargs">connect(..args)</span></h3><p>리덕스를 쓰면서 가장 많이 쓰게 되는 함수일텐데 코드를 먼저 보이면 아래와 같다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123;connect, bindActionCreataors&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> StateProps &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> DispatchProps &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> OwnProps &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Props = StateProps &amp; DispatchProps &amp; OwnProps</span><br><span class="line"><span class="keyword">interface</span> State &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Container = connect&lt;StateProps, DispatchProps, OwnProps&gt;(</span><br><span class="line">(state: RootState) =&gt; (&#123;&#125;),</span><br><span class="line">dispatach =&gt; bindActionCreators(&#123;&#125;, dispatch)</span><br><span class="line">)(</span><br><span class="line"><span class="keyword">class</span> Component <span class="keyword">extends</span> React.Component&lt;Props, State&gt; &#123;</span><br><span class="line">render() &#123;</span><br><span class="line"><span class="keyword">return</span>&lt;p&gt;hello world&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p>위 코드는 완전히 동작하는 코드이고 컨테이너를 정의하기 위해 풀어쓴 기본적인 형태다. 참고로 connect 함수는 추가적인 옵션을 기술하기 위해 4개까지 인자를 받을 수 있다.</p><p>connect를 보면 3개의 타입을 받고 있다. 순서대로 살펴 보겠다.</p><h4><span id="stateprops">StateProps</span></h4><p>connect의 첫번째 인자는 <code>mapStateToProps</code>로 정의되어 있으며 함수 명과 같이 <code>Store</code>의 state를 <code>Component</code>의 props로 주입하는 함수다. 이 함수의 리턴 타입이라고 생각하면 된다.</p><p>예를 들어 Store에 <code>bglee</code>라는 프로퍼티를 연결하고자 한다면 <code>mapStateToProps</code>는 아마도 다음과 같이 작성되게 된다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStaetToProps = <span class="function">(<span class="params">state: RootState</span>) =&gt;</span> state.bglee</span><br></pre></td></tr></table></figure><p>그러면 Container는 props로 bglee가 가지고 있는 <code>name</code>, <code>email</code>을 받게 된다. 그럼 그에 맞춰서 <code>StateProps</code>를 정의하면 된다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StateProps &#123;</span><br><span class="line">name: <span class="built_in">string</span></span><br><span class="line">email: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>작성하고 보니 <code>User</code> 타입과 동일하다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StateProps = User</span><br></pre></td></tr></table></figure><p>로 정의해도되고 코드에서 StateProps를 User로 치환해도 된다. 이 경우는 예제를 위해 특수한 케이스기 때문에 이러하지만 여러 state를 props로 연결해야한다라면 곧 확장을 해야하니 StateProps라는 이름의 컨벤션을 유지해서 코드 일관성, 가독성을 확보하자.</p><p>다시 <code>mapStateToProps</code> 함수를 구현한 코드를 보면 아래와 같이 보일 것이 의심치 않는다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStaetToProps = (state: RootState): <span class="function"><span class="params">StateProps</span> =&gt;</span> (&#123;</span><br><span class="line">name: state.name,</span><br><span class="line">email: state.email</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>이해를 돕기 위해 완전히 풀어서 보였다. StateProps가 리턴되고 있다는 것만 인지하고 있으면 되며 위와 같은 코드작성은 connect가 타입을 받는 이유와 상충되므로 줄여서 작성하도록 하자.</p><h4><span id="dispatchprops">DispatchProps</span></h4><p>두번째 인자는 dispatch할 액션들이 Component의 props로 매핑된다. 위와 마찬가지로 두번째 인자의 이름인 <code>mapDispatchToProps</code>의 리턴 타입이다.</p><p>완벽한 이해를 위해 아래와 같이 액션이 정의해보자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contactBglee = <span class="function">(<span class="params"><span class="keyword">from</span>: <span class="built_in">string</span></span>) =&gt;</span> (&#123;</span><br><span class="line"><span class="keyword">type</span>: <span class="string">'CONTACT_BGLEE'</span></span><br><span class="line">payload: &#123;</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>액션은 <code>type</code>을 포함하는 오브젝트를 리턴하는 함수이며 <code>bindActionCreators</code>함수를 통해 dispatch가능한 형태가 된다.</p><p>그럼 두번째 인자의 구현부를 다시 보자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch = bindActionCreators(&#123;&#125;, dispatch)</span><br></pre></td></tr></table></figure><p>이름을 달고 정의한 액션을 바인딩해보자</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> bindActionCreators(&#123;</span><br><span class="line">contactBglee</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>작성된 <code>mapDispatchToProps</code>함수를 두번째 인자로 전달하게 되며 Container는 <code>contactBglee</code>액션을 디스패칭할 수 있다. Container는 <code>contactBglee</code> props를 가지고 있다는 의미며 이를 컴파일러에게 알려주기위해 두번째 DispatchProps는 아래와 같이 정의된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Dispatchprops &#123;</span><br><span class="line">contactBglee: typeof contactBglee</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>typeof</code>를 유심히 보자 contactBglee의 액션이 <code>from: string</code>인자를 취하는데 이를 재 다시 정의하는 것이아니라 기존 정의로부터 타입을 가지고 와서 추가해준다. 따라서 우린 중복정의 없이 기존 정의를 <code>typeof</code> 키워드를 통해서 쓸 수 있다.</p><h4><span id="ownprops">OwnProps</span></h4><p>마지막 타입은 기존 우리가 컴포넌트를 정의할 때 받는 부모로 부터 받게되는 그 인자를 정의하면 된다. <strong>컴포넌트를 컨테이너로 변경하는 경우라면 기존 컴포넌트의 인자가 OwnProps로 변경된다.</strong></p><hr><p>개인적으로 수없이 정의하게 되는 이런 타입과 함수들이 매우 반복적이기 때문에 <code>mapStateToProps</code>와 같은 함수를 정의하는 대신 inline으로 삽입하는 것을 선호하며 위에 설명한 것들을 함쳐 결과를 보면 아래와 같다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123;connect, bindActionCreataors&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123;contactBglee&#125; <span class="keyword">from</span> <span class="string">'./actions'</span> <span class="comment">// 액션이 존재하는 곳</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> StateProps <span class="keyword">extends</span> User &#123;&#125; <span class="comment">// type으로 정의도 가능하다</span></span><br><span class="line"><span class="keyword">interface</span> DispatchProps &#123;</span><br><span class="line">contactBglee: <span class="keyword">typeof</span> contactBglee</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> OwnProps &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Props = StateProps &amp; DispatchProps &amp; OwnProps</span><br><span class="line"><span class="keyword">interface</span> State &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Container = connect&lt;StateProps, DispatchProps, OwnProps&gt;(</span><br><span class="line">(state: RootState) =&gt; (&#123;</span><br><span class="line">...state.bglee</span><br><span class="line">&#125;),</span><br><span class="line">dispatach =&gt; bindActionCreators(&#123;</span><br><span class="line">contactBglee</span><br><span class="line">&#125;, dispatch)</span><br><span class="line">)(</span><br><span class="line"><span class="keyword">class</span> Component <span class="keyword">extends</span> React.Component&lt;Props, State&gt; &#123;</span><br><span class="line">render() &#123;</span><br><span class="line"><span class="keyword">return</span>&lt;p&gt;hello world&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><h2><span id="next">next</span></h2><p>이제 <code>render()</code>함수 안에서 this.props 그리고 <code>.</code>을 찍어보자.</p>]]></content>
    
    <summary type="html">
    
      redux connect를 제대로 typing 해보자
    
    </summary>
    
      <category term="dev" scheme="http://blog.bglee.me/categories/dev/"/>
    
      <category term="ts" scheme="http://blog.bglee.me/categories/dev/ts/"/>
    
    
  </entry>
  
  <entry>
    <title>Texts 구현</title>
    <link href="http://blog.bglee.me/posts/2017/texts/"/>
    <id>http://blog.bglee.me/posts/2017/texts/</id>
    <published>2017-05-07T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.633Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="texts-구현"> 구현</span></h1><p><img src="https://lh3.googleusercontent.com/t_LQOLOXJ64l4zi05A_-By3QDDo7FIvWREe9meD6ZCuAUBlv8Y-DwyvzvShtR1v192sdYwfvgGG8e4S5pEsuAksPuyPj6MTBZBZvHvZIvMkyFH2j2I6_A4VIeZ3GOKyGigOg0dID1VQpXYTDkIDNJ_fFzjH39iPbM7p08KX1UWhOT02uU0yR0RK-3lH8obg57t9sohm4OUZVa-skdrOWh1U_qM_yKAiGhhkUIFBFAjCvdpmmiQIGk-zWX2MpVMHqkTDDbF9wyp87m2PbYegL5SuNTibFrYVTnRHfeCS8cA1uV7skajLXVK9cMuoKbSgyjMQAM3ZQ_kiaez78tvMz03tKKxtghcf4oyQHkHD3OIx15HdJad3W48oJxTBkyPO9DvR7r7dRVT4mGw70Tx1dZcYog6YeWPzXMCXl6SgO37QP3raxZMpkgbhWy5kzhbSmE-uIigUHUyiEo9gLhOwsVNwW1pzW9-LP4HDuwO7XGeVTep9SAaPCAIs4_SfiLwM3L0BoEPpxPPY7MBd-6FkofxblJsf_uset1CHbpT2xqUG2CHKO8Q79YJqgte5I34JK6mj42S89EDRO0lbg3VG769NRsbWuCLT4GWagjHJw5gpkdsvkC0xpszdilkBUprqzqy27ZbJti2I4VtBx53qlUOCDTKQdW_TN9NyH=w1139-h410-no" alt="" title="texts image"></p><blockquote><p>기획자 디자이너, 퍼블리셔와의 협업시 문구 변경으로 인한 피로를 덜기 위해 ID기반의 문구 관리를 앱</p></blockquote><h2><span id="동기">동기</span></h2><ul><li>부동산 계열에서 일을 하다보니 너무많은 term이 존재한다.</li><li>사소한 문구 변경이 데일리로 일어난다.</li><li>퍼블리셔 쪽에서도 html에 대한 이력관리를 원한다.</li><li>문구 변경과 markup의 변경이 구분되지 않는다.</li><li>react로 퍼블리싱하지 않는 이상 태그를 그대로 사용하지 못하므로 daily diff이슈가 존재한다.</li><li>여러 곳에서 동일하게 쓰이는 문구 변경이 일어난 경우 diff에 혼란이 있다.</li></ul><h2><span id="개발">개발</span></h2><blockquote><p>일단 퍼블리셔 쪽에서 <code>ID</code>를 사용하용하여 퍼블리싱 할 수 있게 끔 하는 것을 최우선으로 했다.</p></blockquote><ul><li>독립적으로 사용할 수 있도록 <a href="https://www.serverless.com" target="_blank" rel="noopener">serverless</a>를 통해 DB까지 한번에 deploy한다.</li><li>backend 엔드포인트만 사용자 별로 바꾸면 되니까 fe는 직접 만들어서 배포했다. <strong><a href="https://texts.surge.sh" target="_blank" rel="noopener">Texts</a></strong></li></ul><h2><span id="운영">운영</span></h2><h3><span id="기획스트링-관리-주체">기획(스트링 관리 주체)</span></h3><ul><li><a href="https://texts.surge.sh" target="_blank" rel="noopener">https://texts.surge.sh</a>?endpoint=https://[BACKEND_ENDPOINT] 접속</li><li>스트링 마음껏 만들고 잘 됬으면 deploy한다.</li></ul><h3><span id="퍼블리셔">퍼블리셔</span></h3><ul><li>퍼블리셔 쪽에서는 <code>&lt;div data-text-id=&quot;TEXT_ID&quot;/&gt;</code>와 같은 형식으로 퍼블리싱을 할 수 있게한다.</li><li>퍼블리셔는 눈으로 이를 확인할 수 있어야하므로 이를 치환해주는 태그를 서비스해준다. <strong><a href="https://texts-translator.surge.sh" title="texts" target="_blank" rel="noopener">Texts Translator</a></strong></li><li>퍼블리셔가 동적인 동작을 위해 <code>jQuery</code>태그를 심듯이 심어주면 동적으로 확인이 가능해준다.</li></ul><h3><span id="개발">개발</span></h3><ul><li>개발 버전에서는 퍼블리셔와 같이 태그를 심어서 스트링 관리주체가 변경하는 것을 즉각적으로 확인할 수 있게끔 한다.</li><li>프로덕션 릴리즈시에 아래 형식으로 저장해서 CI빌드시에 넣으면된다.</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ http post https://[END_POINT]/json &gt; language_ko.json</span><br></pre></td></tr></table></figure><h2><span id="todos">todos</span></h2><ul><li>퍼블리셔쪽에 구문 변경으로 인한 스트레스에서 벗어나고 싶지않냐고 설득한다.</li><li>기획자분이 스트링을 관리할 수 있도록 제안하고 설득한다.</li></ul><h2><span id="히스토리">히스토리</span></h2><ul><li>표준을 이용할 수 있게 끔 <code>Intl</code>을 붙이려고 디자이너쪽에서 태그를 어떻게 사용하게 해야할지 감이 오지 않아 뒤로 미뤘다.</li></ul><h2><span id="장점">장점</span></h2><ul><li>퍼블에서도 모델을 분리한다.</li><li>모델, 디자인, 컨트롤의 물리적인 관리주체(부서)가 명확해 진다.</li></ul><h2><span id="단점">단점</span></h2><ul><li>서비스가 아니라 aws 설치 형태라 결국 나만의…</li></ul>]]></content>
    
    <summary type="html">
    
      기획자 디자이너, 퍼블리셔와의 협업시 문구 변경으로 인한 피로를 덜기 위해 ID 기반의 문구 관리
    
    </summary>
    
      <category term="dev" scheme="http://blog.bglee.me/categories/dev/"/>
    
      <category term="js" scheme="http://blog.bglee.me/categories/dev/js/"/>
    
    
  </entry>
  
</feed>
