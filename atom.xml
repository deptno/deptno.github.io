<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>봉로그</title>
  
  <subtitle>do 봉지니어링 | 기술 관련된 글 포스팅은 앞으로 &lt;a href=&quot;https://medium.com/@deptno&quot;&gt;medium.com/@deptno&lt;/a&gt;에 포스팅합니다.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.bglee.me/"/>
  <updated>2018-08-07T12:14:31.970Z</updated>
  <id>http://blog.bglee.me/</id>
  
  <author>
    <name>deptno@gmail.com</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Github OAuth 404, 그리고 헤더의 중요성</title>
    <link href="http://blog.bglee.me/posts/2018/Github-OAuth-404/"/>
    <id>http://blog.bglee.me/posts/2018/Github-OAuth-404/</id>
    <published>2018-08-07T11:32:50.000Z</published>
    <updated>2018-08-07T12:14:31.970Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>이 것도 한 3번인가 삽질을 한 것 같은데.. 기록을 해두지 않아 매번 삽질을 한다. 오늘도 4시간 정도 날린거같다…</p></blockquote><h2><span id="3-티어-인증-프로세스">3 티어 인증 프로세스</span></h2><ul><li>클라이언트(웹)에서 깃헙로 리다이렉션을 시도한다.</li><li>깃헙에서는 스코프랑 유저 허락 받고 허락 되면 어플리케이션 정보 저장시에 사용했던 콜백(서버)로 <strong>code</strong> 를 전송한다.</li><li>서버는 <strong>code</strong> 를 <strong>token</strong> 으로 교환한다.</li><li>교환 후에는 <strong>token</strong> 을 가지고 다시 클라이언트로 돌아갈 수 있도록 <strong>302</strong> 리턴을 하면서 쿼리 파라메터로 <strong>token</strong> 을 넘긴다.</li></ul><h2><span id="이슈">이슈</span></h2><p>코드에서 토큰으로 교환하는 과정에서 깃헙이 <strong>404</strong> 를 내뱉는다. 무엇이 문제인가 <span class="github-emoji" title="eyes" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f440.png?v8">&#x1f440;</span></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">`https://github.com/login/oauth/access_token`</span>, &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  body: &#123;</span><br><span class="line">    client_id    : GITHUB_CLIENT_ID,</span><br><span class="line">    client_secret: GITHUB_CLIENT_SECRET,</span><br><span class="line">    code,</span><br><span class="line">    <span class="comment">// state,</span></span><br><span class="line">    <span class="comment">// redirect_uri</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3><span id="content-type-헤더의-중요성">Content-Type 헤더의 중요성</span></h3><p>문제는 이것 저것 해보다가 설마 헤더 때문인가? 라는 생각에 이르렀다. 코드는 다음과 같이 수정해봤다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">`https://github.com/login/oauth/access_token`</span>, &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  body: &#123;</span><br><span class="line">    client_id    : GITHUB_CLIENT_ID,</span><br><span class="line">    client_secret: GITHUB_CLIENT_SECRET,</span><br><span class="line">    code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>바로 <strong>200 OK</strong> 가 떨어진다. <span class="github-emoji" title="fist_raised" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/270a.png?v8">&#x270a;</span></p><h3><span id="서버는-서버-엔지니어-마음">서버는 서버 엔지니어 마음</span></h3><p>언젠가는 URL에 뒤에 <code>/</code> 를 붙이냐 마느냐로, <code>200</code> vs <code>201</code>, <code>200</code> vs <code>404</code> 등등 피곤하고 시나리오적인 흐름과 주관이 섞일 수 밖에 없는 문제가 있다.</p><p>소 제목은 <strong>서버는 서버 엔지니어 마음이다.</strong> 라고 달았지만 흥분을 가라 앉히고 보면 내가 잘못한게 맞다. 이런 날들을 위해 준비되어있는 스펙을 무시했다. 최근 근무한 직장도 그렇고 기본적으로 <code>JSON</code> 이 일반화 된 세상에서 살고 있다보니 기본이 <code>JSON</code> 일 것이라 예단했다. 깃헙도 꽤나 오랜 시간을 버텨왔고 매우 많은 유저가 사용하는 만큼 바꾸지 못하는 레거시가 있기 마련이다.</p><h2><span id="리턴-값">리턴 값</span></h2><p>자성을 하고 리턴 값을 확인하려고 코드를 짜니 또 에러가 난다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> json = <span class="keyword">await</span> response.json()</span><br></pre></td></tr></table></figure><p>고통을 교훈으로 헤더를 확인했다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'content-type'</span>: [ <span class="string">'application/x-www-form-urlencoded; charset=utf-8'</span> ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>두번 반성한다. 리턴값도 당연히 <code>JSON</code> 일리가 없었다. <code>response.text()</code> 도 가능하지만 요청 헤더에 <code>Accept</code> 를 추가했다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">    <span class="string">'Accept'</span>: <span class="string">'application/json'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 잘 날아온다. <span class="github-emoji" title="boxing_glove" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f94a.png?v8">&#x1f94a;</span></p><h2><span id="다시-한번-헤더의-중요성-다시-한번-서버는-서버-엔지니어의-마음">다시 한번 헤더의 중요성, 다시 한번 서버는 서버 엔지니어의 마음</span></h2><p><strong>API</strong> 를 사용하다보면 헤더도 마음데로 들어온다. 서버리스의 <strong>serverless offline</strong> 플러그인을 통하면 <code>event.headers.referer</code> 가 들어오는데 반해 실제 서버에 디플로이되면 <code>event.headers.Referer</code> 가 들어온다. 이 경우는 플러그인 버그라 할 수 있겠지만 대소문자도 예단해선 안된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;이 것도 한 3번인가 삽질을 한 것 같은데.. 기록을 해두지 않아 매번 삽질을 한다. 오늘도 4시간 정도 날린거같다…&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;span id=&quot;3-티어-인증-프로세스&quot;&gt;3 티어 인증 프로세스&lt;/s
      
    
    </summary>
    
    
      <category term="github" scheme="http://blog.bglee.me/tags/github/"/>
    
      <category term="OAuth" scheme="http://blog.bglee.me/tags/OAuth/"/>
    
      <category term="login" scheme="http://blog.bglee.me/tags/login/"/>
    
      <category term="깃허브" scheme="http://blog.bglee.me/tags/%EA%B9%83%ED%97%88%EB%B8%8C/"/>
    
      <category term="로그인" scheme="http://blog.bglee.me/tags/%EB%A1%9C%EA%B7%B8%EC%9D%B8/"/>
    
      <category term="404" scheme="http://blog.bglee.me/tags/404/"/>
    
  </entry>
  
  <entry>
    <title>서평. 진화된 마케팅 그로스 해킹</title>
    <link href="http://blog.bglee.me/posts/2018/review-%E1%84%8C%E1%85%B5%E1%86%AB%E1%84%92%E1%85%AA%E1%84%83%E1%85%AC%E1%86%AB-%E1%84%86%E1%85%A1%E1%84%8F%E1%85%A6%E1%84%90%E1%85%B5%E1%86%BC-%E1%84%80%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%B3-%E1%84%92%E1%85%A2%E1%84%8F%E1%85%B5%E1%86%BC/"/>
    <id>http://blog.bglee.me/posts/2018/review-진화된-마케팅-그로스-해킹/</id>
    <published>2018-08-02T09:38:38.506Z</published>
    <updated>2018-08-02T09:59:28.304Z</updated>
    
    <content type="html"><![CDATA[<p><img src="growth-hacking.png" alt="growth-hacking"></p><p>초반을 제외하고는 읽는 내내 상당히 괴로웠다. <strong>그로스 해킹</strong> 이었구나 라고 충분히 이해할 수 있었음에도 불구하고 너무나도 반복적이라 읽은 글이 5초 이후에 기억이 안나 같은 부분을 계속 읽은 것 같다. 책 자체는 그로스 해킹이 적용되지 않은 것 같아 아쉽다.</p><p><strong>그로스 해킹</strong> 은 용어 자체가 마케팅적으로 훌륭하게 정립됐다. 용어 자체만으로 관심을 끌기에 충분하다.</p><h2><span id="그로스-해킹">그로스 해킹</span></h2><p>그로스 해킹은 정의를 한번에 내리기에는 너무 광범위 하다. 추적 데이터를 기반으로한 분석, 실험 설계, 적용, 수정 정도의 서클이라고 생각하면 쉬울 것 같다. 누군가는 이미 너무 많이 가지고 있는 지식과 직관을 기반으로 이런 실험으로 도출 할 수 있는 단계를 건너 띌 수도 있다 생각한다.</p><p>그럼에도 불구하고 모든 면을 다 분석하기에는 무리며 일반적인 사람들로 이루어진 집단은 이런 그로스 해킹 싸이클을 통해 검증된 데이터를 얻고 이를 통해 설득의 커뮤니케이션을 비용을 낮추고 성장에 다가갈 수 있다.</p><p>그로스 해킹은 심리적인 영역부터 시작하여 상당히 많은 영역을 포괄하며 실험할 수 있는 모든 분야에 적용된다.</p><h2><span id="아쉬운-점">아쉬운 점</span></h2><p>아마도 저자가 마케터로 생각되는데 책이 후반부로 갈 수록 이메일, 설문조사 영역으로 치우치는 점은 아쉽다. 아마도 책에서 그로스 해킹, 깔데기 분석 등 몇 가지 단어만 줄여도 분량이 대폭 줄 것 같다. 특히 깔데기 분석같은 건 100번을 읽어도 직관적으로 다가오지 않아 역자분께 아쉬운 느낌이 있다. 왜 이렇게 안읽히나 계속 읽어보면 문장은 정상인데 접속사가 많아서 그런지 잘 읽히지 않는다.</p><p>내 문제인지, 아님 너무 직역이라 어색한 것인지, 아님 안읽히는 문장을 매우 천천히 계속 적으로 시도해도 읽는다 하더라도 이미 초반 챕터에서 설명한 부분과 다르지 않을거라는 이미 실망이 마음에 반영됐을지 모른다.</p><h2><span id="그럼에도">그럼에도</span></h2><p>책 그로스 해킹이란 개념을 심어주기에는 충분하다 중간까지 읽으면 충분하지 않을까 한다. 너무 두껍다. 좀 더 얇았어야 했다.</p><p>그로스 해킹은 광범위 함에도 불구하고 데이터에 기반하여 개인화 단계까지 추적한다는 개념 자체는 직관적이면서도 누구나 공감 할, 그러나 이름이 붙어 있지 않았던 영역이라고 생각되기 때문에 이해가 된다. 정책이 명확하다랄까?</p><p>어렵지 않은 내용을 너무 많은 예를 들어 접속사가 많은 문장으로 설명하다보니 결국 책을 끝까지 읽지 못했다. 시간도 오래걸리고 10번은 더 잠든거 같다. 의무가 된거같아 2챕터를 남기고 접었다. 평가는 좋은거 보니 나한테만 지루했을 지 모르겠다.</p><p>이미 책을 읽는 순간에 데이터레이크 구성에 대해 관심이 고정됐다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;growth-hacking.png&quot; alt=&quot;growth-hacking&quot;&gt;&lt;/p&gt;&lt;p&gt;초반을 제외하고는 읽는 내내 상당히 괴로웠다. &lt;strong&gt;그로스 해킹&lt;/strong&gt; 이었구나 라고 충분히 이해할 수 있었음에도 불구하고 
      
    
    </summary>
    
    
      <category term="서평" scheme="http://blog.bglee.me/tags/%EC%84%9C%ED%8F%89/"/>
    
      <category term="창업" scheme="http://blog.bglee.me/tags/%EC%B0%BD%EC%97%85/"/>
    
      <category term="스타트업" scheme="http://blog.bglee.me/tags/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85/"/>
    
      <category term="마케팅" scheme="http://blog.bglee.me/tags/%EB%A7%88%EC%BC%80%ED%8C%85/"/>
    
      <category term="그로스 해킹" scheme="http://blog.bglee.me/tags/%EA%B7%B8%EB%A1%9C%EC%8A%A4-%ED%95%B4%ED%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>세미나, 스타트업의 노무인사관리</title>
    <link href="http://blog.bglee.me/posts/2018/seminar-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85%EC%9D%98-%EB%85%B8%EB%AC%B4%EC%9D%B8%EC%82%AC%EA%B4%80%EB%A6%AC/"/>
    <id>http://blog.bglee.me/posts/2018/seminar-스타트업의-노무인사관리/</id>
    <published>2018-07-28T13:00:23.000Z</published>
    <updated>2018-07-28T13:00:23.199Z</updated>
    
    <content type="html"><![CDATA[<p>어제(2018-07-27) <strong>스타트업의 노무 인사관리</strong> 라는 세미나(주최측에선 아카데미라 부른다)에 참석했다. 저번엔 <strong>팀 빌딩</strong> 에 들으러 참석을 했었는데 생각보다 좋은 내용이 많다.</p><p>마침 집하고도 가까워서 좋은 내용이 있으면 자주 가려고하는데 노무인사관리에 대해 들은 감상은 민방위를 다녀왔을때와 비슷하다.</p><p>강사님도 매우 열정적이셔서 많은걸 배울 수 있었다. 2시간을 초과해서 2시간 반이나 진행됐다.</p><h3><span id="민방위">민방위</span></h3><p>민방위는 주방에서 불났을 때 대응 방법, 지진시 대피, 아파트 화재시 완강기 사용법, 소화기 사용법, 심폐소생술 등 매우 살아가는 필요한 것들을 알려준다. 민방위라는게 예비군의 연장선이라서 남자만 듣는지 모르겠으나 모두에게 필요한 매우 중요한 내용들을 가르친다고 생각이 들었었다.</p><h3><span id="인사노무관리">인사노무관리</span></h3><p>인사노무관리도 다르지 않다. 창업 아카데미라는 이름의 커리큘럼이지만 노동자와 사용자 모두에게 중요하다. 아무래도 예전에 노동 집약적 산업을 기준으로 설계된 감이 없지 않다. 그 만큼 노동자의 권리가 매우 강한 느낌인데 때문에 사용자 측에선 채용에 더 신중해 질 수 밖에 없을 것 같다.</p><p>IT 분야에서는 일반 노동자가 아닌 지식 노동자고, 계속 적으로 성장하며 그에 따라 대체 불가능해진다. 때문에 스스로도 회사가 더러우면 다른데가면 그만이라는 인식과, 이직의 일상화, 당연히 평생직장은 같은 것 생각 안함으로 생각했는데 내 생각일 수 있으니 채용은 매우 신중해야한다고 느껴진다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;어제(2018-07-27) &lt;strong&gt;스타트업의 노무 인사관리&lt;/strong&gt; 라는 세미나(주최측에선 아카데미라 부른다)에 참석했다. 저번엔 &lt;strong&gt;팀 빌딩&lt;/strong&gt; 에 들으러 참석을 했었는데 생각보다 좋은 내용이 많다.&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="창업" scheme="http://blog.bglee.me/tags/%EC%B0%BD%EC%97%85/"/>
    
      <category term="스타트업" scheme="http://blog.bglee.me/tags/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85/"/>
    
      <category term="노무" scheme="http://blog.bglee.me/tags/%EB%85%B8%EB%AC%B4/"/>
    
      <category term="인사" scheme="http://blog.bglee.me/tags/%EC%9D%B8%EC%82%AC/"/>
    
  </entry>
  
  <entry>
    <title>서평, 권도균의 스타트업 경영 수업</title>
    <link href="http://blog.bglee.me/posts/2018/review-%EA%B6%8C%EB%8F%84%EA%B7%A0%EC%9D%98-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85-%EA%B2%BD%EC%98%81-%EC%88%98%EC%97%85/"/>
    <id>http://blog.bglee.me/posts/2018/review-권도균의-스타트업-경영-수업/</id>
    <published>2018-07-26T16:20:01.000Z</published>
    <updated>2018-07-28T05:12:35.925Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="서평-권도균의-스타트업-경영-수업">서평, 권도균의 스타트업 경영 수업</span></h1><p><img src="cover.jpg" alt="xxlarge"></p><blockquote><p>이번엔 스타트업의 경영에 대해 알고 싶어 이 책을 선택했다.</p></blockquote><p><strong>경영</strong> 에 대해 무지하기 때문에 사기전에 경영이 문과인지 이과인지 부터 검색했다. <span class="github-emoji" title="ram" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f40f.png?v8">&#x1f40f;</span> 그냥 말로 풀어진 책이었다. 수치나 이런게 나올 수도 있겠다 했었는데 그냥 읽을 수 있는 책이었다. <span class="github-emoji" title="laughing" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f606.png?v8">&#x1f606;</span> 역시 좋은 책이고 뭐라도 읽어야하는 나에게 또 지식과 경험을 줬다.</p><h3><span id="구성">구성</span></h3><p>무려 12챕터에 챕터당 10개정도의 소 주제를 가지고 이루어져있다. 필요한 부분만 찾아보기에 좋을 것 같고 저자의 경험을 위주로 씌여져있다.</p><h3><span id="내용">내용</span></h3><p>원론적이고 바른 얘기가 많이 쓰여져 있다.</p><h3><span id="공감">공감</span></h3><p>아래는 주인공이 나구나 (하아…)🍶 하면서 읽은 부분들 중 몇가지다.</p><h4><span id="기업가-정신의-네가지-특징">기업가 정신의 네가지 특징</span></h4><p>저자는 보통 기업가 정신이라 하면 <strong>피상적이고 모호하며 사람마다 다르게 해석되는</strong> 말로 정의 하고 있다고 말하며 자신이 본 네가지를 말한다.</p><blockquote><p>낙관주의</p></blockquote><p>낙관주의에 대해 저자는 미래 지향성을 이야기한다. 현재보다 미래에 배팅하고 움직인다. 저자의 생각에 첨언을 하자면 공무원이 안정적이라 하여 지금 공무원을 준비하는 것은 사람에 따라서 미래에도 그 일이 가장 안정적이라 생각하기 배팅하는 것일 수 있다. 그런데 여기서 이미 안정적을 추구한다는 모순이 있다. 이경우는 미래 지향적이지 않다. 현재에서 발전하지 않을 것이라 생각하는 것이므로, 보다 나은 내일에 낙관한다.</p><blockquote><p>주도성</p></blockquote><p>주도성이라 한다면 누구나 <strong>“나는 주도적인데?”</strong> 할 수 있다. 저자는 예를 들어 설명한다. 금융 기관보다 자신이 직접 돈을 관리하는 것. <span class="github-emoji" title="smile" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f604.png?v8">&#x1f604;</span> 직접 경기에 뛰어 들어 흐름을 바꾸고자 하는 사람들이다.</p><blockquote><p>책임감</p></blockquote><p>주도성과 연관성이 깊어 보인다. 주어진 상황을 타박하지 않고 경기를 뛰는 선수처럼 심판의 오심도 경기의 일부인 것을 받아들인다. 저자는 일본 경영 컨설턴트 <strong>하마구치 다카노리</strong> 의 말을 인용한다.</p><p>“경영자는 눈이 내리는 것도 내 책임이라고 말해야한다.”</p><blockquote><p>결과중심적 사고</p></blockquote><p>기업가는 행동하는 사람이다. 경영을 통해 <strong>경제적 성과</strong> 를 실체화 한다. 몽상가가 아니다. 수필가도 아니다.</p><h4><span id="시작은">시작은</span></h4><p>가능한 부담 없는 상태를 유지해야한다. 매출과 자본이 없는 상태에서의 고용, 사업자 등록, 의리와 팀의 오해등이다.</p><h4><span id="채용">채용</span></h4><p>채용은 너무도 중요하다. 저자는 <strong>사람은 변하지 않는다</strong> 라는 가정을 여러 인용을 통해 말하며 그만큼 중요하다 이야기한다. 채용은 <strong>일을 얼마나 잘 하느냐</strong> 보다 내가 만드려는 문화를 <strong>보존할 수 있는가?</strong> 에 더 초점을 맞춰야한다고 말한다. 특히 초반엔</p><hr><h4><span id="비즈니스의-터">비즈니스의 터</span></h4><p>나는 돈이 내게 잠깐 흐르게 하는 것이라 생각하고 그 돈의 물줄기가 나에게도 오도록 강 근처에 땅을 파서 내 근처에도 흐르게 한다는 생각을 주로했었는데 저자도 비슷한 표현을 했다. 아이디어에서도 비슷한 생각을 볼 수 있었는데 대충 이런 거다.</p><p>뭔가 자신이 대단한 아이디어를 생각해냈다고 생각하고 취할 수 있지만 그 아이디어의 작동 여부는 고객에 의해서 판단된다는 것이다. 저자는 <strong>흐르는 강물에 배를 띄워라</strong> 라고 말을 한다.</p><p>사업 아이템은 고객들이 필요로하는 그 곳에 생성하는 것이지 자신이 시장을 만들고나면 사람이 오는 그런게 아니라는 뜻이다. 비슷한 생각을 가지고 있다. 난 이런 생각을 <strong>니즈의 자연 발생</strong> 이라고 말하곤 한다. 예를 들면 이런거다.</p><blockquote><p>뭘 지원하려고 하면 주민등록등본을 스캔해서 보내란다.</p></blockquote><p>그럼 이걸 주민센터가서 발급하고 스캔해서 메일로 보내는데 왜이렇게 불편하게 하는건가? 한참 이전에 발전된 인증 기술을 이용해서, 서비스에 접속해서 회사에서 받을 수 있도록 인가해주면 회사에서 직접 출력하게 하면 누구에게 제출되었는지까지 추적되고, 더 투명하고, 더 편하지 않은가?</p><p>많은 사람들이 고통받고 있는 것, 필요로 하는 곳에 사업을 트면된다. 하고자 하는 것을 하고 사람들이 사용하길 바라는 것이 아니다.</p><h4><span id="지표">지표</span></h4><p>책에서 <strong>지표</strong> 의 중요성을 설명한다. 근데 포커스는 측정이 아닌 선택이다. 무엇을 지표로 선택하는지는 고객의 반응을 어떻게 해석할지, 이해할지에 대한 것이기 때문에 매우 중요하며 경영자 본인이 판단해야한다.</p><p>이 부분이 “호오?” 하면서 봤는데, 서비스를 하면서 중요한 데이터를 뽑아내고 수치화하고 이걸 다시 적용하는 사이클을 갖는 시스템(자동화)을 만드는 것, 이 부분이 엔지니어로써 매우 탐나면서도 수긍이 가능 부분이었다. 사실 대부분의 회사에서 이미 하고 있을텐데 생각없이 애널리틱스 하나 뿌려놓고 있는게 아니라 지표 자체도 비즈니스마다 필요한 것을 제대로 설정해서 그를 달성하는 것, 이것은 중요하고 재밌을 것 같다.</p><h4><span id="팀">팀</span></h4><p>저자는 다른 사람의 글도 많이 인용하는데 이 부분이 사실 궁금했다. 현실적이면서도 초기 팀을 구성하며 지분을 어떻게 할지, 지금 두권째 읽는 것인데 이에 대한 디테일한 수치는 나오지 않는다. 초기에 창업멤버끼리 C레벨을 구성하는데 실력이 거기에 미치지 못한다는 걸 깨달았는데 어떻게 행동해야 할 것인지, 그런일이 벌어지게 둘 것인가 등 창업을 해보곤 알수 없는 베일을 안을 잠시 들여다 볼 수 있었다.</p><h4><span id="계약">계약</span></h4><p>계약도 창업 경험이 없는 사람에게는 블랙박스인데 이 부분에 대해서도 꽤나 갈증을 풀어준다. 연봉 협상이랑 다를바가 없어보인다. 역시 최고의 협상카드는 <strong>“안할래요”</strong> 인가 ㅋㅋ</p><h3><span id="요약">요약</span></h3><p>개인 정리라 두서가 없다. 한번읽고 서머리 할 분량은 아니었다. 좋은 책이고 궁금한 걸 말해준다. 내용이 꽤 되는데다가 같은 류의 생각을 가진 것 같아 멍한 상태로 읽으면 기억에 남지 않는다. 공감을 많이해서 당연한말이 많아서 그런 것 같은데, 난 옳은 말이기 때문에 당연한 말이라고 생각한다, 다시 한번 되새길 수 있는 시간을 갖게 하고, 경험에서 나오는 실질적인 조언을 해준다.</p><p>저자를 조금 찾아보니 최근 인터뷰에 왜 한국에선 유니콘이 안나오느냐 묻자. 경영이 문제라 한다.</p><p>저자가 책에서 쉽게 풀어쓴 것인지 모르겠으나 경영은 특별한 학문 같은게 아니었다. 뭐랄까 회사 생활 하는 방법처럼 회사 굴리는 타이쿤 게임 공략본 같은…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;서평-권도균의-스타트업-경영-수업&quot;&gt;서평, 권도균의 스타트업 경영 수업&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;cover.jpg&quot; alt=&quot;xxlarge&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;이번엔 스타트업의 경영에 대해 알
      
    
    </summary>
    
    
      <category term="서평" scheme="http://blog.bglee.me/tags/%EC%84%9C%ED%8F%89/"/>
    
      <category term="스타트업" scheme="http://blog.bglee.me/tags/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85/"/>
    
      <category term="권도균의 스타트업 경영 수업" scheme="http://blog.bglee.me/tags/%EA%B6%8C%EB%8F%84%EA%B7%A0%EC%9D%98-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85-%EA%B2%BD%EC%98%81-%EC%88%98%EC%97%85/"/>
    
      <category term="경영" scheme="http://blog.bglee.me/tags/%EA%B2%BD%EC%98%81/"/>
    
  </entry>
  
  <entry>
    <title>서평, 장병규의 스타트업 한국</title>
    <link href="http://blog.bglee.me/posts/2018/review-%EC%9E%A5%EB%B3%91%EA%B7%9C%EC%9D%98-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85-%ED%95%9C%EA%B5%AD/"/>
    <id>http://blog.bglee.me/posts/2018/review-장병규의-스타트업-한국/</id>
    <published>2018-07-20T15:05:26.000Z</published>
    <updated>2018-07-20T15:07:40.428Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="서평-장병규의-스타트업-한국">서평, 장병규의 스타트업 한국</span></h1><blockquote><p>읽은지 4-5일 됐다고 벌써 기억이 가물거리는걸 보니 역시 정리는 빠르면 빠를 수록 좋다.</p></blockquote><p><img src="cover.jpg" alt="File"></p><h2><span id="궁금했다">궁금했다.</span></h2><ul><li>스타트업은 어떻게 운영되는가?</li><li>스타트업은 어떻게 시작할 수 있는가?</li><li>시작을 하게 되면 지분등은 어떻게 분배되는가?</li></ul><h3><span id="이-책을-고른-이유">이 책을 고른 이유</span></h3><p>목차에 지분 얘기가 있는 책을 이 것 밖에 못 찾아서 이 책을 구매했다. 가격은 고려 대상은 아니었다. 가격도 쌌다. IT 창업자다.</p><h2><span id="결론적으로">결론적으로</span></h2><p>이 책은 훌륭한 책이다. 가격도 싸다. 군더더기 없다. 경험담이다. 솔직히다. 케이스 스터디도 있다.</p><h3><span id="책의-저자">책의 저자</span></h3><p>이 책의 저자인 장병규 대표에 대해 구두로는 많이 들어봤는데 얼굴은 책 표지를 통해 처음 알았다. 배틀그라운드의 성공, 블루홀 스튜디오 정도는 알았는데 호랑이 담배피던 시절의 <strong>원 클릭</strong> 으로 시작했다는 건 알지 못했다. 또 <strong>네오위즈</strong> 의 창업자다. 내 이전 직장 <strong>부동산 다이렉트</strong>의 투자자다.</p><h3><span id="공감">공감</span></h3><p>책을 읽으면서 초반에는 장병규 대표가 생각하는 스타트업, 뭐 그런 것들에 대해 상당히 <strong>공감</strong>을 많이 했다. 기술 서적외에는 사실 거의 읽질 않기 때문에 책 이란게 원래 이런 느낌을 받으면서 읽는 것인지는 모르겠으나 일전에 읽은 <strong>소프트웨어 장인 정신</strong> 이란 책도 상당히 공감을 많이 했다.</p><p>합리화의 귀신 같은 존재인 난 <strong>소프트웨어 장인 정신</strong> 을 읽는 순간 장인이었는데, 이번엔 인맥 없고 끈 없는 장병규 대표였다. <span class="github-emoji" title="thinking" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f914.png?v8">&#x1f914;</span> 일단 생각의 방향성을 느낄 수 있는데 그 점이 와 닿아서 좋았다.</p><p>책의 중간 중간, 해서 4개 정도의 창업자 케이스 소개가 있다. 모두 장병규 대표와 연관성이 있는 사람들로 지금 장병규 대표가 있는 본엔젤스의 투자를 받은 회사라던가, 하여 창업에 대한 스토리텔링이 있다. 재밌는건 여기서 3인칭 화법을 사용하는데… 나쁘지 않았다.</p><h4><span id="케이스-소개">케이스 소개</span></h4><p>이 부분이 꽤나 좋은데 교과서 마냥 케이스를 상당히 다른 것들로 구성해놔서 궁금했던 얘기를 예를 들어 전해 듣는 느낌이랄까? 이런 예에는 성공한 케이스도 있는 반면 망한 케이스도 있다. 이런 것들이 도움이 되려면 공감이 되야하는데 여기서 창업하는 사람들은 창업에 대해 아무 것도 모른체 창업하는 케이스도 포함되어 있었기에 더 도움이 됐다.(유명한 우아한형제들의 이야기도 있다.)</p><h3><span id="조언">조언</span></h3><p>조언에 내 감상은 필요 없을 것 같다. 굳이 조금 말하자면 창업자와 투자자, 그리고 예비(?) 선배로써의 경험에서 나오는 실질적인 충고가 있다. 굳이 책에 거짓을 이야기할 이유도 없겠지만 이러한 충고들에 신뢰성을 더 하는 몇가지 양념 <span class="github-emoji" title="hot_pepper" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f336.png?v8">&#x1f336;</span> 들이있다. 이 글은 주관적인 글이지만 이 부분은 매우 주관적이다.</p><ul><li>배틀그라운드의 성공 이후 성공에 대한 분배를 이토록 하는 기업을 본적이 없다.</li><li>책 가격이 싸다(책으로 돈벌 생각은 없어보인다.)</li></ul><p>공동 창업, 스타트 업의 성장 뭐 이런 내용은 책을 보는게 빠르겠다.</p><h2><span id="추천">추천</span></h2><p>값도 싸고 필요한 말만 들어있는 그런 책이다. 그냥 해주고 싶은 얘기를 하는 것 같은데, 듣는 입장에서 궁금한 것들을 많이 얘기해준다. 저자가 독자를 공감해주는, 그렇게 씌여진 느낌을 받았다. 좋은 책이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;서평-장병규의-스타트업-한국&quot;&gt;서평, 장병규의 스타트업 한국&lt;/span&gt;&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;읽은지 4-5일 됐다고 벌써 기억이 가물거리는걸 보니 역시 정리는 빠르면 빠를 수록 좋다.&lt;/p&gt;&lt;/blockquote
      
    
    </summary>
    
    
      <category term="서평" scheme="http://blog.bglee.me/tags/%EC%84%9C%ED%8F%89/"/>
    
      <category term="창업" scheme="http://blog.bglee.me/tags/%EC%B0%BD%EC%97%85/"/>
    
      <category term="스타트업" scheme="http://blog.bglee.me/tags/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85/"/>
    
      <category term="장병규의 스타트업 한국" scheme="http://blog.bglee.me/tags/%EC%9E%A5%EB%B3%91%EA%B7%9C%EC%9D%98-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85-%ED%95%9C%EA%B5%AD/"/>
    
  </entry>
  
  <entry>
    <title>Typora ♥️  Hexo</title>
    <link href="http://blog.bglee.me/posts/2018/typora-hexo/"/>
    <id>http://blog.bglee.me/posts/2018/typora-hexo/</id>
    <published>2018-07-18T06:15:02.000Z</published>
    <updated>2018-07-20T13:33:23.610Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="typora-hexo-이미지-설정">Typora, Hexo 이미지 설정</span></h1><blockquote><p>⚠️ Typora와 Hexo의 소개는 이 글의 주제가 아니다. Typora 에 대한 소개는 <a href="http://blog.bglee.me/posts/2018/typora/">이전 글</a> 을 참조한다.</p></blockquote><blockquote><p>마크다운 글 작성, 블로그 포스트, <strong>Typora</strong> 하나로 끝을 내자.</p></blockquote><h2><span id="서문">서문</span></h2><p>생산성 때문에 <strong>미디움</strong> 으로 옮겨서 글을 작성한 것이었는데, 미디움의 웹 에디터가 그 다지 성능이 좋지가 않아서 다시 고민중이다.</p><p>대표적인 문제는 두가지다.</p><ul><li>글 작성중 저장이 꼬였다고 리로드하라고 한다.</li><li>코드 하이라이팅이 매우 취약하다.</li></ul><p>반면 여기서 쓰고 있는 Hexo는 지킬과 달리 쓸만한 테마가 그리 많지 않았다. 그렇다고 만들자니… “내가 그런 것 까지?” 하는 생각이 들고, 그나마 마음에 드는 테마를 골라도 시간이 지나면 질리기 마련이니, 여기서 또 시간이 소모된다. 글 생산에 집중하고자 했고 그래서 <strong>미디움</strong> 으로 옮기게 되었다.</p><p>그런데 여기서 가볍게 글을 쓰고자 하는 나의 마음과는 달리 <strong>팔로우</strong> 라는 시스템이 붙어 버리니 조금 부담스럽게 된 것도 사실이다. 많은 사람이 글을 읽으면 더 좋으니까 라는 마음도 있었지만,</p><p>그래서 좀 더 정리 안되면서도 개인적인 쏟아낼 공간이 필요해서 다시 이 곳을 활용하기로 했다.</p><h1><span id="typora-x1f91d-hexo">Typora <span class="github-emoji" title="handshake" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f91d.png?v8">&#x1f91d;</span> Hexo</span></h1><p>Typora 라는 내가 써본 마크다운 에디터중 가장 강력하며 안정화되어 있다. Hexo 는 작성된 마크다운을 가지고 포스팅을 만들어준다.</p><p>그럼 여기서 소개하고자 하는, 해결하고자 하는 문제는 무엇인가?</p><h3><span id="이미지-첨부">이미지 첨부</span></h3><p>이미지 첨부를 하게 되면 Typora 라는 친절하게도 몇가지 옵션을 제시한다. Hexo는 포스팅의 파일 명을 기반으로 동일 명의 디렉토리를 참조하여 이미지를 업로드하고 이를 참조한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── cognito</span><br><span class="line">│   └── federated_identities_logins.png</span><br><span class="line">├── cognito.md</span><br></pre></td></tr></table></figure><p>이런 형태다. 즉, <code>cognito.md</code> 는 <code>cognito</code> 의 참조를 통해야 디플로이시에 문제가 발생하지 않는다.</p><p>문제는 이 설정이 Hexo 의 설정과 맞지 않는다는데 있다.</p><p><img src="typora-config.png" alt="typora-config"></p><p>현재 폴더로 복사와 몇가지 프리셋이 준비되어 있는데 동일 폴더명을 선택할 수 없다. 그래서 플러그인을 작성하려다가 잠시 멈추고 몇 가지 문서를 검색해서 참조하니 간단한 해결책이 있었다.</p><h3><span id="typora-copy-images-to">typora-copy-images-to:</span></h3><p>포스팅 글에는 마크다운 문서 상단부에 <strong>YAML</strong> 포맷으로 메타 정보를 기입할 수 있는데 이 메타 정보는 <strong>HTML</strong> 을 생성하는데 관여하고 글 자체에 영향을 주지는 않는다.</p><p>이런 방식이 블로그 포스팅에 관련해서는 일반적이기 때문인지 이를 활용해서 Typora 에 설정을 주입할 수 있다. 플러그인도 아니고 기존 환경을 이용하는, 이건 뭐 매우 신박한 방식이다.</p><p>결론적으로는 <code>typeora-copy-images-to</code> 속성을 주입놓으면 Typora 강 이를 읽고 설정보다 우선시하여 적용한다. 확인은 드래고 이미지를 넣게 되면 <code>typora-copy-images-to</code> 에 의해 설정된 디렉토리를 읽어 자동으로 복사가 이루어지고 그에 따른 경로도 수정되어진다. :+1:</p><h3><span id="scaffolds">scaffolds</span></h3><p>Hexo 의 디렉토리 구조에 <code>scaffolds</code> 라는 디렉토리가 존재한다. 이 곳을 열어보면 일반적으로 <code>draft.md</code>, <code>page.md</code>, <code>post.md</code> 가 들어있다. 이를 레이아웃이라고 하는데 <strong>cli</strong> 를 통해 포스트(파일)를 기본 구조와 함께 생성할 수 있다.</p><p>문서를 참조하면 기본 레이아웃은 <strong>post</strong> 다. 즉 <code>hexo new &lt;filename&gt;</code> 은 <strong>post</strong>, <code>post.md</code> 파일을 참조해서 생성된다.</p><h4><span id="postmd"><code>post.md</code></span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat scaffolds/post.md</span><br><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">typora-copy-images-to: &#123;&#123; title &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>파일을 열어 보면 위와 같이 되어 있다. <code>typora-copy-images-to</code> 속성을 눈 여겨 보자. 그럼 아까 포스트를 생성하고자 했던 명령어에 실질적으로 파일 이름을 부여해보자. 파일 이름은 타이틀도 함께 매칭된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new typora-hexo</span><br><span class="line">INFO  Created: ~/workspace/src/github.com/deptno/blog/<span class="built_in">source</span>/_posts/typora-hexo.md</span><br><span class="line">✨  Done <span class="keyword">in</span> 1.30s.</span><br></pre></td></tr></table></figure><p>파일이 생성되었다.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: typora-hexo</span><br><span class="line">date: 2018-07-17 14:48:06</span><br><span class="line">typora-copy-images-to: typora-hexo</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>파일을 열어보면 위와 같다. 우리가 주목해야할 것은 <code>typora-copy-images-to</code> 속성이다. 뒤에는 <code></code> 을 매칭해 뒀기 때문에 값은 파일명과 같이 <code>typora-hexo</code> 다.</p><p>때문에 이제 그냥 글을 작성하면서 이미지를 드래그해서 넣으면 알아서 <code>typora-hexo/&lt;image-file&gt;</code> 형식으로 삽입되게 되며 복사 또한 자동으로 이루어져 이미지에 대한 고민에서 해방된다.</p><h2><span id="generate-후-html에서-이미지가-깨지는-문제">Generate 후 HTML에서 이미지가 깨지는 문제</span></h2><p>Hexo 의 설정 파일인 <code>_config.yml</code> 에서 <code>post_asset_folder: true</code> 를 설정하게 되면 `hexo new<filename>을 통해 파일을 생성할때 파일이름과 동일한 어셋 폴더가 자동으로 생성된다.</filename></p><p>우리는 위에서 <code>typora-copy-images-to:</code> 메타 속성의 주입을 통해 이미지 드래그시 파일명과 동일한 디렉토리에 이미지를 복사하게 설정을 해둬서 글을 작성할 때는 이미지 잘 보인다. 문제는 Hexo 가 <code>hexo generate</code> 를 할 때는 이미지를 알아서 어셋 디렉토리를 참조하게 되어어서 발생하는데 이 때문에 생성된 HTML 에서는 이미지가 깨지게 된다.</p><p><code>hexo generate</code> 시 경로를 중복 참조하지 않도록 플러그인을 작성했으니 동일한 이슈로 고통받는 이가 있으면 플러그인을 사용하자.</p><p><a href="https://github.com/deptno/hexo-typora-plugins/tree/master/packages/hexo-typora-image" target="_blank" rel="noopener">https://github.com/deptno/hexo-typora-plugins/tree/master/packages/hexo-typora-image</a></p><p><code>hexo generate</code> 전에 플러그인을 인스톨하면 자동으로 적용된다.</p><h3><span id="터미널에서-typora-를-통해-markdown-열기">터미널에서 Typora 를 통해 markdown 열기</span></h3><p>Hexo 에서 템플릿(scffold)을 통해 파일을 생성하기 위해서는 <strong>terminal</strong> 을 이용해야하므로 Typora 또한 터미널에서 열 수 있어야 작은 스트레스를 면할 수 있다.</p><h4><span id="alias">alias</span></h4><p>Typora 의 공식 문서에 칠절하게 나와있어서 한줄 복사해서 사용하는 쉘의 설정파일에 추가하면된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> typora=<span class="string">"open -a typora"</span></span><br></pre></td></tr></table></figure><p>난는 개인적으로 <strong>zsh</strong> 을 이용하고 있으므로 <code>~/.zshrc</code> 파일이다. 이렇게 하면 쉘에서 파일을 생성한후 타이포라를 통해 바로 열 수 있다. <code>typora typora-hexo.md</code> <span class="github-emoji" title="ram" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f40f.png?v8">&#x1f40f;</span></p><hr><h2><span id="참조">참조</span></h2><ul><li><p><a href="https://hexo.io/ko/docs/writing.html" target="_blank" rel="noopener">https://hexo.io/ko/docs/writing.html</a></p></li><li><p><a href="https://support.typora.io/Use-Typora-From-Shell-or-cmd/" target="_blank" rel="noopener">https://support.typora.io/Use-Typora-From-Shell-or-cmd/</a></p></li><li><a href="https://support.typora.io/Images/#when-insert-local-image" target="_blank" rel="noopener">https://support.typora.io/Images/#when-insert-local-image</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;typora-hexo-이미지-설정&quot;&gt;Typora, Hexo 이미지 설정&lt;/span&gt;&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;⚠️ Typora와 Hexo의 소개는 이 글의 주제가 아니다. Typora 에 대한 소개는 &lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://blog.bglee.me/tags/hexo/"/>
    
      <category term="typora" scheme="http://blog.bglee.me/tags/typora/"/>
    
      <category term="typora image" scheme="http://blog.bglee.me/tags/typora-image/"/>
    
  </entry>
  
  <entry>
    <title>Cognito, Multi IDP Login 분석</title>
    <link href="http://blog.bglee.me/posts/2018/cognito/"/>
    <id>http://blog.bglee.me/posts/2018/cognito/</id>
    <published>2018-07-16T18:00:00.000Z</published>
    <updated>2018-07-17T16:43:30.661Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><span class="github-emoji" title="warning" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/26a0.png?v8">&#x26a0;</span> 작성 중</p></blockquote><blockquote><p><span class="github-emoji" title="warning" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/26a0.png?v8">&#x26a0;</span> 개인적인 정리라 확실성을 띄는 단어를 사용하지만 실제론 그렇지 않을 수 있다.</p></blockquote><blockquote><p>이 글은 목적이 존재하며 Cognito 의 소개 글이 아니다. Cognito 는 AWS 문서를 참조 바란다.</p></blockquote><blockquote><p>현재라는 문구가 사용되면 작성 시점인 2018년 7월 17일이다.</p></blockquote><p><code>사용자 풀</code> 과 <code>연동 자격 증명 풀</code> 두 가지가 존재하며 각각 따로 생성이 가능하며 연동도 가능하다. 궁극적으로 알고자 하는 것은 아래 와 같다.</p><ol><li>여러 IDP의 로그인을 통해 정보를 취합하는 앱을 만들경우 이 로그인 정보들을 어떻게 취합해서 어떻게 관리할 것인가?</li><li>사용자 풀 에서도 IDP 를 연동할 수 있고, 연동 자격 증명에서도 사용자 풀과 여타 IDP 연결이 가능한데, 무엇이 다른가?</li></ol><p>특별히 궁금한 부분은 AWS 문서에도 <a href="https://docs.aws.amazon.com/ko_kr/cognito/latest/developerguide/cognito-user-pools-identity-federation.html" target="_blank" rel="noopener">노트</a>로도 표시되어 있다.</p><blockquote><p>참고</p><p>타사(연동)를 통한 로그인을 Amazon Cognito 사용자 풀에서 사용할 수 있습니다. 이 기능은 Amazon Cognito 자격 증명 풀(연동 자격 증명)을 통한 연동과 무관합니다.</p></blockquote><p>결국 두 방식은 다르다는 뜻으로 해석되며 <strong>2 번과 관련해서는 예상 되는 결과</strong> 는 아래와 같다.</p><ul><li><p>사용자 풀 베이스</p><p>회원가입 후 로그인 이후에 IDP 로그인을 지원하며 이에 따라 정보가 자연스럽게 취합이 가능.</p></li><li><p>연동 자격 증명 베이스</p><p>로그인 퍼스트 전략으로 인증된 IDP와 앱이라면 일단 로그인이 가능하며 그에 따른 인가가 이루어짐.</p></li></ul><h2><span id="사용자-풀">사용자 풀</span></h2><p>사용자 풀은 자체 DB를 갖는 일반적인 구현 형태와 같다. 때문에 회원 가입, 회원 정보, 로그인 방식(MFA 와 같은), SMS, Email 인증등을 전반적으로 제어 할 수 있다.</p><h3><span id="연동-gt-자격-증명-공급자">연동 &gt; 자격 증명 공급자</span></h3><p>일단 연동 자격 증명과는 달리 입력 요구사항이 다르다.</p><blockquote><p>ID(Client ID) 외에 앱 보안(Secret Key)를 요구하고 인증 범위(Scope)에 대한 지정이 가능하다. 명시적(explicit) 또는 3-way 로그인 방식에서 쓰이는 요구 사항과 같으며 이에 대한 뒷 작업을 Cognito가 해주는 것으로 예상 된다.</p></blockquote><h4><span id="현재-지원되는-idp">현재 지원되는 IDP</span></h4><ul><li>Facebook</li><li>Google</li><li>Login with Amazon</li><li>SAML</li><li>OpenID Connect</li></ul><h3><span id="연동-gt-속성">연동 &gt; 속성</span></h3><blockquote><p>IDP 로그인을 통해 들어온 정보와 가입시의 정보가 다른 경우 어떤 정보가 저장되는가?</p></blockquote><hr><h2><span id="연동-자격-증명federated-identities">연동 자격 증명(Federated Identities)</span></h2><p>기본적으로는 <strong>사용자 풀</strong> 없이도 단지 인증된 <strong>IDP</strong>와 <strong>앱 정보</strong>를 통해 유저를 인증하고 <strong>롤</strong>(IAM)에 따라 인가할 수 있다. 간단한 어플리케이션에서 유용할 것으로 보인다.</p><h3><span id="자격-증명-풀-편집">자격 증명 풀 편집</span></h3><p><strong>인증되지 않은 역할</strong>, <strong>인증된 역할</strong>에 IAM을 할당하여 권한을 지정 함</p><h3><span id="인증-공급자">인증 공급자</span></h3><p><strong>인증 공급자(Identity Provider - IDP)</strong>를 등록한다. 인증 공급자는 OAuth를 지원 업체로 생각 할 수 있다.</p><p><strong>IDP</strong> 등록을 위해서는 각 <strong>IDP</strong> 에서 생성한 App ID 가 필요하며 여기서 등록해 둔다.</p><blockquote><p><code>예제 0</code> 페이스북을 통해 얻은 토큰 등록</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AWS.config.credentials = <span class="keyword">new</span> AWS.CognitoIdentityCredentials(&#123;</span><br><span class="line">    IdentityPoolId: &lt;연동 자격 증명 풀 ID&gt;,</span><br><span class="line">    Logins        : &#123;</span><br><span class="line">        'graph.facebook.com': response.authResponse.accessToken&lt;Facebook access token&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>이렇게 <code>credentials</code> 를 등록함으로써 로그인이 된 것으로 간주하고 <strong>인증된 역할</strong> 의 권한을 얻는다.</p><h4><span id="여러-idp를-통해-로그인이-필요한-경우">여러 IDP를 통해 로그인이 필요한 경우</span></h4><p>여러 IDP를 통해서 로그인이 필요한 경우에는 각 로그인마다 다른 유저로 인식 되므로 이전 로그인 정보를 취합하여 다시 저장할 필요가 있다. 즉, <code>Logins</code> 의 오브젝트를 확장해야한다. 코드로 표현하면 다음과 같을 것으로 보인다.</p><blockquote><p><code>예제 1</code> 여러 IDP 토콘을 저장하는 경우</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AWS.config.credentials = <span class="keyword">new</span> AWS.CognitoIdentityCredentials(&#123;</span><br><span class="line">    IdentityPoolId: &lt;연동 자격 증명 풀 ID&gt;,</span><br><span class="line">    Logins        : &#123;</span><br><span class="line">        'graph.facebook.com': response.authResponse.accessToken&lt;Facebook 억세스 토큰&gt;,</span><br><span class="line">    'cognito-idp.&lt;리전&gt;.amazonaws.com/&lt;유저풀 ID&gt;': result.getIdToken().getJwtToken()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p><code>예제 2</code> 순서가 정의되고 이미 <code>credentials</code> 이 이미 등록어 있어 이를 확장하는 경우</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AWS.config.credentials = <span class="keyword">new</span> AWS.CognitoIdentityCredentials(&#123;</span><br><span class="line">    IdentityPoolId: &lt;연동 자격 증명 풀 ID&gt;,</span><br><span class="line">    Logins        : &#123;</span><br><span class="line">        ...AWS.config.credentials,</span><br><span class="line">    'cognito-idp.&lt;리전&gt;.amazonaws.com/&lt;유저풀 ID&gt;': result.getIdToken().getJwtToken()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4><span id="현재-지원되는-idp-목록">현재 지원되는 <strong>IDP</strong> 목록</span></h4><ul><li>Cognito</li><li>Amazon</li><li>Facebook</li><li>Google+</li><li>Twitter / Digits</li><li>OpenID</li><li>SAML</li><li>사용자 지정</li></ul><h4><span id="use-case">Use Case</span></h4><h5><span id="두개의-idp-facebook-으로-로그인-후-cognito-로-다시-인증하는-경우">두개의 IDP: Facebook 으로 로그인 후, Cognito 로 다시 인증하는 경우</span></h5><p><code>예제 0</code> 의 코드와 같은 방식으로 두번 각기 등록하는 경우는 유저가 2명으로 인식되나 <code>Logins</code> 에 두 정보를 함께 등록하는 경우 이 정보가 취합되어 한명의 유저로 인식된다.</p><p><code>Logins</code> 에 한번이라도 함께 등록되면 각기 다른 <strong>IDP</strong>에 의해 발급된 두개의 토큰은 함께 연결되는 것으로 보인다. 때문에 함께 저장하는 순간 유저 수 인식이 2 에서 1명으로 변경된다.</p><p><img src="federated_identities_logins.png" alt="federated_identities_logins"></p><p>위 이미지는 <code>Logins</code> 에 함께 저장 후 대쉬보드의 화면이며 <strong>Facebook</strong> 로그인(파란색)과 <strong>Cognito</strong> 로그인(녹색)이 각각 카운트가 1이나 총 자격 증명이 1 로 인식되는 걸 확인 할 수 있다. 함께 저장하기 전에는 총 자격 증명이 2 였다.</p>]]></content>
    
    <summary type="html">
    
      Cognito, multi IDP login
    
    </summary>
    
    
      <category term="cognito" scheme="http://blog.bglee.me/tags/cognito/"/>
    
      <category term="multi idp" scheme="http://blog.bglee.me/tags/multi-idp/"/>
    
      <category term="idp" scheme="http://blog.bglee.me/tags/idp/"/>
    
      <category term="user pool" scheme="http://blog.bglee.me/tags/user-pool/"/>
    
      <category term="federated Identities" scheme="http://blog.bglee.me/tags/federated-Identities/"/>
    
  </entry>
  
  <entry>
    <title>✒️  Typora, 마크다운 에디터</title>
    <link href="http://blog.bglee.me/posts/2018/typora/"/>
    <id>http://blog.bglee.me/posts/2018/typora/</id>
    <published>2018-07-16T04:48:06.000Z</published>
    <updated>2018-07-19T09:31:34.616Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="typora-마크다운-에디터-소개">Typora, 마크다운 에디터 소개.</span></h1><blockquote><p>Typora 를 주제로 Typora 를 사용하여 글 작성을 테스트 중이다. <span class="github-emoji" title="cat2" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f408.png?v8">&#x1f408;</span> 때문에 글 자체 보다는 이를 통해서 블로그 포스팅에 대한 생산성 검증 목적이 있다.</p></blockquote><h2><span id="마크다운-에디터-연대기">마크다운 에디터 연대기</span></h2><p>사용하는 혹은 사용했었던 에디터들이다.</p><table><thead><tr><th>에디터</th><th>평</th></tr></thead><tbody><tr><td><a href="http://www.vim.org" target="_blank" rel="noopener">ViM</a></td><td><a href="https://github.com/vim/vim" target="_blank" rel="noopener">오픈소스</a>, 지금도 간혹 쓴다. 한글 사용시 ViM 커맨드에 대한 고질적인 문제, 외부 프리뷰 이슈, 플러그인 설정 필요.</td></tr><tr><td><a href="https://bywordapp.com" target="_blank" rel="noopener">Byword</a></td><td>앱스토어 추천, 할인에 샀으나 특이점 없음.</td></tr><tr><td><a href="http://pad.haroopress.com" target="_blank" rel="noopener">하루패드</a></td><td><a href="https://github.com/rhiokim/haroopad" target="_blank" rel="noopener">오픈소스</a>, 독립 프로개름으로는 아마도 ViM을 지원하는 유일한 에디터가 아닐까한다. 국내 개발자이신 <a href="https://github.com/rhiokim" target="_blank" rel="noopener">Rhio</a> 님이 개발했다.</td></tr><tr><td><a href="https://code.visualstudio.com" target="_blank" rel="noopener">VSCode</a></td><td><a href="https://github.com/Microsoft/vscode/" target="_blank" rel="noopener">오픈소스</a>, 마소의 오픈소스 에디터, 마크다운을 기본적으로 지원.</td></tr><tr><td><a href="http://jetbrains.com/webstorm" target="_blank" rel="noopener">Webstorm</a></td><td>개발 툴인데 붙어 있으니 가끔 <code>README.md</code> 작성용으로 사용</td></tr><tr><td><a href="https://marktext.github.io/website/" target="_blank" rel="noopener">MarkText</a></td><td><a href="https://github.com/marktext/marktext" target="_blank" rel="noopener">오픈소스</a>, 가장 최근에 사용했던 에디터, 테이블 삽입, 에디팅과 프리뷰가 함께 어우러진 것이 인상적.</td></tr></tbody></table><p>한동안 미디움에서 글을 쓰고 있었는데 <a href="https://typora.io" target="_blank" rel="noopener">Typora</a> 라는 끝내주는 마크다운 에디터를 발견했다. 사실 본지는 좀 오래되었는데 최근에 쓰고 있던 마크다운 에디터가 만족스러워서 시도는 하지 않고 있다가 한글 타이핑시 문장 마지막에 <code>Tab</code> 입력시 글자가 사라지는 버그로 인해 고생해서 옮겨타게 되었다.</p><h2><span id="typora">Typora</span></h2><p>타이포라는 아직 베타 버전이며 곧 상용화 될 것으로 보인다. 안정적이며 별 버그가 없다. 테마도 다양하게 지원되고 있으며 마크다운을 통해 작성되며 글은 바로 테마가 입혀진 모습으로 보여진다. 프리뷰와 에디터가 빌트인 된 것으로 생각하면 된다.</p><h3><span id="이모지emoji">이모지(emoji)</span></h3><p>이모지를 훌륭하게 지원한다. 찾아볼 필요없이 <code>:</code> 를 입력하는 순간 자동 완성이 이미지와 함께 지원된다.</p><h3><span id="테이블">테이블</span></h3><p>일반적인 에디터를 이용할 때 가장 문제가 되는 것은 테이블 작성이다. 테이블 작성 문법이 시간이 오래걸려 여기서 생산성에 대한 이슈가 생기는데 커맨드를 통해 빠르고 직관적으로 테이블 생성이 가능하다.</p><h3><span id="이미지">이미지</span></h3><p>이미지 지원도 다소 짜증이 나는 영역인데, 블로그 글을 포스팅 할 때 이미지를 그냥 드래그해서 붙일 수 있다. 또한 그 것을 같은 폴더에 저장할 것인지 등도 정할 수 있으므로 사용성이 꽤나 최적화 되어있다.</p><h2><span id="모자란-점">모자란 점</span></h2><p>정말로 쓸 수 있는 프로그램이 되려면 몇 가지를 개선한다. 아직은 만족하고 있으나, 사업 계획서와 같은 방대한 문서를 작성할때 이슈가 되는 것 들이 몇가지 있었다.</p><h3><span id="실행-취소-다시-실행undo-redo">실행 취소, 다시 실행(Undo, Redo)</span></h3><p>이 부분이 다소 불안정적이다. 한글 작성과 함께 꼬이는 이슈일 수 있다. 많은 글을 작성하면서 당연히 신뢰하고 있는 실행 취소와 같은 기능들이 방금 전 타이핑이 아닌 그 전에 타이핑한 글을 취소한다던지 하는 이슈가 있었다. 난 글을 작성할 때 단락의 위치를 괘나 바꾸는데 그래서 생기는 문제인지는 모르겟으나 실행 취소가 바로 전 타이핑에 대한 것이 아닌 경우가 존재했다.</p><p>이는 꽤 치명적인 글로 그 취소를 내가 인지하지 못하는 경우가 있으면 글이 틀어져 버린다.</p><hr><blockquote><p>일단 여기까지 작성후 퍼블리싱 테스트 <span class="github-emoji" title="cat2" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f408.png?v8">&#x1f408;</span></p></blockquote>]]></content>
    
    <summary type="html">
    
      Typora, 마크다운 에디터
    
    </summary>
    
    
      <category term="typora" scheme="http://blog.bglee.me/tags/typora/"/>
    
      <category term="markdown" scheme="http://blog.bglee.me/tags/markdown/"/>
    
      <category term="editor" scheme="http://blog.bglee.me/tags/editor/"/>
    
  </entry>
  
  <entry>
    <title>미디움으로 이사합니다.</title>
    <link href="http://blog.bglee.me/posts/2018/move-to-medium/"/>
    <id>http://blog.bglee.me/posts/2018/move-to-medium/</id>
    <published>2018-03-28T15:00:00.000Z</published>
    <updated>2018-03-29T06:41:17.921Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://medium.com/@deptno" target="_blank" rel="noopener">https://medium.com/@deptno</a>으로 이사합니다.</p><p>RSS: <a href="https://medium.com/feed/@deptno" target="_blank" rel="noopener">https://medium.com/feed/@deptno</a></p><p>이 곳엔 가끔 업데이트나 더 개인적인 주제들을 담고자 합니다.</p>]]></content>
    
    <summary type="html">
    
      RSS 구독자 분들을 위한 안내
    
    </summary>
    
      <category term="service" scheme="http://blog.bglee.me/categories/service/"/>
    
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="http://blog.bglee.me/posts/2017/python/"/>
    <id>http://blog.bglee.me/posts/2017/python/</id>
    <published>2017-11-10T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.631Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>macOS 기반으로 작성되었다.</p></blockquote><p>ml(머신러닝) 공부를 하기 위해 파이썬을 환경을 설정했다.</p><h2><span id="installation">installation</span></h2><p>brew는 기본적으로 설치되어 있어야 한다. <a href="http://deptno.github.io/posts/2016/osx" target="_blank" rel="noopener">참조</a></p><p>설치 각각에 종속성이 있을 수 있으므로 패키지 설치시마다 터미널을 재시작하면서 하도록 한다.</p><p>아나콘다라는 파이썬 배포판으로 데이터 사이언스 관련 패키지들을 포함하고 있다. 보통 책들에서 강력히 추천하므로 설치한다. 파이썬 배포판이므로 글을 쓰는 현재 python 3.6.3을 포함하여 설치된다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install anaconda</span><br></pre></td></tr></table></figure><p>프로젝트별 독립된 개발 환경을 만들어주는 <code>virtualenv</code>와 이를 편하게 사용하도록 해주는 <code>virtualenvwrapper</code>를 설치한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install virtualenv virtualenvwrapper</span><br></pre></td></tr></table></figure><p>사용하는 쉘의 설정 파일을 열어 다음을 추가한다. 설정 파일을 쉘에 따라 다르다.</p><p>~/.zshrc or ~/.bashrc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python virtualenv settings</span></span><br><span class="line"><span class="built_in">export</span> WORKON_HOME=~/workspace/virtualenvs</span><br><span class="line"><span class="built_in">export</span> VIRTUALENVWRAPPER_PYTHON=/usr/<span class="built_in">local</span>/anaconda3/bin/python</span><br><span class="line"><span class="built_in">source</span> /usr/<span class="built_in">local</span>/anaconda3/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure><p><code>~/workspace/virtualenvs</code> 이 부분은 사람마다 다른 경로를 사용하므로 사용하고자 하는 경로를 쓰면된다. 설정파일이 적용되기 전에(터미널 재시작 전) 폴더를 만들어준다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/workspace/virtualenvs</span><br></pre></td></tr></table></figure><p>터미널을 재시작하면 스크립트가 돌고 아래와 같은 명령어를 사용할 수 있게된다.</p><ul><li>mkvirtualenv 프로젝트명</li><li>rmvirtualenv 프로젝트명</li><li>workon 프로젝트명</li><li>deactivate</li></ul><p><code>ml</code>이라는 가상황경을 위한 라이프 사이클은 아래와 같다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 가상환경를 생성한다.</span></span><br><span class="line">bglee@since-20171107  mkvirtualenv ml</span><br><span class="line"><span class="comment"># 가상환경를 종료한다.</span></span><br><span class="line">(ml)  bglee@since-20171107  deactivate</span><br><span class="line"><span class="comment"># 가상환경에 진입한다.</span></span><br><span class="line">bglee@since-20171107  workon ml</span><br><span class="line"><span class="comment"># 가상환경를 종료한다.</span></span><br><span class="line">(ml)  bglee@since-20171107  deactivate</span><br><span class="line"><span class="comment"># 가상환경를 삭제한다.</span></span><br><span class="line">bglee@since-20171107  rmvirtualenv ml</span><br></pre></td></tr></table></figure><p>이제 가상환경은 설정이 되었고 프로젝트를 활성화(진입)한 상태로 <code>pip install package_name</code>을 할 경우 가상환경에 패키지가 포함되게 된다.</p>]]></content>
    
    <summary type="html">
    
      머신러닝을 위한 macOS 파이썬 환경설정
    
    </summary>
    
      <category term="service" scheme="http://blog.bglee.me/categories/service/"/>
    
    
      <category term="python" scheme="http://blog.bglee.me/tags/python/"/>
    
      <category term="파이썬" scheme="http://blog.bglee.me/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"/>
    
      <category term="ml" scheme="http://blog.bglee.me/tags/ml/"/>
    
      <category term="머신러닝" scheme="http://blog.bglee.me/tags/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D/"/>
    
      <category term="anaconda" scheme="http://blog.bglee.me/tags/anaconda/"/>
    
      <category term="아나콘다" scheme="http://blog.bglee.me/tags/%EC%95%84%EB%82%98%EC%BD%98%EB%8B%A4/"/>
    
      <category term="virtualenv" scheme="http://blog.bglee.me/tags/virtualenv/"/>
    
      <category term="virtualenvwrapper" scheme="http://blog.bglee.me/tags/virtualenvwrapper/"/>
    
  </entry>
  
  <entry>
    <title>Netlify</title>
    <link href="http://blog.bglee.me/posts/2017/netlify/"/>
    <id>http://blog.bglee.me/posts/2017/netlify/</id>
    <published>2017-10-03T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.627Z</updated>
    
    <content type="html"><![CDATA[<p>Netlify 는 스태틱 웹을 위한 CMS다. Git 서비스들을 통해 제공되며 레포지터리에 푸시를 할 경우 이를 자동으로 감지하고 빌드하며 재 배포한다. 여기에 본인이 도메인을 가진게 있다라면 본인의 도메인을 연결하여 서비스 할 수 있다.</p><blockquote><p>스태틱웹은 동적으로 URL을 생성하는 것이 아닌 그냥 실제 html파일 자체로 서빙을 한다고 생각하면 단순하다.</p></blockquote><p>Netlify 는 추가적으로 Let’s encrypt 를 서비스 안으로 포함시켜서 SSL(https://) 을 지원하며 이를 위해 DNS를 품고 있다. 자동으로 지원되지만 자신만의 도메인이 있어 이를 사용할 때는 Netlify DNS를 사용해야한다.</p><p>이번 &lt;bglee.me&gt;의 DNS를 Netlify 로 옮기면서 모든 페이지에 SSL을 적용하고 기존 블로그는 <a href="https://deptno.github.io" target="_blank" rel="noopener">https://deptno.github.io</a>로 되돌려 하나의 루트로 접근 경로를 통일했으며 기존 <a href="https://blog.bglee.me">https://blog.bglee.me</a>는 이제 SSL을 적용하고 기존 패스 그대로 <a href="https://deptno.github.io" target="_blank" rel="noopener">https://deptno.github.io</a>로 리다이렉트 시키도록 세팅했다. 이를 세팅 과정은 로컬 환경이 아닌 깃헙 레포지터리를 이용할 정도로 단순했고 Netlify 에서 지원하는 리다이렉트 옵션도 매우 직관적이었다.<a href="https://github.com/deptno/blog.bglee.me" title="적용 레포지터리" target="_blank" rel="noopener">1</a></p><h2><span id="배포">배포</span></h2><p>글을 작성하고 있는 현재 Netlify 에서 지원하고 있는 Git 클라우드 서비스는 아래와 같다.</p><ul><li>Gitub</li><li>Gitlab</li><li>Bitbucket</li></ul><p>잠깐 부연하자면 비공개 레포지터리를 만들기 위해서 Github은 유로 플랜을 써야하지만 나머지 둘은 기본적으로 비공개 레포지터리를 개인에게 무료로 허용한다.</p><p>로그인하면 바로 사용을 위한 화면이 시작되며 순서는 아래와 같다.</p><p><img src="netlify-sequence.png" alt="순서"></p><ul><li>사용하고 있는 레포지터리 서비스를 선택한다.(Git 클라우드 서비스들)</li><li>배포에 사용될 레포지터리를 선택한다.</li><li>배포에 사용될 브랜치, 빌드시 명령어, 그리고 빌드 명령어를 통해 생성된 배포될 파일들을 가리키는 디렉토리를 작성한다.</li></ul><p><img src="netlify-deploy.png" alt="배포"></p><p>그럼 바로 배포가 시작되며 앞으로 레포지터리에 푸시를 할 때마다 자동으로 빌드 =&gt; 배포가 진행된다.</p><h2><span id="커스텀-도메인과-dns">커스텀 도메인과 DNS</span></h2><p>커스텀 도메인을 을 사용하기 위해서는 <code>domain settings</code>에 들어가서 <code>custom domain</code>을 누르고 본인의 도메인을 입력해야한다. 도메인 셋업은 <code>www.YOUR_DOMAIN</code>을 통해야 SSL서비스를 받을 수 있다.</p><p>예를 들어 필자는 <code>www.bglee.me</code>를 입력하고 <code>HTTPS</code> 에서 주소를 확인한뒤에 <code>Force TLS connections</code>를 활성화 시켜 http접속을 https로 강제 리다이렉트 시켰다.</p><p>Netflify 에서는 <code>bglee.me</code>가 아닌 <code>www.bglee.me</code>를 등록하라고 권고하고 있으며 <code>www.bglee.me</code>를 등록시에 <code>bglee.me</code>도 자동으로 Netlify에 의해 등록되며 &lt;bglee.me&gt; 접속시 &lt;<a href="http://www.bglee.me&gt;로" target="_blank" rel="noopener">www.bglee.me&gt;로</a> 강제 리다이렉트된다.</p><h2><span id="추가적인-기능">추가적인 기능</span></h2><p><strong>와…</strong> 한 기능들을 몇개 지원한다.</p><h3><span id="브랜치를-통한-ab-테스트-지원">브랜치를 통한 A/B 테스트 지원</span></h3><p>브랜치를 추가적으로 등록할 수 있는데(A/B테스트 메뉴) 자동으로 로드밸런싱을 해서 A/B테스트를 하게 해준다.</p><h3><span id="pr시-스테이지-url">PR시, 스테이지 URL</span></h3><p>PR이 왔을시 이에대한 Preview URL을 생성할 수 있으며 이를 스테이지로 활용할 수 있다.</p><hr><h2><span id="next">next</span></h2><p>이제 스태틱 사이트를 작성하고 배포해보자.</p><hr>]]></content>
    
    <summary type="html">
    
      Git 레포지터리 Push 만으로 https까지 적용된 사이트를 지속적으로 빌드하고 배포할 수 있다.
    
    </summary>
    
      <category term="service" scheme="http://blog.bglee.me/categories/service/"/>
    
    
      <category term="netlify" scheme="http://blog.bglee.me/tags/netlify/"/>
    
      <category term="https" scheme="http://blog.bglee.me/tags/https/"/>
    
      <category term="ssl" scheme="http://blog.bglee.me/tags/ssl/"/>
    
      <category term="스태틱 웹" scheme="http://blog.bglee.me/tags/%EC%8A%A4%ED%83%9C%ED%8B%B1-%EC%9B%B9/"/>
    
      <category term="static web" scheme="http://blog.bglee.me/tags/static-web/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript와 Redux connect</title>
    <link href="http://blog.bglee.me/posts/2017/typescript-redux-connect/"/>
    <id>http://blog.bglee.me/posts/2017/typescript-redux-connect/</id>
    <published>2017-10-02T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.633Z</updated>
    
    <content type="html"><![CDATA[<p>타입스크립트와 리덕스로 SPA를 구현하는데 있어 기본적인 셋업이 아닌 문법적인 측면에 포커싱된 글로 타입스크립트를 활용하는데 도움이 되었으면한다.</p><p>필자는 하드 타이핑을 하지 않으며 추가적으로 린트를 쓰지 않는다. 리덕스는 자체적으로 타입스크립트 데피니션 파일(d.ts)을 가지고 있으므로 따로 타입 관련 패키지를 설치하지 않아도 된다.</p><h2><span id="설치">설치</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev typescript</span><br><span class="line">npm install redux</span><br></pre></td></tr></table></figure><h2><span id="redux">redux</span></h2><p>리덕스에 대한 설명을 돕기 위해 루트 스토어가 가지는 스테이트의 타입을 아래와 같이 정의하기로한다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.d.ts</span></span><br><span class="line"><span class="keyword">interface</span> RootState &#123;</span><br><span class="line">bglee: User</span><br><span class="line">deptno: User</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">name: <span class="built_in">string</span></span><br><span class="line">email: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="connectargs">connect(..args)</span></h3><p>리덕스를 쓰면서 가장 많이 쓰게 되는 함수일텐데 코드를 먼저 보이면 아래와 같다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123;connect, bindActionCreataors&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> StateProps &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> DispatchProps &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> OwnProps &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Props = StateProps &amp; DispatchProps &amp; OwnProps</span><br><span class="line"><span class="keyword">interface</span> State &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Container = connect&lt;StateProps, DispatchProps, OwnProps&gt;(</span><br><span class="line">(state: RootState) =&gt; (&#123;&#125;),</span><br><span class="line">dispatach =&gt; bindActionCreators(&#123;&#125;, dispatch)</span><br><span class="line">)(</span><br><span class="line"><span class="keyword">class</span> Component <span class="keyword">extends</span> React.Component&lt;Props, State&gt; &#123;</span><br><span class="line">render() &#123;</span><br><span class="line"><span class="keyword">return</span>&lt;p&gt;hello world&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p>위 코드는 완전히 동작하는 코드이고 컨테이너를 정의하기 위해 풀어쓴 기본적인 형태다. 참고로 connect 함수는 추가적인 옵션을 기술하기 위해 4개까지 인자를 받을 수 있다.</p><p>connect를 보면 3개의 타입을 받고 있다. 순서대로 살펴 보겠다.</p><h4><span id="stateprops">StateProps</span></h4><p>connect의 첫번째 인자는 <code>mapStateToProps</code>로 정의되어 있으며 함수 명과 같이 <code>Store</code>의 state를 <code>Component</code>의 props로 주입하는 함수다. 이 함수의 리턴 타입이라고 생각하면 된다.</p><p>예를 들어 Store에 <code>bglee</code>라는 프로퍼티를 연결하고자 한다면 <code>mapStateToProps</code>는 아마도 다음과 같이 작성되게 된다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStaetToProps = <span class="function">(<span class="params">state: RootState</span>) =&gt;</span> state.bglee</span><br></pre></td></tr></table></figure><p>그러면 Container는 props로 bglee가 가지고 있는 <code>name</code>, <code>email</code>을 받게 된다. 그럼 그에 맞춰서 <code>StateProps</code>를 정의하면 된다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StateProps &#123;</span><br><span class="line">name: <span class="built_in">string</span></span><br><span class="line">email: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>작성하고 보니 <code>User</code> 타입과 동일하다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StateProps = User</span><br></pre></td></tr></table></figure><p>로 정의해도되고 코드에서 StateProps를 User로 치환해도 된다. 이 경우는 예제를 위해 특수한 케이스기 때문에 이러하지만 여러 state를 props로 연결해야한다라면 곧 확장을 해야하니 StateProps라는 이름의 컨벤션을 유지해서 코드 일관성, 가독성을 확보하자.</p><p>다시 <code>mapStateToProps</code> 함수를 구현한 코드를 보면 아래와 같이 보일 것이 의심치 않는다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStaetToProps = (state: RootState): <span class="function"><span class="params">StateProps</span> =&gt;</span> (&#123;</span><br><span class="line">name: state.name,</span><br><span class="line">email: state.email</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>이해를 돕기 위해 완전히 풀어서 보였다. StateProps가 리턴되고 있다는 것만 인지하고 있으면 되며 위와 같은 코드작성은 connect가 타입을 받는 이유와 상충되므로 줄여서 작성하도록 하자.</p><h4><span id="dispatchprops">DispatchProps</span></h4><p>두번째 인자는 dispatch할 액션들이 Component의 props로 매핑된다. 위와 마찬가지로 두번째 인자의 이름인 <code>mapDispatchToProps</code>의 리턴 타입이다.</p><p>완벽한 이해를 위해 아래와 같이 액션이 정의해보자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contactBglee = <span class="function">(<span class="params"><span class="keyword">from</span>: <span class="built_in">string</span></span>) =&gt;</span> (&#123;</span><br><span class="line"><span class="keyword">type</span>: <span class="string">'CONTACT_BGLEE'</span></span><br><span class="line">payload: &#123;</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>액션은 <code>type</code>을 포함하는 오브젝트를 리턴하는 함수이며 <code>bindActionCreators</code>함수를 통해 dispatch가능한 형태가 된다.</p><p>그럼 두번째 인자의 구현부를 다시 보자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch = bindActionCreators(&#123;&#125;, dispatch)</span><br></pre></td></tr></table></figure><p>이름을 달고 정의한 액션을 바인딩해보자</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> bindActionCreators(&#123;</span><br><span class="line">contactBglee</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>작성된 <code>mapDispatchToProps</code>함수를 두번째 인자로 전달하게 되며 Container는 <code>contactBglee</code>액션을 디스패칭할 수 있다. Container는 <code>contactBglee</code> props를 가지고 있다는 의미며 이를 컴파일러에게 알려주기위해 두번째 DispatchProps는 아래와 같이 정의된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Dispatchprops &#123;</span><br><span class="line">contactBglee: typeof contactBglee</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>typeof</code>를 유심히 보자 contactBglee의 액션이 <code>from: string</code>인자를 취하는데 이를 재 다시 정의하는 것이아니라 기존 정의로부터 타입을 가지고 와서 추가해준다. 따라서 우린 중복정의 없이 기존 정의를 <code>typeof</code> 키워드를 통해서 쓸 수 있다.</p><h4><span id="ownprops">OwnProps</span></h4><p>마지막 타입은 기존 우리가 컴포넌트를 정의할 때 받는 부모로 부터 받게되는 그 인자를 정의하면 된다. <strong>컴포넌트를 컨테이너로 변경하는 경우라면 기존 컴포넌트의 인자가 OwnProps로 변경된다.</strong></p><hr><p>개인적으로 수없이 정의하게 되는 이런 타입과 함수들이 매우 반복적이기 때문에 <code>mapStateToProps</code>와 같은 함수를 정의하는 대신 inline으로 삽입하는 것을 선호하며 위에 설명한 것들을 함쳐 결과를 보면 아래와 같다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123;connect, bindActionCreataors&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123;contactBglee&#125; <span class="keyword">from</span> <span class="string">'./actions'</span> <span class="comment">// 액션이 존재하는 곳</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> StateProps <span class="keyword">extends</span> User &#123;&#125; <span class="comment">// type으로 정의도 가능하다</span></span><br><span class="line"><span class="keyword">interface</span> DispatchProps &#123;</span><br><span class="line">contactBglee: <span class="keyword">typeof</span> contactBglee</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> OwnProps &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Props = StateProps &amp; DispatchProps &amp; OwnProps</span><br><span class="line"><span class="keyword">interface</span> State &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Container = connect&lt;StateProps, DispatchProps, OwnProps&gt;(</span><br><span class="line">(state: RootState) =&gt; (&#123;</span><br><span class="line">...state.bglee</span><br><span class="line">&#125;),</span><br><span class="line">dispatach =&gt; bindActionCreators(&#123;</span><br><span class="line">contactBglee</span><br><span class="line">&#125;, dispatch)</span><br><span class="line">)(</span><br><span class="line"><span class="keyword">class</span> Component <span class="keyword">extends</span> React.Component&lt;Props, State&gt; &#123;</span><br><span class="line">render() &#123;</span><br><span class="line"><span class="keyword">return</span>&lt;p&gt;hello world&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><h2><span id="next">next</span></h2><p>이제 <code>render()</code>함수 안에서 this.props 그리고 <code>.</code>을 찍어보자.</p>]]></content>
    
    <summary type="html">
    
      redux connect를 제대로 typing 해보자
    
    </summary>
    
      <category term="dev" scheme="http://blog.bglee.me/categories/dev/"/>
    
      <category term="ts" scheme="http://blog.bglee.me/categories/dev/ts/"/>
    
    
  </entry>
  
  <entry>
    <title>Next.js</title>
    <link href="http://blog.bglee.me/posts/2017/next-js/"/>
    <id>http://blog.bglee.me/posts/2017/next-js/</id>
    <published>2017-05-07T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.630Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="nextjs">Next.js</span></h1><p>현재 회사의 <a href="https://www.rsquare.co.kr" target="_blank" rel="noopener">고객사이트</a>를 <a href="https://zeit.co/blog/next2" title="next.js" target="_blank" rel="noopener">next.js</a>와 <a href="https://www.typescriptlang.org/" title="typescript" target="_blank" rel="noopener">typescript</a> 기반으로 2017-04-10 일 기준으로 배포되었다. 간단하게 소개를 하고자 한다.</p><h2><span id="nextjs">next.js</span></h2><blockquote><p><a href="https://zeit.co/blog/next2" title="next.js" target="_blank" rel="noopener">next.js</a>는 node.js, <a href="https://facebook.github.io/react/" title="react.js" target="_blank" rel="noopener">react</a>기반의 유니버살 렌더링을 지원하는 프레임웍이다. 첫 접속시에는 서버로부터 첫 페이지를 구동하기 위한 청크를 가져가게되며 한번 접속한 페이지에 대해서는 데이터 청크가 있으므로 SPA와 같이 동작하게 된다.</p></blockquote><h3><span id="라우팅">라우팅</span></h3><p>라우팅은 기본설정으로 <code>pages/</code> 디렉토리가 루트가 된다. 기본 라우팅은 <code>index.html</code>에 매칭되는 <code>index.js</code>가 된다.</p><p>디렉토리 구조가 그대로 서비스 라우팅에 매칭되기 때문에 특별히 할 일이 없어서 빠른 속도로 개발을 시작할 수 있다.</p><p>그럼 html에 해당하는 template은 어디서 제어하는가?</p><h4><span id="pages_documentjs">pages/_document.js</span></h4><p><code>_document.js</code>는 <code>index.html</code>의 템플릿에 해당하는 정보를 내려주는 리엑트 컴포넌트로 시그니쳐가 <code>React.Component</code>의 상속이 아닌 <code>next/document</code> 패키지의 Document 컴포넌트를 상속해서 만들게 된다. 자세한건 문서를 참조한다.</p><h4><span id="pages_errorjs">pages/_error.js</span></h4><p>SSR이 지원되기때문에 데이터를 서버에서 미리 패칭하여 내릴 수 있다. 이런 경우를 포함해서 예외처리가 제대로 되지 않은 경우 <code>500</code>에러를 내리게 되는데 그에 대한 에러 <code>status</code>를 받아 그에 맞는 화면을 내릴 수 있다. <code>_document.js</code>와는 달리 <code>React.Component</code>를 상속한다.</p><h3><span id="api">api</span></h3><p>next.js에서는 리액트 컴포넌트를 내릴때 특수한 <code>static</code> 메서드를 정의할 수 있는데 이 함수는 서버와 클라이언트 모두에서 사용되며 서버일 경우와 클라이언트일 경우에 대한 분기를 여기서 정할 수 있다. 이를 통해서 서버인 경우에 대한 처리, 클라이언트에 대한 처리를 추가할 수 있다.</p><h4><span id="getinitialprops">getInitialProps()</span></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Index <span class="keyword">extends</span> React.Component&lt;<span class="literal">null</span>, <span class="literal">null</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> store: Store&lt;RSquareStore&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> getInitialProps(&#123;req&#125;) &#123;</span><br><span class="line">        <span class="keyword">const</span> server = !!req;</span><br><span class="line">        <span class="keyword">const</span> store  = <span class="keyword">await</span> storeCreator(reducer, <span class="literal">null</span>, server);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">await</span> store.dispatch(getCatalogue());</span><br><span class="line">        &#125; <span class="keyword">catch</span>(ex) &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> initialState = store.getState();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;initialState, server, catalogue: initialState.themes.catalogue&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.store = storeCreator(reducer, props.initialState, props.server);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Provider store=&#123;<span class="keyword">this</span>.store&#125;&gt;</span><br><span class="line">                &lt;Layout&gt;</span><br><span class="line">                    &lt;Head&gt;</span><br><span class="line">                        &lt;title&gt;&#123;<span class="string">`SEO_TEXT`</span>&#125;&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;/</span>Head&gt;</span><br><span class="line">                    &lt;Home catalogue=&#123;<span class="keyword">this</span>.props.catalogue&#125;/&gt;</span><br><span class="line">                &lt;<span class="regexp">/Layout&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Provider&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>단순한 구현은 위와 같다. 구조에는 redux가 쓰였으며 이를 위해 스토어를 생성해서 내리고 있는 걸 볼 수 있다. <code>&lt;Head&gt;</code>컴포넌트도 보이는데 <code>helmet</code> 역할로 헤더쪽으로 자식 태그들을 펌핑해준다. 동적으로 바껴야하는 메타태그들을 여기서 처리하면 된다.</p><h3><span id="pros">pros</span></h3><ul><li>라우팅이 정형화된 디렉토리 구조로 되어 있기 때문에 직관적이다.</li><li>API가 적다.</li><li>유니버설 렌더링의 지원한다.</li></ul><h3><span id="cons">cons</span></h3><ul><li>표준으로 자리잡았다 싶은 기존의 리액트용 라이브러리들과 함께 사용하려면 커스텀 셋업이 필요하다.</li></ul><p>###</p>]]></content>
    
    <summary type="html">
    
      react SSR 을 지원하는 next.js의 사용법을 간단히 소개한다.
    
    </summary>
    
      <category term="dev" scheme="http://blog.bglee.me/categories/dev/"/>
    
      <category term="js" scheme="http://blog.bglee.me/categories/dev/js/"/>
    
    
  </entry>
  
  <entry>
    <title>Texts 구현</title>
    <link href="http://blog.bglee.me/posts/2017/texts/"/>
    <id>http://blog.bglee.me/posts/2017/texts/</id>
    <published>2017-05-07T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.633Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="texts-구현"> 구현</span></h1><p><img src="https://lh3.googleusercontent.com/t_LQOLOXJ64l4zi05A_-By3QDDo7FIvWREe9meD6ZCuAUBlv8Y-DwyvzvShtR1v192sdYwfvgGG8e4S5pEsuAksPuyPj6MTBZBZvHvZIvMkyFH2j2I6_A4VIeZ3GOKyGigOg0dID1VQpXYTDkIDNJ_fFzjH39iPbM7p08KX1UWhOT02uU0yR0RK-3lH8obg57t9sohm4OUZVa-skdrOWh1U_qM_yKAiGhhkUIFBFAjCvdpmmiQIGk-zWX2MpVMHqkTDDbF9wyp87m2PbYegL5SuNTibFrYVTnRHfeCS8cA1uV7skajLXVK9cMuoKbSgyjMQAM3ZQ_kiaez78tvMz03tKKxtghcf4oyQHkHD3OIx15HdJad3W48oJxTBkyPO9DvR7r7dRVT4mGw70Tx1dZcYog6YeWPzXMCXl6SgO37QP3raxZMpkgbhWy5kzhbSmE-uIigUHUyiEo9gLhOwsVNwW1pzW9-LP4HDuwO7XGeVTep9SAaPCAIs4_SfiLwM3L0BoEPpxPPY7MBd-6FkofxblJsf_uset1CHbpT2xqUG2CHKO8Q79YJqgte5I34JK6mj42S89EDRO0lbg3VG769NRsbWuCLT4GWagjHJw5gpkdsvkC0xpszdilkBUprqzqy27ZbJti2I4VtBx53qlUOCDTKQdW_TN9NyH=w1139-h410-no" alt="" title="texts image"></p><blockquote><p>기획자 디자이너, 퍼블리셔와의 협업시 문구 변경으로 인한 피로를 덜기 위해 ID기반의 문구 관리를 앱</p></blockquote><h2><span id="동기">동기</span></h2><ul><li>부동산 계열에서 일을 하다보니 너무많은 term이 존재한다.</li><li>사소한 문구 변경이 데일리로 일어난다.</li><li>퍼블리셔 쪽에서도 html에 대한 이력관리를 원한다.</li><li>문구 변경과 markup의 변경이 구분되지 않는다.</li><li>react로 퍼블리싱하지 않는 이상 태그를 그대로 사용하지 못하므로 daily diff이슈가 존재한다.</li><li>여러 곳에서 동일하게 쓰이는 문구 변경이 일어난 경우 diff에 혼란이 있다.</li></ul><h2><span id="개발">개발</span></h2><blockquote><p>일단 퍼블리셔 쪽에서 <code>ID</code>를 사용하용하여 퍼블리싱 할 수 있게 끔 하는 것을 최우선으로 했다.</p></blockquote><ul><li>독립적으로 사용할 수 있도록 <a href="https://www.serverless.com" target="_blank" rel="noopener">serverless</a>를 통해 DB까지 한번에 deploy한다.</li><li>backend 엔드포인트만 사용자 별로 바꾸면 되니까 fe는 직접 만들어서 배포했다. <strong><a href="https://texts.surge.sh" target="_blank" rel="noopener">Texts</a></strong></li></ul><h2><span id="운영">운영</span></h2><h3><span id="기획스트링-관리-주체">기획(스트링 관리 주체)</span></h3><ul><li><a href="https://texts.surge.sh" target="_blank" rel="noopener">https://texts.surge.sh</a>?endpoint=https://[BACKEND_ENDPOINT] 접속</li><li>스트링 마음껏 만들고 잘 됬으면 deploy한다.</li></ul><h3><span id="퍼블리셔">퍼블리셔</span></h3><ul><li>퍼블리셔 쪽에서는 <code>&lt;div data-text-id=&quot;TEXT_ID&quot;/&gt;</code>와 같은 형식으로 퍼블리싱을 할 수 있게한다.</li><li>퍼블리셔는 눈으로 이를 확인할 수 있어야하므로 이를 치환해주는 태그를 서비스해준다. <strong><a href="https://texts-translator.surge.sh" title="texts" target="_blank" rel="noopener">Texts Translator</a></strong></li><li>퍼블리셔가 동적인 동작을 위해 <code>jQuery</code>태그를 심듯이 심어주면 동적으로 확인이 가능해준다.</li></ul><h3><span id="개발">개발</span></h3><ul><li>개발 버전에서는 퍼블리셔와 같이 태그를 심어서 스트링 관리주체가 변경하는 것을 즉각적으로 확인할 수 있게끔 한다.</li><li>프로덕션 릴리즈시에 아래 형식으로 저장해서 CI빌드시에 넣으면된다.</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ http post https://[END_POINT]/json &gt; language_ko.json</span><br></pre></td></tr></table></figure><h2><span id="todos">todos</span></h2><ul><li>퍼블리셔쪽에 구문 변경으로 인한 스트레스에서 벗어나고 싶지않냐고 설득한다.</li><li>기획자분이 스트링을 관리할 수 있도록 제안하고 설득한다.</li></ul><h2><span id="히스토리">히스토리</span></h2><ul><li>표준을 이용할 수 있게 끔 <code>Intl</code>을 붙이려고 디자이너쪽에서 태그를 어떻게 사용하게 해야할지 감이 오지 않아 뒤로 미뤘다.</li></ul><h2><span id="장점">장점</span></h2><ul><li>퍼블에서도 모델을 분리한다.</li><li>모델, 디자인, 컨트롤의 물리적인 관리주체(부서)가 명확해 진다.</li></ul><h2><span id="단점">단점</span></h2><ul><li>서비스가 아니라 aws 설치 형태라 결국 나만의…</li></ul>]]></content>
    
    <summary type="html">
    
      기획자 디자이너, 퍼블리셔와의 협업시 문구 변경으로 인한 피로를 덜기 위해 ID 기반의 문구 관리
    
    </summary>
    
      <category term="dev" scheme="http://blog.bglee.me/categories/dev/"/>
    
      <category term="js" scheme="http://blog.bglee.me/categories/dev/js/"/>
    
    
  </entry>
  
  <entry>
    <title>yarn</title>
    <link href="http://blog.bglee.me/posts/2016/yarn/"/>
    <id>http://blog.bglee.me/posts/2016/yarn/</id>
    <published>2016-12-11T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.634Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://yarnpkg.com/assets/feature-speed.png" alt=""></p><p><code>yarn</code>은 동시 다운로드를 지원하는 <code>npm</code>이라고 보면된다. 디펜던시 트리를 저장하고 있어서 빠르게 인스톨을 하므로 CI등에서 위력을 발휘한다.<br>기본 지식은 <a href="https://yarnpkg.com/en/docs/cli/info" target="_blank" rel="noopener">문서</a>를 참고하면 된다.</p><blockquote><p><code>yarn global add [package]</code> 커맨드를 통해 인스톨을 한 경우 <code>npm</code>과 달리 실행이 안되는 문제가 있다.</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; yarn global add typescript</span><br><span class="line">yarn global v0.17.8</span><br><span class="line">warning No license field</span><br><span class="line">[1/4] 🔍  Resolving packages...</span><br><span class="line">[2/4] 🚚  Fetching packages...</span><br><span class="line">[3/4] 🔗  Linking dependencies...</span><br><span class="line">[4/4] 📃  Building fresh packages...</span><br><span class="line">success Installed typescript@2.1.4 with binaries:</span><br><span class="line">      - tsc</span><br><span class="line">      - tsserver</span><br><span class="line">warning No license field</span><br><span class="line">✨  Done <span class="keyword">in</span> 1.56s.</span><br><span class="line"></span><br><span class="line">&gt; tsc</span><br><span class="line">zsh: <span class="built_in">command</span> not found: tsc</span><br></pre></td></tr></table></figure><p><code>bash</code> 를 이용하고 있다면 될 수도 있을 것 같은데 필자와 같이 <code>zsh</code>를 사용하고 있다면 아래와 같이 한줄을 추가해자.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"export PATH=\$PATH:`yarn global bin`"</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><p>이후 실행</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; tsc -v</span><br><span class="line">Version 2.1.4</span><br></pre></td></tr></table></figure><p><code>npm</code>을 통해서도 인스톨을 했다라면 패스 문제로 버전 문제가 생길 수 있으니 둘중 하나만 사용하자.</p><hr><p>2016-12-26 추가</p><p><code>brew</code>를 통해 <code>yarn</code>을 설치한 경우 위 방법으로는 <code>yarn global add [package]</code>로 추가한 모듈이 동작을 안한다. <code>npm global</code>, <code>yarn global</code>, <code>brew</code>가 꼬여서 생기는 문제일 것 같은데 일단 해결책은 <code>brew</code>를 통해서 설치했다면 다시 아래를 추가로 입력해주면 된다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"export PATH="</span><span class="variable">$PATH</span>:<span class="variable">$HOME</span>/.config/yarn/global/node_modules/.bin<span class="string">"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      facebook 에서 만든 `NPM` 의 래퍼 `yarn`에 대해서 설명한다. `yarn`을 소개한다.
    
    </summary>
    
      <category term="setup" scheme="http://blog.bglee.me/categories/setup/"/>
    
      <category term="js" scheme="http://blog.bglee.me/categories/setup/js/"/>
    
    
      <category term="npm" scheme="http://blog.bglee.me/tags/npm/"/>
    
      <category term="yarn" scheme="http://blog.bglee.me/tags/yarn/"/>
    
  </entry>
  
  <entry>
    <title>W3C HTML5 Conference 2016</title>
    <link href="http://blog.bglee.me/posts/2016/w3c-html5-conference-2016/"/>
    <id>http://blog.bglee.me/posts/2016/w3c-html5-conference-2016/</id>
    <published>2016-12-07T12:10:13.000Z</published>
    <updated>2018-07-16T06:10:14.940Z</updated>
    
    <content type="html"><![CDATA[<p>개인 정리</p><hr><p><img src="https://lh3.googleusercontent.com/SQ9w6ZjKzT0NjWcpBNb6EH1j-EJUA762WiyhVjVXvrqusDFXsuNSs3R0Oz_T6JTpvOxqREQ2IyqwGQ3f-gc6wS_O9D98AO7woVzCxVEfOJcpG1abOk7FcweH0HtVh3ZJcRc-BqT9gZR3DW60kAqhdgWXWMzk8FJZfsxI32tLKGooxSTyz5BDmZT8YhrybZ77b3q5TgCrdCw4hOFkEU5tbXD8OMvo0ZLkqDn4gvpEq04-9mSgHOX7dAX8jKZ9M2BmSuBQtN_Zog2gmoXpKiVhtH4zExqOr_Eldb2pOTJslGJo0PFi_oEEK8u0mW3AYAvog91NzdH71YmZZfHh9UOYivxbiHvss-GIoAPohSyHm8fmSdFl6AEw-qw5WPZ7YnjGpN8Ll_-IUcAhd4-cEPBzQ-9E3XgfGPeGH3qWajuuYt1Q6BVfNTX_D7UOWveOVIV4VWuCxufGi2NCGlL5M_ZVqt7ZVSrQZX0jFgWVA_qY8FE4BPZPcB5dI_eRp8FuAQq8mYJxYV0Uk8wHf50N23zeMWTJPibNniMKyecbyXU3rktm1yG92drvTdiyBaY7gc0pdv_v5aRc7gUemueFlK8FsBVlwfBIdgW-moDUrBFrGlnXFjI3gjJsJ-lPgKVVkhTPGqoQTWB5h-ija2wqpACnSBGsCD2gqiYPmt2lX4f2SUg=w895-h672-no" alt=""></p><h2><span id="키노트-1박종목">키노트 1(박종목)</span></h2><h3><span id="웹의-발전">웹의 발전</span></h3><ul><li>스태틱 웹</li><li>웹 2.0(ajax) - symbolic boom</li><li>read, write web(muchine to muchine), 스맨틱 웹(figure, article, header tag), 웹 3.0</li></ul><h3><span id="네이버의-인공지능-사례들">네이버의 인공지능 사례들</span></h3><ul><li>페이지랭킹은 오래됬고 머신러닝으로 랭킹 먹인다.</li><li>지식 쇼핑 40억개 상품, 4000카테고리가 있어서 딥러닝을 통해 자동분류한다.</li><li>위치 기반 검색 지역의 특성등을 인공지능으로 추출한다.<ul><li>전주 한옥마을에 대한 블로그 데이터의 자연어를 분석해서 전주 한옥마을에 대한 특성들을 분석함(크롤링과는 좀 다름)<ul><li>Context-aware analysis based on charateristics of loacation</li><li>해시 태그화 등</li></ul></li></ul></li><li>이미지 검색시의 정렬등</li><li>상품검색의 스타일 서치(유사 상품) topic model을 추출한다.</li><li>인식기술이 많이 발전함<ul><li>머신러닝을 하면서 인식률이 85% =&gt; 95%로 증대</li></ul></li><li>음석 합성도 지원함(사전, 뉴스 읽기, 라인 사전)</li><li>기계번역(통계기반 번역) =&gt; 머신러닝(뉴런) 투입하면서 번역률이 2배정도됌</li><li>amica.ai, 12초 whale browser는 파파고 엔진으로 웹페이지 번역 지원됨</li></ul><p>사용자와의 인터렉션은 음성기반으로 바뀔꺼다.(시리 등등)<br>챗봇(사용자들은 메시징하는데 더 많은 시간을 쓴다(웹은 20%정도)) - 페이스북<br>자율주행(아직은 연관성 별로 없음)<br>스마트 홈(IoT)<br>로봇</p><h3><span id="관련된-웹-표준">관련된 웹 표준</span></h3><ul><li>Voice XML</li><li>시맨틱 웹(3.0에서 실패했던 것이 지금)</li></ul><h3><span id="이에-대한-안좋은-시각생각">이에 대한 안좋은 시각(생각)</span></h3><ul><li>웹표준이 아닌, 애플, 구글, 페이스북등이 사실상 리딩</li><li>산업에 변화에 비해 웹 표준은 느리다는게 걸림</li><li>태생이 다큐먼트 컨셉</li></ul><h3><span id="web의-next">Web의 Next?</span></h3><ul><li>IoT</li></ul><h2><span id="키노트-2김국현">키노트 2(김국현)</span></h2><p>IT 세대론…</p><p>코볼은 | C, C++에<br>Java(자바는 코볼을 품음) | JS<br>에 막히고 3세대로 가고 있다.</p><p>특이사항 없음</p><p>@goodhyun</p><h2><span id="패널토의">패널토의</span></h2><p>웹이 다큐먼트인가? 거의 UI로 사용된다. 그러면 모델이 다큐먼트인게 맞는가<br>1조개의 센서, 세금을 블록체인으로 걷는다.<br>서로 다른얘기 함.. 여튼 지금 혁명중</p><p>Q: 네이버 브라우저 왜 만드셨어요?</p><p>A: 사용성이 안좋다. 선두업계 주자라 인터넷 환경 자체를 개선하겠다.</p><p>Q: 삼성도 MS따라서 오픈소스하나?</p><p>A: 변명함, artik이라는 보드도 오픈소스로 내놓음 ecma준수하는 jscript 만듬(40k정도)</p><p>Q: 웹이 성숙된 표준을 가지고 잘 따라고 있는가?</p><p>A: 웹 !== 웹브라우저, 칩에도 js call이 들어간다. 쉐이딩 영역도 js가 먹을꺼같다. iot도 먹고있다. 웹을 구성하는 기술들로 간다.</p><p>Q: JS로 IoT하는데 이게 웹인가?</p><p>A:</p><ul><li>웹이라고 하는듯 의견이 갈림</li><li>스펙은 잘 따라가지 못하기 때문에 프레임웍에서 많은 일들을 해야하며 리액트를 디펙토로 가던지 등등 맞다고 생각되는 것을 밀어야한다.</li><li>웹의 기본 철학은 탐험과 연결이다.</li></ul><p>Q: 4차 산업 혁명 준비 예산은? 내년</p><p>A: 주용환</p><ul><li>40억 규모: 엑티브엑스 개선, 웹 표준 확산</li><li>기업지원은 웹이 새롭게 쓰이는 서비스에 지원하려함 올해 2억 수준이었는데 10억 이상 수준으로 편성하려함, VR등 국내사례가 별로 없음.</li><li>빅테이터, 인공지능 이쪽이 지원 받을게 많다.</li></ul><p>Q: 뉴런번역 API 제공 계획 없나</p><p>A: 모른다 ㅠㅠ</p><hr><h2><span id="트랙-b">트랙 B</span></h2><h3><span id="second-screen-amp-webrtc">Second Screen &amp; WebRTC</span></h3><h4><span id="webrct-표준-현재와-미래">WebRCT 표준 현재와 미래</span></h4><p>최진호 - REMOTE MONSTER</p><p>페이스 챗 카카오톡 슬랙, 아마존 등등에서 다 사용이나 아직 Draft단계이며 5년정도밖에 되지 않는다.</p><p>전화기 오픈소스라고 생각하면 이해하기 빠르며 표준화를 진행중이다.(구글이)<br>P2P지만 서버(시그널 서버)는 필요하다.<br>토폴로지 구성 및 브로드캐스팅이 가능</p><p>API</p><ul><li>getUserMedia</li><li>RTCPeerConnection</li><li>RTCDataChannel</li></ul><p>표준화된 프레임웍이 없다.<br>네트워크 및 안드로이드 파편화에 따라 성능차이가 많이 난다.<br>UDP를 사용</p><p>그럼에도 불구하고</p><ul><li>커뮤니티가 강하다. <a href="https://www.facebook.com/groups/rtc.korea" target="_blank" rel="noopener">https://www.facebook.com/groups/rtc.korea</a></li><li>WebRTC PaaS도 존재한다.</li><li>1200+ 서비스, 브라우저들이 지원함, 3.1조억+ 기업 인수, 투자 규모</li><li>엔지니어 구하기가 힘들어서 인수할 정도로 귀족 개발자</li><li>17년 1Q Recommandation 예정</li><li>엣지도 지원, 애플도 지원 예정 (H.264)</li><li>크롬 55에 RTC관련 업데이트가 대거</li><li>용량이 크기때문에 IoT에 대응하기에는 쉽지않지만 빌드 잘하면된다..</li><li>AR, VR에 유용할 것으로 예상된다.</li><li>Google Duo = WebRTC + QUIC 빠른 서비스.</li><li>통신, 방송, IoT분야에서 활약할 것으로 기대된다.</li></ul><h4><span id="webrct-서비스-개발사례와-시사점">WebRCT 서비스 개발사례와 시사점</span></h4><p>이랑혁 - 구루미</p><p>HLS보다 딜레이가 적다. RTSP, RTMP, HLS 가능<br>일반전화 연결이 가능하다(?)</p><p>협업 &gt; 교육 &gt; 상담(의료) &gt; 관제 등 순으로 비지니스 니즈가 있었음</p><p>WinXP, IE 이슈 해결</p><ul><li>일렉트론</li><li>세계적으론 20%대이니 기다려라(국내는 70%이상)</li><li>아니면 앱 만들어서 배포해라</li></ul><p>기회</p><ul><li>크롬 기반 브라우저 확산(웨일 브라우저)</li><li>에코 확장<ul><li>대기업의 신규 서비스</li><li>교육 및 의료 부문 전환중(정부 3.0)</li></ul></li><li>ActiveX 제거</li></ul><h4><span id="second-screen과-웹-커넥티비티">Second Screen과 웹 커넥티비티</span></h4><p>송효진 - LG전자</p><p>다른 기기로 화면이나 앱을 보내서 실행하는 것</p><p>커넥티비티</p><ul><li>네트워크를 통해 떨어진 두 지점을 연결</li></ul><p>ECMA<br>W3C<br>IETF(L3)<br>IEEE(L2)</p><p>IETF</p><ul><li>HTTP/2(One TCP Connection)</li><li>QUIC(based on UDP)</li><li>IPv6</li><li>IPv6 over Bluetooth/NFC(IOT 기반으로 이터넷이아닌디바이스에서 가능)</li></ul><p>Application</p><ul><li>W3C Presentation API</li><li>W3C Remote Playback API</li></ul><p>Underlying Protocol</p><ul><li>SSDP, mDLS</li></ul><p>기대</p><ul><li>교육 분야</li><li>전광판(QR 대체)</li></ul><p>FlyWeb Project</p><p>웹페이지가 서버를 구동하고 디바이스가 여기에 접속 가능</p><h3><span id="웹고속화">웹고속화</span></h3><h4><span id="ampaccelerated-mobile-pages는-어떻게-빠른-성능을-내는가">AMP(Accelerated Mobile Pages)는 어떻게 빠른 성능을 내는가?</span></h4><p>김태훈 - 네이버 <a href="http://facebook.com/groups/webfrontend" target="_blank" rel="noopener">http://facebook.com/groups/webfrontend</a></p><ul><li>구글 라이브러리다. amp.js 다른거 할필요없이 가이드를 따르면 된다.</li><li>인스턴스 로딩이 가능하다.</li><li>커스텀 엘리먼트 기반이다.</li><li>url + #development=1 를 사용하면 에러 뿜어준다.</li><li>amp.js는 외부 js를 허용하지 않는다.</li><li>AMP Cache - 구글이 CDN 으로 다 뿌려준다.</li><li>HTML &lt;=&gt; AMP-HTML 페어로 구성 또는 AMP-HTML 온리</li><li>슬랙등에 링크걸면 AMP로딩해준다.</li><li>amp 컴포넌트를 사용해서 리소스를 로딩하게되면 뷰포트에 보이는 시점에 레이지로딩한다.</li><li>크로스 브라우징 해결해준다.</li><li>속도는 엄청 좋다는 말로 부족하다.</li><li>https만 가능하다(video)</li><li>커스텀 js를 사용하지 못하는 치명적인 단점이있어서 이벤트 페이지 같은 경우에 적합할 것으로 보임.</li></ul><p>특징</p><ul><li>비동기 스크립트만 로딩 허용</li><li>모든 리소스의 사이즈 지정</li><li>확장 컴포넌트들이 렌더링 차단 없이 실행한다.</li><li>써드 파티 자바스크립트 크리티컬 패스에서 제거</li><li>?(CSS관련)</li><li>웹폰트 효율적으로 허용</li><li>GPU 가속 애니메이션으로만 제한됨(레이아웃 변경 CSS는 막힌다)<strong>(css triggers 참조)</strong></li><li>리소스 로딩 순서 제어(뷰포트에 의해)</li><li>페이지 즉시 로드</li><li>리플로우 최적화</li><li>스타일 변경 작업을 배치작업을 통해서 최적화한다(코드 붙여서 작성하면됌)</li></ul><p>6억+ 페이지가 700k+ 사이트가 작성되었다.</p><p>커스텀 엘리먼트를 사용해서 라이프 사이클을 제어한다(이를 통해 뷰포트안에 있을때만 로딩등 처리)</p><h4><span id="프로그레시브-웹앱pwa">프로그레시브 웹앱(PWA)</span></h4><p>송정기 - 삼성전자</p><p>모바일 웹사이트</p><p>장점</p><ul><li>URL, 연결성, 빠른 배포(URL &gt; store)</li><li>표준 기반 다양한, 폭넓은 기기 지원</li></ul><p>단점</p><ul><li>Native 대비 떨어지는 UX</li><li>성능</li><li>기능</li></ul><hr><p>Manifest + Service Worker + Push</p><hr><p><a href="https://whatwebcando.today" target="_blank" rel="noopener">https://whatwebcando.today</a></p><p>PWA - 홈스크린 인스톨레이션, 오프라인 모드, 푸시 메시지</p><ul><li>머무는 시간이 3배 증가</li><li>40% 더 재접속</li><li>70% 홈스크린을 통해 들어오는 유저가 구매할 확률이 더 높다</li><li>3X 데이터를 덜 사용한다</li></ul><p>PWA List 앱 참조</p><p>PWA를 구성하는 표준 기술</p><h5><span id="web-app-manifest">Web App Manifest</span></h5><p>네이티브와 동일한 앱 접근성을 제공한다. 크롬, 오페라, 삼성 브라우저, 사파리<br>메니페스트가 추가됏을때는 브라우저에서 탭했을때 메뉴가 다르게 뜬다.<br>홈화면에 인스톨레이션을 지원하는 로직은 아직 사파리가 지원하지 않는다. 인스톨레이션 팝업은 브라우저별 휴리스틱 알고리즘을 통해 제공된다.</p><p><a href="http://pwa.rocks" target="_blank" rel="noopener">http://pwa.rocks</a></p><p>PWA indication의 조건</p><ul><li>https://</li><li>Service worker</li><li>WebApp Manifest</li></ul><p><code>theme_color</code>를 통해 상태바 색도 바꿀 수 있다.<br><code>display</code>를 통해 풀사이즈 앱으로 띄울 수 있다.</p><p>Splash screen - 크롬이 들고나오고 삼성 인터넷도 탑재 예정, 로딩 전 앱 로딩 화면처럼 만들어준다.</p><h5><span id="service-worker">Service Worker</span></h5><p>오프라인 우선, 백그라운드 처리</p><p>이벤트마다 워커가 종료된다. 웹 워커와는 다르다. 실 브라우저 구현(크로미움 기준) 2-30초는 살아있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> navigator.serviceWorker;</span><br><span class="line">sw.register(scriptURL, &#123;<span class="attr">scope</span>: scopeURL&#125;);</span><br><span class="line">;;</span><br><span class="line">oninstall = <span class="function"><span class="params">e</span> =&gt;</span> &#123; <span class="comment">/* pre-cache here */</span> &#125;;</span><br><span class="line">onfetch = <span class="function"><span class="params">e</span> =&gt;</span> &#123; <span class="comment">/* respond with magic */</span> &#125;;</span><br><span class="line">onactivate = <span class="function"><span class="params">e</span> =&gt;</span> &#123; <span class="comment">/* Deleting cache is on you * &#125;; // 서비스 워커 버전이 변경됐을때</span></span><br><span class="line"><span class="comment">registration.update(); // 강제 업데이트</span></span><br></pre></td></tr></table></figure><p>SW의 이벤트가 가지고 있는 <code>watUntil</code> 메서드를 통해 SW가 죽는 것을 방지할 수 있다.<br>캐시에 애드하는 형식 캐시에 매칭되지 않으면 거기서 <code>fetch</code>한다.</p><p>Service Worekr Cookbook 찾아볼 것 <a href="https://jakearchibald.com" target="_blank" rel="noopener">https://jakearchibald.com</a></p><h5><span id="push-api">Push API</span></h5><p>푸시의 효과는 검증됨.</p><p>필수요소</p><ul><li>Background Service <strong>(Service Worker)</strong></li><li>Push 등록/해지/이벤트 <strong>(Push API)</strong></li></ul><p><code>push</code>이벤트를 받아서 캐싱에 저장하고 노티피케이션을 띄움 띄운 후에는 클릭 이벤트를 받아 그에 따른 처리.</p><p><a href="https://medium.com/samsung-internet-dev" target="_blank" rel="noopener">https://medium.com/samsung-internet-dev</a></p><p>삼성 인터넷 베타 프로그램 신청 <a href="https://goo.gl/1yFP1L" target="_blank" rel="noopener">https://goo.gl/1yFP1L</a></p><h3><span id="web-엔진">Web 엔진</span></h3><h4><span id="naver-webkit-sling-project-소개-및-오픈소스">Naver Webkit - Sling Project 소개 및 오픈소스</span></h4><p>김준걸 - 네이버 랩스</p><ul><li>슬링 4년 6개월 작업했고 오늘 깃헙에 오픈했다.</li><li>애플의 웹킷에서 fork</li><li>win/android 지원</li><li>JS엔진 - JSC vs V8(과할 수록 유리 V8, 실사용에선 JSC, 슬링은 JSC)</li><li>리소스가 부족해서 안드로이드로 개발 =&gt; 스크립팅 =&gt; C++ 소스 제네레이팅(android pp, github 참조)</li><li>크로미움 네트워크 성능이 뛰어남</li><li>GFX Tool for Sling 이라는 디버깅 툴 만들어서 그걸로 선검증 후포팅</li><li>WebExtensions API가 400개 정도 되서 아직 다 지원은 못함</li><li></li></ul><h4><span id="chrome-dev-summit-2016-참관기">Chrome Dev Summit 2016 참관기</span></h4><p>김지한 - 네이버 랩스</p><ul><li>PWA 포커싱</li><li>AMP to PWA</li><li>매 단계마다 20%의 사용자가 떨어져나간다.(설치나, 가입 등등 모두)</li><li>3G 기준으로 5초 이내에 인터렉션이 가능해야한다.</li><li>홈 화면에 추가된 사이트는 4배 더 많이 방문한다(알리바바, 2016)</li></ul><p>PRPL pattern - Push, render, Pre-cache, Lazy-load</p><p><code>&lt;link rel=&quot;preload&quot;/&gt;</code></p><p>크롬 51+, 오페라 41+, 안드로이드 5+</p><p><a href="https://www.flipkart.com" target="_blank" rel="noopener">https://www.flipkart.com</a> PWA의 정석<br><a href="https://www.housing.com" target="_blank" rel="noopener">https://www.housing.com</a> 부동산 체크</p><h5><span id="crediential-api">Crediential API</span></h5><p><code>navigator.credentials</code> 인증을 브라우저에 던진다.</p><h5><span id="web-payment-api">Web Payment API</span></h5><p>브라우저에 결재 던짐</p><h5><span id="debugging-the-web">Debugging the Web</span></h5><ul><li>크롬개발자도구</li><li>Lighthouse 익스텐션(PWA)</li></ul><h5><span id="결론">결론</span></h5><ul><li>PWA의 핵심 - 오프라인 지원, 로딩 성능 향상</li><li>Lyft등 선행 사업자들도 이머징 마켓 중심으로 적용 중</li><li>로그인, 결재 등이 브라우저로 이동(크롬, 안드로이드), 이에 대한 강력한 지원</li></ul><h4><span id="html5기반-웹앱-그리고-다가올-http-2">HTML5기반 웹앱 그리고 다가올 HTTP / 2</span></h4><p>커넥션 제약으로 이미지 등을 로딩할때</p><ul><li>image sprite</li><li>local cache<code>&lt;link rel=&quot;prefetch&quot; href=&quot;image.png&quot;/&gt;</code></li><li>domain lookup, <code>x-dns-prefetch-control</code>, <code>preconnect</code></li><li>minify</li><li><code>prerender</code></li><li><code>preresolve</code></li><li>google에서 instant page 검색</li></ul><h5><span id="http2">HTTP2</span></h5><ul><li>바이너리 기반 프로토콜</li><li>헤더 압축</li><li>멀티플렉스 스트림(프로세스, 쓰레드 같은 개념)</li><li>스트림 프라이어티티(리소스 의존성 지정가능)</li><li>서버 푸쉬</li></ul><p>1.1 에선 핑퐁 치던걸 2에선 한방에 내림</p><p>APM<a href="https://ampproject.org" target="_blank" rel="noopener">https://ampproject.org</a> + PWA</p><p>포커싱이 HTTP2가 아니라 아쉬움</p>]]></content>
    
    <summary type="html">
    
      W3C HTML 5 컨퍼런스 2016 요약
    
    </summary>
    
      <category term="summary" scheme="http://blog.bglee.me/categories/summary/"/>
    
    
      <category term="pwa" scheme="http://blog.bglee.me/tags/pwa/"/>
    
      <category term="amp" scheme="http://blog.bglee.me/tags/amp/"/>
    
  </entry>
  
  <entry>
    <title>2016년 12월</title>
    <link href="http://blog.bglee.me/posts/2016/2016-12/"/>
    <id>http://blog.bglee.me/posts/2016/2016-12/</id>
    <published>2016-12-04T10:58:37.000Z</published>
    <updated>2018-03-29T06:03:19.620Z</updated>
    
    <content type="html"><![CDATA[<p>벌써 12월이다. 미션들이 여러개가 떨어져서 이래저래 공부와 삽질을 하면서 11월 한달을 보냈다. 한달에 한번 포스팅할 시간도 없어서 정리를 하고간다.</p><h2><span id="독서">독서</span></h2><ul><li>클로저 시작하기 - 기본 개념과 7주 훈련 프로그램</li><li>빠른 모바일 앱 개발을 위한 React Native</li><li>디스커버리 Go</li></ul><p>예전에는 정독을 목표로 책을 펴고 <strong>서문</strong>부터 읽어나갔었는데 출퇴근 시간을 아껴서 공부하다보니 실무에 쓰일 수 있는 부분을 먼저 읽기위해 <strong>목차</strong>를 읽고 고급 내용을 다루는 뒷 부분을 나중에 읽게 되었다.</p><p>11월 중순 부로 서버까지 커버해야하는 상황이 오면서 회사에서 쓰이는 언어인 클로저(이전에도 한번 읽긴 했었다.)와 <strong>Go</strong>를 공부해야하는 상황인데 기존에 인계 받은 것 중에는 <strong>루비 온 레일즈</strong>도 존재한다.</p><h2><span id="블로그">블로그</span></h2><p>서브 도메인을 구현했다. 이제까지 블로그가 집에서 굴리는 작은 서버를 통해 서비스되고 있었는데 이를 나스로 옮겨 잘 사용하고 있었는데 조카들이 와서 전원을 뽑아 놓는 바람에 이틀 정도 서비스가 중단되는 것을 계기로 깃헙 페이지를 통해 서비스를 제공하면서 도메인도 <strong><a href="http://blog.bglee.me">http://blog.bglee.me</a></strong>로 옮겼다.</p><h2><span id="next">Next</span></h2><p>공부에 치이는 상황에서 주어진 시간을 최대한 활용하고 추후의 빠른 개발 및 데브옵스를 위해서 기존 API 서버의 <strong>GraphQL</strong> 프록시를 도전하기도 했고 앱에 대한 니즈 또한 존재해 리액트 네이티브를 공부했다. 시간이 얼마 없기 때문에 <strong>GraphQL</strong>은 드랍했고 메인 프로젝트의 일정을 맞추기 위해 주니어들과 함께 다시 <strong>FrontEnd</strong> 코드를 작성중에 있다.</p><p>웹 서빙을 위해 EC2, ECS, S3 static hosting 여러가지를 해왔는데 각각의 장단점이 있고 Serverless 스택 또한 러닝커브가 있지만 한번 구현이 완료되면 안정성과 비용 절감이 이루어지는 만큼 이 부분이 다음 타겟이 될 것 같다. 첫 시도는 주어진 시간의 한계로 친구에게 맡긴 상황인데 이 부분이 잘 해결되었으면 한다.<br>ㅏ</p>]]></content>
    
    <summary type="html">
    
      벌써 12월이다. 미션들이 여러개가 떨어져서 이래저래 공부와 삽질을 하면서 11월 한달을 보냈다. 한달에 한번 포스팅할 시간도 없어서 정리를 하고간다.
    
    </summary>
    
      <category term="summary" scheme="http://blog.bglee.me/categories/summary/"/>
    
    
  </entry>
  
  <entry>
    <title>AWS EC2 Container Service(ECS)를 통한 배포</title>
    <link href="http://blog.bglee.me/posts/2016/aws-ec2-container/"/>
    <id>http://blog.bglee.me/posts/2016/aws-ec2-container/</id>
    <published>2016-11-05T06:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>ecs</code> 는 현재 서울 리전에서는 지원되고 있지 않다. 글을 쓰다가 개인 업무가 있어서 끊어 쓰다보니 매끄럽지가 않은데 질문사항이나 잘못된 점이 있으면 피드백 주세요.</p></blockquote><p><img src="https://lh3.googleusercontent.com/KLmTMdEkWSEkTDl9l8oe840Cxd8Siu4MG4qJJ9Z6emVjRhsH3_uC9WPhstkLq_q5qoRiFv20Ws_VSx7c0bsO1FfG8lfV8OSDEcQWHCLf4ZB5aOtRai4BmLmDJPEA1hVadtsyBVxJRzomTv-J-svCzFpyX1_jBwSdmi_FUCj31iJKNM0WsZc4nxkBHYz_2oBD2vbCa-HzAhcsDwgt61VzKRTyQHH0W9_ygKllbofMhHa6_x4hTwkmVW_MgGunvS2EULiJfnscxlW-QveQ9EGGWjx__xHBk_QhXYdbbPhf5U4rZw3nkejvTa12BfgnsvB9ROWvL3nFCO_NtKoAabNCVJ5cpZrHokxy7Aul02nTHcyXIjRpwuEaZd4Us3rQ2y_rL5sWEtE70FQCBmM_iYwfKTsTdPg_fkQkGO4nj5Idbe-RcCQ0oOsGcw1f67VTwsowi-S9T999WFdSSHsg3Y1jwrZ1JLnHkTZWwwRO0QEAjLAW1g3NsH3DPKuH6qdG3i269fauB-rsdqsqoB4s7VKaTN-JcuqRdqwuZAcBG1zYimIhFdVe7Qvobn8mwDbTo-InwPUM_qSClu6SRTYnTgGMDyhmsijwYHmePk1q8M5RM7RZlBLW5w=s803-no" alt=""></p><h2><span id="개요">개요</span></h2><p><code>aws console</code> 을 통해 <code>EC2 Container Service</code>(ecs) 에 진입하면 3개의 메뉴가 보인다.</p><ul><li>Cluster</li><li>Task Definitions</li><li>Repositories</li></ul><blockquote><p>Cluster</p></blockquote><p>하드웨어 클러스터를 의미한다. EC2의 모임이라고 생각하면 편하다.</p><blockquote><p>Task Definitions</p></blockquote><p>이 곳에서 Docker 파일을 통해 <code>task</code> 를 정의한다. 정의한 <code>task</code>를 <code>cluster</code>에 할당하여 동작시킨다고 생각하면된다. <code>task</code> 에서는 <code>메모리를 얼마나 사용할 것인가?</code> 등의 <code>docker</code> 설정을 포함한다.</p><blockquote><p>Repository</p></blockquote><p><code>aws</code> 에서 사용할 수 있는 <code>docker hub</code> 라고 이해하면 빠르다. 이 곳에 빌드된 <code>docker image</code> 를 올린다.</p><h2><span id="실제-구성">실제 구성</span></h2><h3><span id="저장소-구성-및-업로드">저장소 구성 및 업로드</span></h3><h5><span id="docker-image-build">docker image build</span></h5><p>먼저 어플리케이션을 구현하고 <code>Dockerfile</code>을 통해 이미지로 빌드한다(빌드 과정은 이 포스트의 영역을 넘어간다).</p><h5><span id="docker-저장소-생성">docker 저장소 생성</span></h5><p>빌드 된 이미지를 <code>ecs repository</code> 에 업로드하기 위해서 <code>ecs</code> 서비스의 <code>repository</code> 에 진입하여 <code>Create repository</code> 버튼으로 저장소를 생성한다.</p><h5><span id="docker-image-upload">docker image upload</span></h5><p>친절하게 <code>ecs</code>에서 <code>repository</code> 를 선택하면 <code>View Push Commands</code> 라는 버튼을 통해 업로드 방법을 볼 수 있다. <code>login</code>, <code>build</code>, <code>tag</code>, <code>push(upload)</code> 순으로 명령어가 적혀있는데 저장소 url, region을 자신에 맞게 수정하고 올리면된다.</p><h3><span id="task-definitions">task definitions</span></h3><h5><span id="task-생성">task 생성</span></h5><p><code>Task Definitions</code> 메뉴에서 <code>Create a Task Definition</code> 버튼을 눌러 생성한다. <code>Container Definitions</code> 에서 <code>Add container</code> 버튼을 통해 컨테이너를 등록해야하는데, <code>image</code> 에서는 프로토콜(<code>http://</code>)을 제외한 이미지 경로를 넣어준다.</p><p>메모리의 경우는 <code>task</code> 가 실행될 실제 컨테이너의 메모리 안에서 설정하면된다. 실제 사용하는 메모리보다 적게 잡을 경우 속도저하, <strong>응답없음</strong> 등을 경험할 수 있다. 실제로 PDF를 생성하는 서버를 구현했다가 랜더링 할 메모리가 모자라 응답없음을 경험했었다.</p><p>추가적으로 포트 매핑, CPU unit 등을 설정해준다.</p><h3><span id="cluster-에-배포">cluster 에 배포</span></h3><h5><span id="cluster-생성">cluster 생성</span></h5><h5><span id="service-생성">service 생성</span></h5><p>클러스터를 생성하고 나서 클러스터에 제공할 서비스를 생성한다. 여기서는 위에서 정의한 <code>task</code> 와 이를 서비스할 <code>cluster</code> 를 지정하고 몇개의 <code>task</code>를 돌릴 것인지 등을 셋업한다. 추가적으로 <code>ELB</code>, <code>auto scaling</code>등도 셋업을 한다.</p><p><strong>ELB</strong> 최근에 <strong>Application Load Balandcer</strong> 가 추가 되면서 기본설값이 되어 있다. 기존에 쓰이던 ELB는 <strong>Classic Load Balancer</strong> 니 참고 바란다.</p><hr><p>여기 까지는 그냥 따라오면 되는데 중요한 문제가 있다. <strong>cluster</strong> 에 등록된 컨테이너 인스턴스가 없다. 이제 이를 세팅해야한다. cluster에 ec2 instance를 등록하기 위해서는 <code>ecs agent</code>가 설치된 이미지가 로드되야한다. 이건 유저가 스스로 설치할 수도 있지만 기본적으로 아마존에서 제공하는 이미지가 있다.</p><p>테스트를 위해 <strong>ec2 instance</strong> 를 생성한다. <strong>AMI</strong>는 <strong>Amazon ECS-Optimized Amazon Linux AMI</strong> 를 이용한다.</p><p><strong>auto scaling group</strong>, <strong>launch configuration</strong> 을 통해 서비스를 하는게 정석이다.</p><p>여기서 <strong>user data</strong> 를 설정해서 인스턴스가 ecs에 접속해서 클러스터에 등록을 할 수 있도록 설정해 줘야한다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> ECS_CLUSTER=CLUSTER_NAME &gt;&gt; /etc/ecs/ecs.config</span><br></pre></td></tr></table></figure><p>user 데이터의 내용은 위와 같다.</p><p>여기서 <strong>CLUSTER_NAME</strong> 부분을 통해 인스턴스가 로딩되면서 ecs agent가 실행되게되고 여기서 ecs 에 접속하여 cluster에 등록되게 된다.</p><hr><h3><span id="update-revision">update revision</span></h3><p>docker image가 업데이트 되어 재 배포가 필요한 경우에는 task의 new revision을 선택하고 container를 눌러서 한번 업데이트를 누른다(현재 컨테이너가 같은 docker이름을 참조하더라도 재 참조를 하도록) 리비전이 생성되면 생성된 task를 서비스에 업데이트하게 되면 현재 구동되고 있는 task가 active로 업데이트된 task가 primary로 등록되며 시간이 조금 지나면 active가 내려가고 primary가 active되면서 서비스가 이어지게 된다.</p><h2><span id="trouble-shotting">trouble shotting</span></h2><p>###* cat /etc/ecs/ecs.config</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could not register module=&quot;api client&quot; err=&quot;ClientException: Cluster not found.</span><br></pre></td></tr></table></figure><ul><li><code>/etc/ecs/ecs.config</code> 에 cluster 이름이 정확히 올라가 있는지 2번 확인한다.</li><li>그래도 안되면 ecs agent api call이 public ip를 요구하므로 public ip가 있어야한다.(또는 프록시 등의 다른 방법) ec2를 확인한다.</li></ul>]]></content>
    
    <summary type="html">
    
      aws ec2 container service 를 통해 서비스를 배포하자.
    
    </summary>
    
    
      <category term="ecs" scheme="http://blog.bglee.me/tags/ecs/"/>
    
      <category term="ecs_cluster" scheme="http://blog.bglee.me/tags/ecs-cluster/"/>
    
      <category term="ecs.config" scheme="http://blog.bglee.me/tags/ecs-config/"/>
    
      <category term="aws" scheme="http://blog.bglee.me/tags/aws/"/>
    
      <category term="ec2" scheme="http://blog.bglee.me/tags/ec2/"/>
    
      <category term="ec2 container" scheme="http://blog.bglee.me/tags/ec2-container/"/>
    
  </entry>
  
  <entry>
    <title>deview-2016</title>
    <link href="http://blog.bglee.me/posts/2016/deview-2016/"/>
    <id>http://blog.bglee.me/posts/2016/deview-2016/</id>
    <published>2016-10-23T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.624Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="deview-2016">Deview 2016</span></h1><p><img src="https://lh3.googleusercontent.com/o5PfgOsLJtkIDI1hRbb89DS8Os9SG_IJer64JvJfJyyS6zYuI_j0bTb2TPolXO2cYhL4gL9IZwc=w2145-h1343-no" alt=""></p><h2><span id="cto">CTO</span></h2><h3><span id="keynote">keynote</span></h3><p>회사에서 프론트엔드 개발차 지원해준 기회기 때문에 FE로 스케줄을 잡았는데 키노트를 들으니.. 로봇과 음성인식 세션이 궁금했지만 계획대로 진행하기로했다.</p><p>네이버 랩스는 무인 주행, 음성 인식(자연어), 로봇에 집중하고 있는 것으로 보인다. 무인 주행 자체에 집중하기 보다는 시각데이터를 파싱하는 목적이 큰 것으로 보였다.</p><p>M1(?) 이라는 네이버 랩스 로봇 영상이 보여졌는데 돌아다니면서 영상을 찍는데(머리가 카메라로 무장) 단순이 동영상을 찍는게 아니라 걸 돌아다니면 녹화했던 영상 데이터를 다시 보여줄 때는 걸려있던 액자들의 내용을 바꿔서 보여줬다. 3D 맵 데이터로 파싱해서 데이터화 하고 있는 것으로 보였다.</p><h3><span id="d2">D2</span></h3><h4><span id="naver-open-source">Naver Open Source</span></h4><p>2016년 4개를 공개함 <a href="https://github.com/naver.com" target="_blank" rel="noopener">https://github.com/naver.com</a></p><ul><li>pinpoint star: 2300</li></ul><p>나눔 고딕 폰트가 금일 업데이트 되었다.</p><p>지도 API는 일일 20만 콜이 가능하다.</p><h4><span id="d2-startup-factory">D2 Startup Factory</span></h4><p>스타트업 지원</p><h4><span id="papago">papago</span></h4><p>한국, 일본, 영어, 중국어 지원</p><h4><span id="whale">Whale</span></h4><p>네이버의 Chromium 기반 브라우저다. 12월 런칭 예정이다 [공식 홈페이지]<a href="https://whale.google.com" target="_blank" rel="noopener">https://whale.google.com</a></p><ul><li>네이버 브라우저 스플릿창 지원</li><li>글자 선택만으로 검색</li><li>스마트 팝업(구석에 나옴)</li><li>이미지 번역</li><li>악성코드 제어</li><li>파파고 기술이 들어가있음</li></ul><p>12월 발표</p><h4><span id="blue">BLUE</span></h4><p>생활 환경 지능(Ambient Intelligence) - 사용자가 요구하지 않아도 상황을 인식하고 추천하는 것</p><ul><li>understand - 이해하는 것</li><li>anticipatory - 답/정보/action을 예상 추천</li><li>natural UX 음성, gesture등</li></ul><h5><span id="amica">AMICA</span></h5><blockquote><p>AMI Connected All</p></blockquote><p>영상이 소개되었는데 아이템은 팔찌로 보이고 차 내에서 또 자기전에 말을 하는데 음성인식관련으로 siri와 매우 유사했다.</p><p><a href="https://amica.ai" target="_blank" rel="noopener">https://amica.ai</a></p><p><code>자연어 처리는 음성에만 국한된 것이 아닌 채팅에서도 사용이 가능하다.</code>는 것을 기억해야할 듯</p><p>AMICA는 11/7 까지 클로즈 베타 신청 받음(막상 들어가보니 11/6일)</p><p>Samsung ARTIK 으로(Intel Edison류의 보드인 것으로 보임) 포팅되어있어 사용이 가능하다.</p><h4><span id="자율주행">자율주행</span></h4><p>미국(?)의 기준인 NHTSA level 3 수준이다.</p><h4><span id="naver-labs-m1">NAVER LABS M1</span></h4><p>Indoor mapping robot</p><ul><li>공간 인식 및 정보화, 3D 실내지도</li></ul><p>이미지 인식기술은 인공지능 기술과 합성되면 사람의 눈과 같은 역할을 하게될 것으로 보여졌다.(카메라니 당연히 눈이지만 시각정보를 인간과 같이 파싱하는 느낌)</p><h2><span id="session01web-payment-api의-현재와-미래">Session#01(Web Payment API의 현재와 미래)</span></h2><p>2015-10 에 표준화 작업이 시작됨</p><h3><span id="motivation">Motivation</span></h3><p>68%는 카트에 담고 결재하지 않음, 데스크탑 보다 모바일에서 그보다 나가는 비율이 66% 더 됨</p><ul><li>폼이 너무 복잡하다</li><li>계정생성 귀찮음</li><li>모바일 디자인이 구림</li><li>로딩 속도</li></ul><h3><span id="web-payment-with-basic-cards">Web Payment with Basic Cards</span></h3><p>크롬 53(4?)에서부터 지원한다.</p><p>구성</p><ul><li>Payment Request API,</li><li>Payment Method Identifiers</li><li>Basic Card Payment</li></ul><p>복잡한 form으로 처리 되는 것을 <strong>one button</strong> 으로 처리한다.</p><p>브라우저가 가지고 있다. 판매자가 수용하는 payment request를 날리면 카드 리스트만 리스트업 됨</p><h4><span id="benefit">benefit</span></h4><h5><span id="user">user</span></h5><ul><li>쇼핑몰에 관계없이 같은 ux제공</li><li>처음 이용 쇼핑몰에서도 저장된 신용카드를 이용가능</li></ul><h5><span id="merchant">merchant</span></h5><ul><li>결재 ux개발안해도됌</li><li>보안이슈 및 서버 운용비용 절감</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> methodData = [&#123;</span><br><span class="line">supportedMethods: [<span class="string">'visa'</span>, <span class="string">'master'</span>],</span><br><span class="line">&#125;, &#123;</span><br><span class="line">supportedMethods: [<span class="string">'sampay'</span>],</span><br><span class="line">data: &#123;</span><br><span class="line">merchantID: <span class="string">'12345'</span>,</span><br><span class="line">...</span><br><span class="line">&#125;]</span><br><span class="line"><span class="keyword">var</span> pr = <span class="keyword">new</span> PaymentRequest(methodData, details, options);</span><br></pre></td></tr></table></figure><p>shippingOptions: 배송정보<br>paymentOptions: 어떤 정보를 입력받고 받지 않을지 결정</p><p>프로미스 기반</p><p>언급된 이벤트</p><ul><li>shipping address change event</li><li>shipping options change event</li></ul><p>지원하지 않는 지역이나 옵션이 올 경우에 대한 처리를 이벤트를 받아 처리할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.updateWith(<span class="comment">//이벤트 업데이트</span></span><br></pre></td></tr></table></figure><p>결재를 판매자측 서비스에서 처리하는데 개발 부하가 걸린다</p><p>앞으로 미래는 payment app을 사용한 결재가 있다.</p><h3><span id="web-payment-with-payment-apps">Web Payment with Payment Apps</span></h3><blockquote><p>SamsungPay, AliPay 등을 통해</p></blockquote><p>신용카드 뿐만 아니라 결재 앱을 카드처럼 지원한다.</p><p>페이먼트 앱</p><ul><li>웹 기반(현재 포커스 되어있음 w3c)</li><li>네이티브 기반(완전히 정의되지 않음) =&gt; 네이티브를 트리거하는 방식으로 진행 될 예정(지금이랑 같지 않은가?)</li></ul><h4><span id="service-worker">service worker</span></h4><ul><li>브라우저가 죽어도 살아있다.</li><li>브라우저에 설치되게 되며 필요한경우(푸시 알람) 이벤트를 수신받은 브라우저에 의해 활성화된다.</li><li>지정된 origin 및 scope에서만 동작하며, Secure Context에서 실행됨을 보장.</li></ul><p>payment app &lt;&gt; service worker 는 1:1 관계다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.serviceWorker.register(<span class="string">'/tree_pay.js'</span>).then(</span><br></pre></td></tr></table></figure><h2><span id="session02graphql">Session#02(GraphQL)</span></h2><p>기존</p><ul><li>rest<ul><li>필드제한 한계</li><li>필터 문제</li><li>문서 문제</li><li>동기화 문제</li></ul></li><li>json:api</li></ul><h3><span id="graphql">GraphQL</span></h3><ul><li>query</li><li>mutation</li></ul><p>object type을 가지고 schema를 정의</p><p>object</p><pre><code>* type(required): name* args: 인자* resolve: return function</code></pre><p>rest: postman / graphql: GraphiQL(chrome extension)</p><h3><span id="relay">Relay</span></h3><p>React와 GraphQL을 엮는다.</p><blockquote><p>Node</p></blockquote><p>Resource에 대한 단일 interface</p><blockquote><p>Connection(페이지네이션 특화)</p></blockquote><p>Node를 여러개 가져온다</p><blockquote><p>React Relay</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">React.createContainer(COMPONENT_NAME, &#123;</span><br><span class="line">fragments: &#123;</span><br><span class="line">editor(props의 이름: <span class="function"><span class="params">()</span> =&gt;</span> Relay.QL<span class="string">`</span></span><br><span class="line"><span class="string">fragment on User &#123;</span></span><br><span class="line"><span class="string">pictureURL</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;EditorInfo.getFragment</span></span></span><br></pre></td></tr></table></figure><blockquote><p>Mutation Config</p></blockquote><hr><p>query(node, connections),<br>변경(mutation)</p><p>참고 <a href="http://learngraphql.com" target="_blank" rel="noopener">http://learngraphql.com</a></p><p>검색해 볼 것</p><ul><li>nosyncdb</li><li>lukka</li><li>awesome graphql</li></ul><p>Q&amp;A 시간에 질의 응답을 볼때 Relay와 Redux는 함께 사용하기 껄끄러운(베스트 프렉티스가 없는) 상황으로 보여지며 기존 Redux 사용시의 전략인 외각 오브젝트에서 데이터 로직을 처리하고 나머지를 퓨어 컴포넌트로 가져가는 방식이 아닌 서버쪽 데이터를 활용하는 대부분의 컴포넌트가 Relay로 바인딩 되게 된다.</p><p>Redux, Relay 모두 Flux 아키텍쳐의 영향을 받았으므로 개인적으로는 Store가 로컬에 있느냐 리포트에 있냐를 차이로 보고 있지만 컴포넌트가 데이터와 강하게 커플링되는 것에 대한 거부감이 있는 것이 사실이다. 실제 적용을 해보면서 답을 찾아야할 부분으로 보인다.</p><h2><span id="session03electron">Session#03(Electron)</span></h2><p>검색시에는 <code>github eletron</code>으로 검색해야 한다.</p><p>slack과 microsoft가 샘플이 됨(Document에도 존재하지 않는 것들이 쓰이니 볼 것)<br>electron은 소스가 다 보인다. 로직을 백엔드로 빼서 구현했다고 말하고 있다.</p><p>로직을 백엔드로 빼면서 Command 패턴을 사용했는데 로직이 백엔드로간 이유는 보안상의 이유라고 한다.(여기서의 백엔드는 <strong>local</strong>에서 node server를 돌린다는 이야기다.</p><p>Devtron 이라는 크롬 익스텐션이 존재하는 이를 개발 환경에서 이용할 수 있다.</p><p>node 바이너리 솔루션</p><ul><li>enclosejs: 플랫폼에 맞춘 바이너리화</li></ul><p>eletron-builder</p><p>개인적으로 인상적인 세션은 아니었고 개발 방법론, 패턴등을 설명했음에도 30분내에 발표가 마무리되었다.</p><h2><span id="session04한-달-만에-개발한-하이브리드-앱-50만-사용자-서비스가-되기까지">Session#04(한 달 만에 개발한 하이브리드 앱, 50만 사용자 서비스가 되기까지)</span></h2><h3><span id="해먹남녀">해먹남녀</span></h3><p>하이브리드가 넘어야할 장애물</p><ul><li>view 전환 효과</li><li>300ms의 지연이 존재(웹뷰) - single tab, double tab을 잡기 위해 존재<ul><li>hammer.js, fastclick.js가 있음</li></ul></li><li>transition<ul><li>3d translate css 이용</li></ul></li><li>push<ul><li>cordova 등</li></ul></li></ul><p>백수시절 6개월동안 7개의 앱을 만듬(평균 2주)</p><p>해먹남녀는 IonicFramework을 이용해서 제작했다. 1달만에 웹뷰를 이용한 하이브리드앱을 제작했으나 2달의 안정화 작업을 거쳤다.</p><p>1주차</p><p>comonent부터 ui를 만듬<br>문제는 라우팅으로는 위계 제어가 힘들다.</p><p>2주차</p><p>어려운 문제들을 해결하기 시작</p><ul><li>sync</li><li>플러그인 업데이트 종속성</li><li>다중업로드</li><li>보안정책(애플)</li></ul><p>3주차</p><p>성능</p><ul><li>데이터 프리패치</li><li>터치 컨트롤 통제<ul><li>스크롤시 터치를 받지 않는 등으로 속도 향상</li></ul></li><li>이미지 리사이징</li><li>css blur처리가 속도가 느려서 40px짜리를 up scaling해서 속도를 향상 시킴</li></ul><p>4주차</p><ul><li>png 처리 투명</li></ul><h3><span id="voc-사용자-피드백-대응">VOC 사용자 피드백 대응</span></h3><p><a href="https://microsoft.github.io/code-push" target="_blank" rel="noopener">https://microsoft.github.io/code-push</a></p><p>클라우드에서 버전이 바뀌면 파일을 보내줌 급할때만 씀</p><h3><span id="cordova핵시configxml-프로젝트-설정-파일">cordova핵시config.xml 프로젝트 설정 파일</span></h3><p>버전관리, hook script 테스크 자동화, info, plist 자동 작성</p><h3><span id="세션-발표자의-회고">세션 발표자의 회고</span></h3><p>하이브리드 앱과 네이티브 앱 사이에는 넘을 수 없는 성능(트랜지션 등을 말하는 듯) 차이가 존재하나 하이브리드 앱이 보여주는 수준 자체가 준수하기 때문에 문제가 없다.</p><p>하이브리드 앱이 네이티브를 대체한다기 보다는 빠른 Time To Market을 맞추기 적합하며 이를 활용한다는 전략적 차원으로 발표자는 설명했다.</p><p>하지만 React Native가 있다면 어떨가…</p><h2><span id="session055년간의-네이버-웹엔진-개발삽질기-그리고">Session#05(5년간의 네이버 웹엔진 개발/삽질기 그리고…)</span></h2><p>Naver Labs의 신규 브라우저 Whale의 개발에 대한 스토리다. 사실 이 세션은 고민이 많았다. 선택할 수 있는 세션이 4개 였는데 다음과 같았다.</p><ul><li>Clean Front-End Development</li><li>React로 개발자 2명이 플랫폼 4개를 서비스하는 이야기</li><li>우리 팀에서도 코드리뷰를 할 수 있을까?</li><li>5년간의 네이버 웹엔진 개발/삽질 그리고…</li></ul><p>원래는 첫번째 세션을 들을까 준비했는데 Single Page Application만 5년 이상을 진행했고(심지어 임베디드 웹 브라우저에서도…) 사실 이 정도의 기간이 SPA 역사기 때문에 나이가 어린 세션 발표자거나(실망 시킨 경우가 많았다) 뻔해 보이거나 답 없는 주제(React vs Angular)와 같은 주제를 피하고 <strong>다수</strong>의 개발자들이 시간과 노력을 들여 진행한 프로젝트 <strong>이야기</strong>가 듣고 싶어 이 세션을 선택했고 결과 적으로 성공적이었다.</p><p>브라우저 세션 답게 블락 다이어그램으로 스택을 소개하고 공감가는 삽질기를 들을 수 있었다. Q&amp;A 시간을 포함해서 45분인데 그중에 무려 30분을 Webkit 기반으로 진행한 프로젝트 연혁을 말하고 있었는데. 결론적으로는 Webkit을 버리고 Chromium 기반으로 만들었다고…</p><p>국내에 브라우저를 낼 수 있는 기업이 얼마나 있겠는가 기대를 걸어본다. 브라우저 같은 뿌리 기술은 가지고 있으면 시너지를 낼 것도 많고 파급력을 가지는 대신 그 만큼 출시 이후에 끌고가는 문제도 있는 아무쪼록 잘 되었으면 한다.</p><h3><span id="whale">Whale</span></h3><p>일단 feature가 실제 사용 패턴과 관련 된 것이 맘에 들었다 대단히 실질적으로 사용패턴을 분석을 한 것으로 보였다.</p><p>Over Tabber를 예로 들었는데(탭을 엄청나게 띄워 놓는 사람) 이유인 즉슨 이렇다는 거다.</p><ul><li>쇼핑몰에서 고르는데 인덱스 페이지 하나를 두고 상세 페이지를 들어갔다가 나왔다 하기 귀찮으니 여러개를 띄워둔다.</li><li>사내에서 보라고 링크 공유가 왔는데 아예 안보는 것은 매너가 아니니 일단 띄워놓고 하염없이 둔다.</li><li>구글에서 검색을 한뒤에 원하는 결과를 찾는데 이 때 도움이 될 것 같은 것은 일단 띄워둔다.</li></ul><p>실제로 나도 봐도 그렇기 때문에 깊이 공감을 했다. 그래서 Whale은 스플릿 뷰를 지원하고 쇼핑몰등에서 유용히 사용할 수 있도록 했다.</p><p>읽기 모드를 미려하게 지원하고</p><p>블락하면 궁금하고 블락하지 않자니 너무 떠대는 탭들을 스마트 탭뷰를 만들어서 정리해서 볼 수 있도록 구현했다.</p><p>크롬 익스텐션이 풀리 호환되며 자체 지원을 위한 것도 준비되어있다.</p><p>음성 검색(파파고?) 이 들어가있다.</p><p>퀵 서치기능이 들어가있어서 단순 드래그만으로 단어나 인물등을 검색할 수 있는데 단순 검색이 아닌 검색 기반의 회사인 만큼 컨텍스트 검색을 통해 연관성이 높은 결과 값을 받을 수 있다.</p><p>일단 기능이 마음에 든다. 고민의 흔적도 공감할 수 있어서 개인적으로는 <code>아 맞게 고민했구나? (내가 쓸 수 있게...)</code> 이런 느낌을 받았다.</p><p>12월 런치로 보인다. <a href="https://whale.naver.com" target="_blank" rel="noopener">https://whale.naver.com</a></p><hr><h2><span id="deview-2016에-대한-개인적인-감상">deview 2016에 대한 개인적인 감상</span></h2><p>회사 업무도 업무고 상당히 가기 귀찮았는데 잘 갔다왔다는 생각이 든다. 무료 세미나에 가면 제품 홍보 성격이 강하다거나 어린 세션 발표자(어리다고 뭐라 하는 것이 아니라.. 확률상)의 경우 준비 미숙으로 50분 세션을 10분만에 끝내버리는 경우도 많았는데 그 보다는 훨씬 나았고 주제 자체가 진보된 것이 많았다. 무료 했었는데 좀 의지를 태울 수 있었다.</p>]]></content>
    
    <summary type="html">
    
      Deview 2016 세미나 정리
    
    </summary>
    
      <category term="summary" scheme="http://blog.bglee.me/categories/summary/"/>
    
    
      <category term="deview2016" scheme="http://blog.bglee.me/tags/deview2016/"/>
    
      <category term="deview" scheme="http://blog.bglee.me/tags/deview/"/>
    
  </entry>
  
  <entry>
    <title>AWS API Gateway - Lambda - Travis-CI prototype 구현</title>
    <link href="http://blog.bglee.me/posts/2016/aws-gateway-lambda-ci/"/>
    <id>http://blog.bglee.me/posts/2016/aws-gateway-lambda-ci/</id>
    <published>2016-09-25T15:00:00.000Z</published>
    <updated>2018-03-29T06:03:19.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>aws serverless architecture</code> 의 핵심에 <code>api gateway</code> 와 <code>lambda</code> 가 있다. 두 서비스는 모드 서울 리전에서 사용이 가능하다. 이를 이용하여 프로토타입을 작성해 보자.</p></blockquote><h2><span id="architecture">architecture</span></h2><p><code>node</code>로 서버를 구성하는 것을 예로 들자면 아래와 같다.</p><table><thead><tr><th>node application</th><th>express-router</th><th>logic</th></tr></thead><tbody><tr><td>aws</td><td>api gateway</td><td>lambda</td></tr></tbody></table><p>aws에서 제공하는 아키텍쳐 예시를 보면 이해가 쉽다.</p><p><img src="https://awsblogskr.s3-ap-northeast-2.amazonaws.com/articles/2016-04-serverless/serverless-amazon-s3.png" alt="serverless architecture"></p><p><em><a href="https://api.example.com" target="_blank" rel="noopener">https://api.example.com</a></em> 부분을 통해 api gateway에 접근하면 라우팅을 통해 필요한 lambda함수를 콜하게 된다. 그리고 db 등에 데이터를 연산을 하고 다시 사용자에게 응답을 리턴한다.</p><p>이 포스트는 실무에 적용이 가능하도록 아래와 같은 내용을 담고있다.</p><ul><li>lambda 함수 생성</li><li>api gateway - lambda 함수 연결(parameter, header 설정)</li><li>development, production 모드를 분리하기 위한 stage 활용</li><li>travis ci를 통한 배포 자동화</li></ul><p>실제 구현 순서와는 상관없이 설명하기 편하게 상향식 접근 방법으로 작성한다.</p><h2><span id="lambda-함수-구현">lambda 함수 구현</span></h2><h3><span id="코드-구현-방식">코드 구현 방식</span></h3><p>lambda는 다음 3가지 방식으로 코드를 구현 할 수 있다.</p><ul><li>inline editing</li><li><strong>upload zip file</strong></li><li>upload from s3</li></ul><p>이 포스트는 배포 자동화까지가 목표이므로 2번째 안으로 진행한다.</p><h3><span id="구현-언어">구현 언어</span></h3><p><code>lambda</code>는 <code>java</code>, <code>python</code> 등 몇가지 언어를 지원하는데 이 포스트는 <code>nodejs</code> 4.3 버전을 기준으로 설명한다. nodejs 4.3은 <code>es2015</code>(a.k.a es6) 를 부분적으로 지원하는데 훌륭하진 않으며 다행이 <code>Promise</code>, <code>Set</code> 정도는 지원을 하고 있다.<br>이외에 코드 작성은 방식은 자유지만 컴파일 또한 비용이며 polyfill등을 이용하게 되는 경우 용량이 늘어나므로 추천하진 않는다.</p><h3><span id="lambda-함수-생성">lambda 함수 생성</span></h3><p>간단하면서도 lambda와 api gateway가 연결되면서 parameter들이 어떻게 전달되는지를 볼 수 있도록 코드를 작성한다. 배포하기 전 빠른 진행을 위해 aws에서 제공하는 <code>inline editor</code>를 사용해 바로 소스를 작성하도록 하자.</p><p><a href="https://console.aws.amazon.com" target="_blank" rel="noopener">aws console</a> 에서<code>lambda</code>를 선택해서 lambda 페이지에 진입한 후 왼쪽 사이드 바에서 <code>functions</code>를 누르고 <code>create a Lambda function</code>을 눌러 lambda 함수를 생성하도록 하자.</p><p><code>Select blueprint</code> 화면이 나오면서 template 들이 보여지는데 <code>skip</code> 버튼을 눌러 다음 스텝으로 간다.</p><p><code>configure triggers</code> 화면이 나오는데 우리는 api call을 통한 실행을 할 것이므로 <code>api gateway</code>를 선택하고 <code>next</code>를 누른다.<br><img src="https://lh3.googleusercontent.com/Y5RrAUzYbGCZF1Ei9TI8G8r3rNkEDVtTJxp3unq9N3-CNRfo0oEeLVlD2bBDqmqOM0hNmD5Z4TO-aV7URlndgAjXAHxW5ADU98mW1W-mvbqVIu8mtvdKS8ujNd0Xsxez_jbosmy3zxWeRlyk9tSz3qpm1sNcY3UqWmEYoIyuDUUmhsHAtuW74XnHU93Vq49XQtL6sdOLjUI6QC2Ts3XMR2v6752ZIaISRPXpmxZRpOB6x6ZXXErJ_poJMDqjoCoZJDmtST2ry3-T9tdnz37S-SvuD03g6EmF2ogILD8amHdycwkQWEVKiSNLBiw2-i_gjhIgov7nKowMCPI0BuJRnxyTC7WGitmCjsdtj7nV_G13gvQVz-4CkdOp3EKTwgEjZxq3zzfbpA-wbhgYSoAdSVtzxpwRA1WMIPvhNk7FAp0Afte0hvTaX807p9qvmJgkTw0ebaLV5Aj_M-COz2Mo7vScyYC2Rauan_O3Iu6KlXSNG-5zzF4u0cFjCWnv38xbscccKYZ3kOoY40gt0WajQ0OHG3IFG0YuAS4DUXn_pItE_b_oPaqNRehKPgK1CkcHZlK_1dlYlHRCJZ0dkkWFMirpJ6KpWJbeNEfimzM6KKRkfjg9jg=w1218-h546-no" alt=""></p><p><code>configuration function</code> 에서는 함수에 대한 설정을 한다. 아래와 같이 설정한다.</p><table><thead><tr><th>config</th><th>value</th></tr></thead><tbody><tr><td>Name</td><td>loopbackArgument</td></tr><tr><td>Description</td><td></td></tr><tr><td>Runtime</td><td>Node.js 4.3</td></tr><tr><td>code entry type</td><td>Edit code inline)</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exports.handler = <span class="function">(<span class="params">event, context, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    callback(<span class="literal">null</span>, &#123;</span><br><span class="line">        event: event,</span><br><span class="line">        context: context</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>export</code>할 함수 이름을 정하고(여기선 <code>handler</code>) lambda의 signiture대로 3개의 인자를 받는다. 인자를 간략히 설명하면 다음과 같다.</p><table><thead><tr><th>argument</th><th>description</th></tr></thead><tbody><tr><td>event</td><td>event call에 대한 정보로 parameter, header등이 이 인자로 매핑된다.</td></tr><tr><td>context</td><td>lambda 함수 자체에 대한 정보</td></tr><tr><td>callback</td><td>리턴함수라고 생각하면된다, 첫 번째 인자는 Error 객체, 첫 번째 인자가 null 경우 성공으로 간주되고 2번째 인자가 응답값으로 사용된다.</td></tr></tbody></table><p>이 코드는 단순히 람다 함수의 인자를 그대로 응답하는 <code>handler</code>함수를 반환하고 있다.</p><p>이 외는 기본 설정을 이용하며 <code>role</code>을 정해줘야하는데 이전에 람다를 위한 role을 만들지 않았다면 생성 후 선택하고 <code>next</code>를 함수를 생성한다.</p><h2><span id="api-gateway-lambda-함수-연결parameter-header-설정">api gateway - lambda 함수 연결(parameter, header 설정)</span></h2><p><code>api gateway</code>에서는 라우팅 테이블을 만들때 swagger를 지원한다. 기 구현된 서버가 swagger를 통해 문서화가 되어 있다라면 serverless architecture를 바로 적용할 수 있을 것으로 보인다.<br>특히 swagger에 <a href="http://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html" target="_blank" rel="noopener">api gateway extensions</a>가 존재하는데 이 부분을 swagger에 함께 작성하게 되면 파라메터나 응답값에 대한 정의를 문서 작성 단계에서 끝낼 수 있다.</p><p>이제 <code>api gateway</code>를 설정할 차례다.</p><h3><span id="api-생성">API 생성</span></h3><p><a href="https://console.aws.amazon.com" target="_blank" rel="noopener">aws console</a> 을 통해 api gateway 서비스에 접속한 후 <code>APIs</code> 메뉴에서 <code>Create API</code>를 누른다.</p><p>New API를 선택하고 <code>API name</code>에 <code>test</code> 라고 작성한다.<br>Actions를 눌러 <code>Create Method</code>를 선택하고 <code>post</code>를 선택한후 check 버튼을 눌러 생성한다.<br>이러면 생성한 <code>POST</code> method에 대해 setup하는 화면이 나오고 이미지와 같이 설정을 하여 위에서 작성한 <code>lambda</code> 함수를 연결한다.</p><p><img src="https://lh3.googleusercontent.com/BF-csXtOhMEE6WspJMUm7eZ7c6cr7_aM0Swxx_DFf0JXhE2c1TwVsB3REoLH30XMkyqQ01kiqZzwNumbqLkbpJ8ZUvj1PlXBK599B7kdjy2w38j9OXxwjtyRWo1rrve2TtxcQfaB5RKJrXmMtRiqiTW4Ojx0gig0NblF-l1sefCvQQuAmHDwDihrN0CYvXgRgPIIkV42kH4CW_tUX2rJtdCisScuSp2iJfc8I6piFwXKIIIWtiUFm7aNRFWds9norKHmpZFg9tJNCW6NdGvA_NsB4phrz-i286cgxUqL_UPvrksJ-_vvRAEm4NKi0cvw3qoRa8cDHQJHe-RAZKgcJgrSuyKkv6j8-Qw3MWVAB_ISlObYFAiEL-kt7C4fJ67zRGFa_BQp9dX1EnJZhSLXJ6jA_9RI63uxxrSuMvc0TBOHCwUtH6R5GvjMp_RpSVdHVrCoPYmKJ-qRPZre7SHnz5n9tfgSUfY97hiFLze-EeqYD8Ydc_dYrzyREgMhe-E8xxOzhfTgqQc-jarA-v2HpTiovD8g5AG_gLEbUhvISQJGRaUZXiCeRW-EZ8phipGYN5h5Yz9A7250P6T_9gFvNSGTb_vJKUeTBEL16jM96GdZzLj3Ww=w783-h400-no" alt=""></p><p>물론 함수명과 리전은 작업중인 상황에 맞게 넣어야한다.</p><h3><span id="api-설정">API 설정</span></h3><h4><span id="method-request">Method Request</span></h4><p>설정할 것은 없지만 <code>header</code>와 <code>query string</code>이 들어오는 것을 확인하기 위해 이미지와 같이 추가해 둔다.<br><img src="https://lh3.googleusercontent.com/vGNzrnq8mtX_glpQje0FTPMxqrXSkLpzEgWdDvfRe3oTCy-5dl40FLX9PhS1-i1tE6ECxszAc6U2jcWU3IvcP5tHLE20pmC4SNWx_uF7_bXlBWipFAENk11BSNIgFkws73UNRw2UycbSAp1q1uP7k69dWvuTGf3w2-w3uLcyUBKOSHukkFyFVBjd84nFHNm8b-sDr2RTE6sOdXQtJNsO0oQ6rOzgxu608HLW-iuS-LIdtMx6nNx92OONE-45P4Q05OlrT5QMNloXw2xr4xr-Ri5tq1EYcBbVm24PrePbUgpOhl9ZqKq_MZq-4pwMoYBWNSer4RCyJCuZxwATNn5ylEexzVLKaAYodFPwSFLbQ9ISL5-sZH0ZRVaAq0a1ZHM94bawcO50hOBjfagTF9Lamdc459-QLfk-TJlmHvg6BWWmyj17FAs8hT8Wn8FEKwBHOzmKj96JQOATff4grr2ZCFhM3H_XxF5JgFYkuPjUEOl91oJB3o14KLat8tIYcEmikC-lB6mafVXELgrYUVNDvqTDId3PFbKdDNdXYKevjk-XuSLgL3k7dticdFtCNhTfKSKpUA6MfX4A7wqgiYuJcK69gylm_vGUg1hoXzhWY7Ny2xo4Hw=w1192-h705-no" alt=""></p><h4><span id="integration-request">Integration Request</span></h4><p>여기선 <code>Method Request</code>에서 설정한 parameter 들을 받기 위한 설정인데 기본 템플릿을 적용하여 아래 이미지와 같이 설정한다.<br><img src="https://lh3.googleusercontent.com/yrQo0p55cgPUD7xTWGpXznNhTalanKmSUtGMWKBTGRNFTuhd3xBZRtlKc9sxsvtYBQclLVeRMvsxhHMC29ONSJ_aXoIqKKSFxulBV2_EDCAd6QuDlu8z5S2dceF1Qj-Es8SjbAg8uE-S0ttxZZIAGvIISN4vK7Y623GnEKb2RhVKPBQW-JB5FN9qgTtYVmCSwDLny9-QFXg7lRZtOeB82Wgn2SiycGyd-wNTyxe6j4cQV12umkC9czZvn2QAwRX_Xl6mzK6nDtoqvXbebe31hxAUUc2DzVnywpIO0LH33a1-vg2KF2Uau9VMfsk0SlC2B-QkXTUdkQSuVDrXN0VXrAfSSiGT6RCF2XwMm9vbK81JV6IH_jlcwxN2jufquEgjMugBCNa0hPFIs4vyj-747FT_9mp-dAlKYWGUF0Cf3rZpE-B-n4nZdiV175Cz0KLVoIuF26cgR2W0SbK2HBxIY3xMdJBnHmwOmr40ailQXudRvPzHXbJk6bS2eYKpz53kAdOOHLHbqHPYgSIKLDtT3CDF4RKQGc-FSkzUcDM93zqYUnGLvcRu2AESbRqq2D6GIjEP_WUUhsUsOtnljyzIvt-BWYNzU8bgD3jUndCmN0cZz_cAQg=w960-h597-no" alt=""></p><h3><span id="api-deploy">API Deploy</span></h3><p>사용을 위해 Resources 옆 Actions 를 선택하고 <code>Deploy API</code>를 선택한다.</p><p><img src="https://lh3.googleusercontent.com/wFO9ggX6eq_T46j0iEYnzGS1yMy74cNWPY9mGU9GhijI2hIxgfut6emscJ607db5BlGgZNPCbcQgBPCKUvYfKtCm3wpZx1xK0mE5-4-i7ABIpDH7GmSAv5o67gPalQTXsFwSvrW0havFns21c3H-PLd-rA80gm-typkeWRxbjKWgM54-gEjAiC2FVEGNdYaso9SQWsnujEUgschszxMhhRaJzC05zD8-L2Nd6ZW4b94ii_xzYjoz4bNrqQiGvMuDExiatSj8AcTg_KsGhm-FgctyyZX0zP8smvh89_sSyLE37y3baz5-9tq9Te42Mkfhj0pIO6zW-lP0ONVYyQhVjtBeZcW4RPzwsfXwunBE_t7vmPGC7yNtRPHChqtBP37XHjNkMNIR4ADhPr_Uyu_yhvk76Gzxw0JXuJATFg9DeT-Ct88_-nLG-9jzb4j1_RgZW0LAgL-BiUObujoweBDBcbmhAlpHP63DZZQ5FeBSyxAVx1u_0vKO8O7qENNDOmOFpiWlrzkjf9YS5OhkQsplCnSUQnjIpVm8K5aQCix8DcvxXhxfpkv_0ZLi5ym6GWLChP8T3-oru4ylc4lgSZwm7K9QUKvyzHbwWakSZGsrguDe2EcvfQ=w599-h412-no" alt=""></p><p>이미지와 같이 <code>[New Stage]</code> 로 <code>prod</code>를 입력 후 deploy 버튼을 누르면 <code>Stages</code> 화면으로 진입하면서 <code>endpoint</code>가 될 url이 <code>Invoke URL</code> 이라는 이름으로 보인다.<br>이제 이 url을 통해 api call 이 가능하며 당장 <code>postman</code>이나 <code>curl</code>등을 통해 확인이 가능하다.</p><p>1차적으로 <code>api gateway</code>와 <code>lambda</code>함수를 연결해서 실행을 확인해 볼 수 있는 상태가 되었다.</p><h2><span id="development-production-모드를-분리하기-위한-stage-활용">development, production 모드를 분리하기 위한 stage 활용</span></h2><p>작성한 코드를 실행해보면 아래와 같은 형태의 <code>json</code>이 응답으로 전달됨을 확인 할 수 있다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"event"</span>: &#123;</span><br><span class="line">    <span class="attr">"body-json"</span>: &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    "params": &#123;</span><br><span class="line">      "path": &#123;&#125;,</span><br><span class="line">      "querystring": &#123;</span><br><span class="line">        "deptno-param": "deptno test"</span><br><span class="line">      &#125;,</span><br><span class="line">      "header": &#123;</span><br><span class="line">        "Authorization": "deptno test"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "stage-variables": &#123;&#125;,</span><br><span class="line">    "context": &#123;,</span><br><span class="line">      "http-method": "POST",</span><br><span class="line">      "stage": "prod",</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "context": &#123;</span><br><span class="line">    "memoryLimitInMB": "128",</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Integration Request</code>에서 설정한 기본 템플릿을 통해 전달된 event 오브젝트와 context 객체의 내용이 구현한 함수의 기능대로 동작한다면 위와 같은 결과 값을 받을 수 있으며, 코드에 보여지는 부분들은 자주 참조 되는 영역만을 코드에 표시했다.</p><p>event 객체의 구조는 앞으로 사용할 lambda 함수에서 event 객체를 사용하는 <code>reference</code>가 된다.<br>보면 <code>event</code> 에도 <code>context</code>가 존재하는데 여기에 <code>stage</code> property가 있고 우리가 deploy했던 stage를 참조할 수 있는데 이를 통해 (프로덕션 코드와 개발코드가 분리되는데 맞지만) lambda 함수에서 개발 버전 또는 배포 버전의 일에 대해 분기를 할 수 있게 된다.</p><h2><span id="travis-ci를-통한-배포-자동화">travis ci를 통한 배포 자동화</span></h2><p>code로 대신한다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">- provider:</span> <span class="string">lambda</span></span><br><span class="line"><span class="attr">  function_name:</span> <span class="string">loopbackArgument</span></span><br><span class="line"><span class="attr">  role:</span> <span class="attr">arn:aws:iam::...</span></span><br><span class="line"><span class="attr">  handler_name:</span> <span class="string">handler</span></span><br><span class="line"><span class="attr">  region:</span> <span class="string">ap-northeast-2</span></span><br><span class="line"><span class="attr">  access_key_id:</span> <span class="string">...</span></span><br><span class="line"><span class="attr">  secret_access_key:</span></span><br><span class="line"><span class="attr">    secure:</span> <span class="string">...</span></span><br><span class="line"><span class="attr">  runtime:</span> <span class="string">nodejs4.3</span></span><br><span class="line"><span class="attr">  timeout:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><p>조금 부연하자면</p><ul><li><code>role</code>은 lambda함수를 생성할 때 줬던 role(lambda 함수 실행을 위한) 이 들어가야된다.</li><li>추가적으로 메모리 사용량 설정등도 가능하다.</li><li>s3를 통해 업로드하는 방식과 달리 폴더를 압축해서 zip파일을 업로드하게 되는데 이때 용량제한이 걸린다. 압축한 파일을 용량이 <code>50MB</code>를 넘어가면 deploy에 실패하게 되니 주의하자.<ul><li>이 때는 s3에 upload 하고 추가로 스크립팅을 통해 deploy 되야하므로 번거로워진다.</li></ul></li></ul><h2><span id="next">next</span></h2><blockquote><p>실무 적용 및 효율 적인 업무를 위한 추가 적인 작업들은 아래와 같다.</p></blockquote><p>todo</p><ul><li>custom domain을 통한 배포<ul><li>ssl 적용</li></ul></li><li>api gateway<ul><li>cors 적용</li></ul></li><li>swagger를 통한 문서화 및 배포</li><li>slack을 통한 알림 처리</li></ul>]]></content>
    
    <summary type="html">
    
      aws serverless architecture 의 핵심에 api gateway 와 lambda 가 있다. 두 서비스는 모드 서울 리전에서 사용이 가능하다. 이를 이용하여 프로토타입을 작성해 보자.
    
    </summary>
    
      <category term="dev" scheme="http://blog.bglee.me/categories/dev/"/>
    
      <category term="aws" scheme="http://blog.bglee.me/categories/dev/aws/"/>
    
    
      <category term="aws" scheme="http://blog.bglee.me/tags/aws/"/>
    
      <category term="ci" scheme="http://blog.bglee.me/tags/ci/"/>
    
      <category term="api gateway" scheme="http://blog.bglee.me/tags/api-gateway/"/>
    
      <category term="lambda" scheme="http://blog.bglee.me/tags/lambda/"/>
    
      <category term="travis" scheme="http://blog.bglee.me/tags/travis/"/>
    
      <category term="lambda 배포" scheme="http://blog.bglee.me/tags/lambda-%EB%B0%B0%ED%8F%AC/"/>
    
  </entry>
  
</feed>
